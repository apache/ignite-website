"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[4052],{40467:(e,s,a)=>{a.r(s),a.d(s,{default:()=>o});a(96540);var i=a(19766),t=a(28774),n=a(5260),r=a(40830),c=a(74848);function o(){const e=(0,r.lZ)();return(0,c.jsxs)(i.A,{children:[(0,c.jsxs)(n.A,{children:[(0,c.jsx)("title",{children:"ACID Transactions - Apache Ignite"}),(0,c.jsx)("meta",{name:"description",content:"Apache Ignite provides full ACID transactions across any number of partitions. MVCC enables snapshot isolation without blocking readers. Distributed replication ensures durability."}),(0,c.jsx)("link",{rel:"canonical",href:e}),(0,c.jsx)("meta",{property:"og:title",content:"ACID Transactions - Apache Ignite"}),(0,c.jsx)("meta",{property:"og:type",content:"article"}),(0,c.jsx)("meta",{property:"og:url",content:e}),(0,c.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,c.jsx)("meta",{property:"og:description",content:"Apache Ignite provides full ACID transactions across any number of partitions. MVCC enables snapshot isolation without blocking readers. Distributed replication ensures durability."})]}),(0,c.jsx)("section",{className:"innerhero",children:(0,c.jsxs)("div",{className:"container innerhero__cont",children:[(0,c.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,c.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,c.jsx)("h1",{className:"h1 innerhero__h1",children:"ACID Transactions"}),(0,c.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Full ACID across any number of partitions"})]}),(0,c.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"ACID Transactions"})]})}),(0,c.jsx)("section",{className:"container pt-5 pb-5",children:(0,c.jsx)("div",{className:"pt-3 pb-3",children:(0,c.jsx)("p",{className:"fz20",children:"Apache Ignite delivers full ACID transactions across any number of partitions. MVCC provides snapshot isolation without blocking readers. Distributed replication ensures durability. Lock tables, transaction state, and commit decisions all remain in memory."})})}),(0,c.jsxs)("section",{className:"nativepersistence3 container",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Snapshot Isolation Without Blocking"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"MVCC Foundation"}),(0,c.jsx)("p",{children:"Every write creates a new version tagged with a timestamp. Transactions read from a snapshot determined by their start time. Readers and writers never block each other. This delivers REPEATABLE_READ isolation without traditional locking overhead."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Version Management"}),(0,c.jsx)("p",{children:"The system maintains multiple versions until older snapshots complete. Storage engines handle version cleanup automatically. Analytical queries execute on stable snapshots while transactional updates proceed at full speed."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Read Consistency"}),(0,c.jsx)("p",{children:"Transactions see a consistent snapshot of the database at their start time. Long-running reads don't block operational writes. No phantom reads. No non-repeatable reads. Snapshot isolation protects against anomalies."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Write Conflicts"}),(0,c.jsx)("p",{children:"The system detects write-write conflicts during commit. Conflicting transactions abort with serialization errors. Applications can retry failed transactions. This provides safety without requiring locks during execution."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Distributed Durability"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Consensus-Based Commit"}),(0,c.jsx)("p",{children:"Transactions commit through Raft consensus. The system replicates transaction changes through the distributed consensus log. Data becomes durable once replicated to a majority of replicas. No local write-ahead log needed."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Cross-Partition Coordination"}),(0,c.jsx)("p",{children:"Transactions span any number of partitions. A coordinator manages distributed commit protocol. All participating partitions must agree before commit completes. Failures trigger automatic rollback across all partitions."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Failure Handling"}),(0,c.jsx)("p",{children:"The system handles node failures during transaction execution. Ongoing transactions on failed nodes abort automatically. Committed transactions remain durable through replication. No data loss after commit acknowledgment."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Performance Characteristics"}),(0,c.jsx)("p",{children:"Lock tables and transaction state live in memory. Commit decisions execute without disk I/O. Durability comes from distributed replication rather than local logging. This delivers transactional guarantees with memory-first performance."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Isolation Levels"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"REPEATABLE_READ (Default)"}),(0,c.jsx)("p",{children:"The default isolation level provides snapshot isolation. Transactions see a consistent snapshot from their start time. Prevents dirty reads, non-repeatable reads, and phantom reads. Write conflicts detected at commit time."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"READ_COMMITTED"}),(0,c.jsx)("p",{children:"Each statement sees committed data as of statement start. Lower isolation provides better concurrency for read-heavy workloads. Still prevents dirty reads. Non-repeatable reads and phantom reads possible within transaction."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Choosing Isolation"}),(0,c.jsx)("p",{children:"Use REPEATABLE_READ for transactions requiring consistent snapshots across multiple operations. Use READ_COMMITTED when statement-level consistency suffices and you need maximum read concurrency. Both levels prevent dirty reads."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Concurrency Control"}),(0,c.jsx)("p",{children:"Both isolation levels use optimistic concurrency. No locks held during transaction execution. Conflicts detected at commit. Applications retry on serialization failures. This approach maximizes throughput for memory-first operations."})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/09-streaming.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Event Stream Processing"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Process event streams with ACID guarantees. Update multiple aggregations atomically. Maintain consistency across derived tables. Rollback on processing errors. Transactions ensure exactly-once semantics."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/event-stream-processing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/06-compute-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Microservices State"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Store microservices state with transactional consistency. Coordinate state updates across services. Maintain referential integrity without external coordination. Achieve consistency without distributed transaction managers."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Analytical Queries"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Run analytical queries on stable snapshots. Long-running aggregations don't block updates. Queries see consistent data across all partitions. MVCC enables mixed workloads without interference."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"How Transactions Connect to the Foundation"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"MVCC Enables Isolation"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Multi-Version Concurrency Control provides snapshot isolation without locks. Version chains support concurrent reads and writes. Readers never block writers. Writers never block readers. This foundation enables ACID with memory-first performance."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About MVCC"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Distributed Replication Ensures Durability"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Raft consensus provides durability without traditional write-ahead logs. Transaction changes replicate through the distributed consensus log. Majority replication ensures durability. No local WAL overhead."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Coordination"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Lock tables, transaction state, and commit decisions live in memory. No disk I/O for coordination. Distributed commit protocol executes against in-memory state. This delivers transactional guarantees with minimal latency."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]})]})]}),(0,c.jsx)("section",{className:"native-bottom container",children:(0,c.jsxs)("div",{className:"native-bottom__grid",children:[(0,c.jsxs)("article",{className:"nativebotblock",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Ready to Start?"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,c.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Read Documentation"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Learn about transaction isolation levels, commit protocols, and error handling"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/develop/work-with-data/transactions",target:"_blank",rel:"noreferrer",children:"Transactions Documentation"})]})]})})]})}},40830:(e,s,a)=>{a.d(s,{lZ:()=>n});var i=a(56347),t=a(44586);function n(){const e=(0,i.zy)(),{siteConfig:s}=(0,t.A)();let a=e.pathname;return"/"!==a&&a.endsWith("/")&&(a=a.slice(0,-1)),`${s.url}${a}`}}}]);