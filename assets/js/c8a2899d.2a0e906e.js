"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[4925],{28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>r});var i=a(96540);const n={},s=i.createContext(n);function o(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},56100:e=>{e.exports=JSON.parse('{"permalink":"/blog/2018/05/31/apache-ignite-2-5-scaling","editUrl":"https://github.com/apache/ignite-website/tree/master/blog/2018-05-31-apache-ignite-2-5-scaling.mdx","source":"@site/blog/2018-05-31-apache-ignite-2-5-scaling.mdx","title":"Apache Ignite 2.5: Scaling to 1000s Nodes Clusters","description":"Apache Ignite was always appreciated by its users for two primary things it delivers - scalability and performance. Throughout the lifetime many distributed systems tend to do performance optimizations from a release to release while making scalability related improvements just a couple of times. It\'s not because the scalability is of no interest. Usually, scalability requirements are set and solved once by a distributed system and don\'t require significant additional interventions by engineers.","date":"2018-05-31T00:00:00.000Z","tags":[{"inline":true,"label":"apache","permalink":"/blog/tags/apache"},{"inline":true,"label":"database","permalink":"/blog/tags/database"},{"inline":true,"label":"ignite2","permalink":"/blog/tags/ignite-2"},{"inline":true,"label":"spark","permalink":"/blog/tags/spark"},{"inline":true,"label":"sql","permalink":"/blog/tags/sql"},{"inline":true,"label":"archived","permalink":"/blog/tags/archived"}],"readingTime":5.29,"hasTruncateMarker":true,"authors":[{"name":"Denis Magda","title":"Apache Ignite PMC Member","url":"https://github.com/dmagda","imageURL":"/img/authors/dmagda.png","key":"denis","page":null}],"frontMatter":{"title":"Apache Ignite 2.5: Scaling to 1000s Nodes Clusters","authors":["denis"],"date":"2018-05-31T00:00:00.000Z","tags":["apache","database","ignite2","spark","sql","archived"]},"unlisted":false,"prevItem":{"title":"Apache Ignite 2.7: Deep Learning and Extended Languages Support","permalink":"/blog/2018/12/13/apache-ignite-2-7-deep"},"nextItem":{"title":"Apache Ignite 2.4 Brings Advanced Machine Learning and Spark DataFrames Capabilities","permalink":"/blog/2018/03/15/apache-ignite-2-4-brings"}}')},77273:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=a(56100),n=a(74848),s=a(28453);const o={title:"Apache Ignite 2.5: Scaling to 1000s Nodes Clusters",authors:["denis"],date:new Date("2018-05-31T00:00:00.000Z"),tags:["apache","database","ignite2","spark","sql","archived"]},r=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){const t={p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Apache Ignite was always appreciated by its users for two primary things it delivers - scalability and performance. Throughout the lifetime many distributed systems tend to do performance optimizations from a release to release while making scalability related improvements just a couple of times. It's not because the scalability is of no interest. Usually, scalability requirements are set and solved once by a distributed system and don't require significant additional interventions by engineers."}),"\n",(0,n.jsx)(t.p,{children:"However, Apache Ignite grew to the point when the community decided to revisit its discovery subsystem that influences how well and far Ignite scales out. The goal was pretty clear - Ignite has to scale to 1000s of nodes as good as it scales to 100s now."}),"\n",(0,n.jsx)(t.p,{children:"It took many months to get the task implemented. So, please join me in welcoming Apache Ignite 2.5 that now can be scaled easily to 1000s of nodes and goes with other exciting capabilities. Let's check out the most prominent ones."})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);