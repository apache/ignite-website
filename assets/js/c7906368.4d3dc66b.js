"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[5197],{40830:(e,s,a)=>{a.d(s,{lZ:()=>n});var i=a(56347),t=a(44586);function n(){const e=(0,i.zy)(),{siteConfig:s}=(0,t.A)();let a=e.pathname;return"/"!==a&&a.endsWith("/")&&(a=a.slice(0,-1)),`${s.url}${a}`}},74460:(e,s,a)=>{a.r(s),a.d(s,{default:()=>r});a(96540);var i=a(19766),t=a(28774),n=a(5260),c=a(40830),o=a(74848);function r(){const e=(0,c.lZ)();return(0,o.jsxs)(i.A,{children:[(0,o.jsxs)(n.A,{children:[(0,o.jsx)("title",{children:"Schema-Driven Data Placement - Apache Ignite"}),(0,o.jsx)("meta",{name:"description",content:"Apache Ignite uses schema-driven colocation to keep related data together. The colocateBy annotation transforms cross-node queries into local memory operations. Distribution zones control replica counts and node placement."}),(0,o.jsx)("link",{rel:"canonical",href:e}),(0,o.jsx)("meta",{property:"og:title",content:"Schema-Driven Data Placement - Apache Ignite"}),(0,o.jsx)("meta",{property:"og:type",content:"article"}),(0,o.jsx)("meta",{property:"og:url",content:e}),(0,o.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,o.jsx)("meta",{property:"og:description",content:"Apache Ignite uses schema-driven colocation to keep related data together. The colocateBy annotation transforms cross-node queries into local memory operations. Distribution zones control replica counts and node placement."})]}),(0,o.jsx)("section",{className:"innerhero",children:(0,o.jsxs)("div",{className:"container innerhero__cont",children:[(0,o.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,o.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,o.jsx)("h1",{className:"h1 innerhero__h1",children:"Schema-Driven Data Placement"}),(0,o.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Keep related data together. Query locally."})]}),(0,o.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Data Placement"})]})}),(0,o.jsx)("section",{className:"container pt-5 pb-5",children:(0,o.jsx)("div",{className:"pt-3 pb-3",children:(0,o.jsx)("p",{className:"fz20",children:"Apache Ignite uses schema-driven colocation to keep related data together. The colocateBy annotation in table definitions specifies which columns control data placement. Related rows store on the same node. This transforms cross-node queries into local memory operations."})})}),(0,o.jsxs)("section",{className:"nativepersistence3 container",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Colocation Through Schema Annotations"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"The colocateBy Annotation"}),(0,o.jsx)("p",{children:"Table definitions specify colocation keys using the colocateBy annotation. All rows with the same colocation key values store on the same partition. The system calculates partition assignments from colocation key hashes. This deterministic placement enables partition-aware operations."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Common Colocation Patterns"}),(0,o.jsx)("p",{children:"Colocate orders with customers. Colocate line items with orders. Colocate related business entities. The pattern: parent entity key becomes child entity colocation key. This keeps hierarchies together for local joins."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Local Joins"}),(0,o.jsx)("p",{children:"Joins between colocated tables execute entirely on the node holding the data. No network traffic for join operations. Query execution happens in memory on a single node. This delivers join performance comparable to single-node databases at distributed scale."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Partition-Aware Routing"}),(0,o.jsx)("p",{children:"The Table API calculates partition ownership from keys. Operations route directly to nodes holding the data. Single-hop access eliminates coordinator overhead. This works for point lookups, batch operations, and colocated queries."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Distribution Zones"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Replica Configuration"}),(0,o.jsx)("p",{children:"Distribution zones define replica counts for table groups. Tables in the same zone share replication settings. Specify replica counts from 1 to cluster size. Higher replica counts increase availability and read throughput at the cost of write amplification."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Node Filters"}),(0,o.jsx)("p",{children:"Distribution zones support node filters based on attributes. Restrict data to specific node subsets. Place hot data on high-memory nodes. Place archive data on cost-optimized nodes. This enables heterogeneous cluster configurations."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Data Rebalancing"}),(0,o.jsx)("p",{children:"The system rebalances data automatically when topology changes. Adding nodes triggers partition migration. Removing nodes redistributes data. Rebalancing maintains target replica counts and respects node filters throughout topology changes."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Zone Management"}),(0,o.jsx)("p",{children:"Create zones with SQL DDL or management APIs. Assign tables to zones during table creation. Modify zone settings without recreating tables. The system applies changes atomically across the cluster."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Performance Characteristics"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Network Elimination"}),(0,o.jsx)("p",{children:"Colocated operations execute without network I/O. Joins process in memory on single nodes. Aggregations work on local partitions. This eliminates the network bottleneck that limits distributed query performance."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Cache Efficiency"}),(0,o.jsx)("p",{children:"Related data residing together improves CPU cache efficiency. Sequential scans benefit from memory locality. Index lookups access fewer cache lines. This memory-level optimization compounds with network elimination for maximum throughput."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Scalability"}),(0,o.jsx)("p",{children:"Colocation scales linearly with cluster size. Each node processes its partition data independently. Adding nodes increases total cluster capacity proportionally. No centralized coordination limits throughput."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Trade-offs"}),(0,o.jsx)("p",{children:"Colocation requires careful schema design. Choose colocation keys based on query patterns. Non-colocated joins require data shuffling. The system optimizes for colocated operations, accepting higher cost for cross-partition queries."})]})]})]}),(0,o.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,o.jsxs)("div",{className:"cardswrap",children:[(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Multi-Tenant Applications"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Colocate all tenant data by tenant ID. Tenant queries execute locally without cross-node traffic. Achieve single-tenant performance in multi-tenant systems. Scale tenants horizontally by adding nodes."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/06-compute-APIs.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"E-Commerce Systems"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Colocate orders, line items, and shipping records by order ID. Order processing queries execute locally. Inventory checks, pricing calculations, and order totals compute in memory. No network overhead for transaction processing."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/use-cases/high-performance-computing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/09-streaming.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Time-Series Analytics"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Colocate metrics by device ID or customer ID. Time-range queries execute locally per device. Aggregations compute on single nodes. This pattern works for IoT telemetry, financial tick data, and application metrics."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,o.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-4",children:"How Data Placement Connects to the Foundation"}),(0,o.jsxs)("div",{className:"cardswrap",children:[(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Operations"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Colocated operations execute against in-memory data. Local joins access memory without disk I/O. This memory-first approach combined with colocation delivers the performance needed for complex queries at scale."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Distributed Replication for Availability"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Distribution zones use Raft-based replication. Each partition replicates across configured replica count. Data remains available during node failures. Colocation works transparently with replication."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"SQL and Table API Integration"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Colocation works identically for SQL and Table API. Schema annotations drive placement for both access patterns. This unified approach simplifies application development."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/sql",className:"cardsimple__button button button--shadow",children:"Learn About Access Patterns"})})]})]})]}),(0,o.jsx)("section",{className:"native-bottom container",children:(0,o.jsxs)("div",{className:"native-bottom__grid",children:[(0,o.jsxs)("article",{className:"nativebotblock",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Ready to Start?"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,o.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Read Documentation"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Learn about colocation keys, distribution zones, and data placement strategies"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/configure-and-operate/operations/colocation",target:"_blank",rel:"noreferrer",children:"Colocation Documentation"})]})]})})]})}}}]);