"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[1955],{7429:(e,s,a)=>{a.r(s),a.d(s,{default:()=>o});a(96540);var t=a(19766),i=a(28774),n=a(5260),c=a(40830),r=a(74848);function o(){const e=(0,c.lZ)();return(0,r.jsxs)(t.A,{children:[(0,r.jsxs)(n.A,{children:[(0,r.jsx)("title",{children:"Processing Where Data Lives - Apache Ignite"}),(0,r.jsx)("meta",{name:"description",content:"Apache Ignite executes compute jobs on nodes holding the data. Colocated compute eliminates network overhead. Works with colocation and memory-first storage for local aggregations and transformations."}),(0,r.jsx)("link",{rel:"canonical",href:e}),(0,r.jsx)("meta",{property:"og:title",content:"Processing Where Data Lives - Apache Ignite"}),(0,r.jsx)("meta",{property:"og:type",content:"article"}),(0,r.jsx)("meta",{property:"og:url",content:e}),(0,r.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,r.jsx)("meta",{property:"og:description",content:"Apache Ignite executes compute jobs on nodes holding the data. Colocated compute eliminates network overhead. Works with colocation and memory-first storage for local aggregations and transformations."})]}),(0,r.jsx)("section",{className:"innerhero",children:(0,r.jsxs)("div",{className:"container innerhero__cont",children:[(0,r.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,r.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,r.jsx)("h1",{className:"h1 innerhero__h1",children:"Processing Where Data Lives"}),(0,r.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Execute compute jobs on nodes holding the data"})]}),(0,r.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Compute APIs"})]})}),(0,r.jsx)("section",{className:"container pt-5 pb-5",children:(0,r.jsx)("div",{className:"pt-3 pb-3",children:(0,r.jsx)("p",{className:"fz20",children:"Apache Ignite executes compute jobs on nodes holding the data. This colocated compute pattern eliminates network overhead. Jobs access memory-resident data directly. Combined with schema-driven colocation, this enables complex operations at memory speed without data movement."})})}),(0,r.jsxs)("section",{className:"nativepersistence3 container",children:[(0,r.jsx)("h2",{className:"h4 pb-3",children:"Colocated Compute"}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Data Locality"}),(0,r.jsx)("p",{children:"The Compute API schedules jobs on nodes holding relevant data partitions. No data movement across the network. Jobs read and write local memory directly. This eliminates the network bottleneck that limits traditional distributed processing."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"Key-Based Routing"}),(0,r.jsx)("p",{children:"Submit jobs with specific keys. The system routes jobs to nodes holding those keys. Works with colocation to ensure jobs and data reside together. This single-hop execution delivers minimal latency for targeted operations."})]})]}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Partition-Wide Operations"}),(0,r.jsx)("p",{children:"Execute jobs across entire partitions. The job receives all rows in the partition as input. Process partition data sequentially or build in-memory indexes. This enables operations that require full partition visibility."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"Broadcast Execution"}),(0,r.jsx)("p",{children:"Broadcast jobs to all nodes for cluster-wide operations. Each node processes its local partitions independently. Results aggregate at the coordinator. This pattern works for parallel aggregations and distributed transformations."})]})]})]}),(0,r.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,r.jsx)("h2",{className:"h4 pb-3",children:"Compute Job Patterns"}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Stateless Jobs"}),(0,r.jsx)("p",{children:"Submit jobs that read data, perform calculations, and return results. No state persists between invocations. Jobs implement simple Java methods. The system handles serialization, routing, and result collection automatically."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"MapReduce Operations"}),(0,r.jsx)("p",{children:"Implement map-reduce patterns with compute jobs. Map phase executes on data-holding nodes. Reduce phase aggregates results. The framework handles distribution and coordination. This provides map-reduce semantics without separate systems."})]})]}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Async Execution"}),(0,r.jsx)("p",{children:"Compute API returns CompletableFuture for non-blocking operations. Submit multiple jobs in parallel. Compose operations with async combinators. This enables high-concurrency compute workloads without thread exhaustion."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"Error Handling"}),(0,r.jsx)("p",{children:"Jobs execute within try-catch blocks. Exceptions propagate to caller as CompletionException. The system handles node failures transparently. Failed jobs retry on other nodes holding the same data partitions."})]})]})]}),(0,r.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,r.jsx)("h2",{className:"h4 pb-3",children:"Integration with Data Layer"}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Table API Access"}),(0,r.jsx)("p",{children:"Compute jobs access tables through RecordView and KeyValueView. Same partition-aware semantics as client access. Local reads avoid network overhead. This provides consistent programming model across client and compute layers."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"SQL Execution"}),(0,r.jsx)("p",{children:"Compute jobs can execute SQL queries on local partitions. Filter and aggregate local data with SQL. Combine procedural logic with declarative queries. This enables complex business logic at the data layer."})]})]}),(0,r.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,r.jsxs)("div",{className:"nativepersistence3__left",children:[(0,r.jsx)("h3",{className:"h5",children:"Transaction Support"}),(0,r.jsx)("p",{children:"Compute jobs execute within transactions. Begin transactions in compute code. Read and write data transactionally. Commit or rollback based on business logic. This ensures consistency for complex multi-step operations."})]}),(0,r.jsxs)("div",{className:"nativepersistence3__right",children:[(0,r.jsx)("h3",{className:"h5",children:"Memory-First Performance"}),(0,r.jsx)("p",{children:"Compute jobs operate on memory-resident data. No disk I/O during execution. MVCC provides snapshot isolation for read operations. This delivers the performance needed for real-time compute workloads."})]})]})]}),(0,r.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,r.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,r.jsxs)("div",{className:"cardswrap",children:[(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/06-compute-APIs.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Real-Time Aggregations"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Execute aggregation jobs on data-holding nodes. Process millions of rows in memory. Return aggregated results without data movement. Scale horizontally by adding nodes. Each node processes its partitions independently."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Complex Business Logic"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Implement multi-step business rules in compute jobs. Access related data locally through colocation. Execute validation, transformation, and enrichment. Combine procedural and declarative logic at the data layer."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/09-streaming.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Stream Processing"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Process event streams with colocated compute. Execute windowing and aggregation logic where data lands. Update derived tables and materialized views. Maintain complex state in memory for stateful stream processing."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/use-cases/event-stream-processing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,r.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,r.jsx)("h2",{className:"h4 pb-4",children:"How Compute Connects to the Foundation"}),(0,r.jsxs)("div",{className:"cardswrap",children:[(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/05-key-value-APIs.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Colocation Enables Local Processing"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Compute jobs execute on nodes holding colocated data. Schema-driven placement ensures data and compute reside together. This eliminates network overhead for complex operations."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/features/data-placement",className:"cardsimple__button button button--shadow",children:"Learn About Data Placement"})})]}),(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Execution"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Compute jobs access data directly from memory. No disk I/O during execution. This memory-first approach delivers the performance needed for real-time compute workloads at scale."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]}),(0,r.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,r.jsx)("div",{className:"cardsimple__icon",children:(0,r.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,r.jsx)("h3",{className:"cardsimple__title",children:"Transactional Compute"}),(0,r.jsx)("div",{className:"cardsimple__text",children:"Compute jobs execute within ACID transactions. MVCC provides snapshot isolation for read operations. This ensures consistency for complex multi-step operations executing at the data layer."}),(0,r.jsx)("div",{className:"cardsimple__bottom",children:(0,r.jsx)(i.A,{to:"/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn About Transactions"})})]})]})]}),(0,r.jsx)("section",{className:"native-bottom container",children:(0,r.jsxs)("div",{className:"native-bottom__grid",children:[(0,r.jsxs)("article",{className:"nativebotblock",children:[(0,r.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,r.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,r.jsx)("span",{children:"Ready to Start?"})]}),(0,r.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,r.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,r.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,r.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,r.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,r.jsx)("span",{children:"Read Documentation"})]}),(0,r.jsx)("p",{className:"nativebotblock__text",children:"Learn about compute job submission, execution patterns, and colocated processing"}),(0,r.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/develop/work-with-data/compute",target:"_blank",rel:"noreferrer",children:"Compute Documentation"})]})]})})]})}},40830:(e,s,a)=>{a.d(s,{lZ:()=>n});var t=a(56347),i=a(44586);function n(){const e=(0,t.zy)(),{siteConfig:s}=(0,i.A)();let a=e.pathname;return"/"!==a&&a.endsWith("/")&&(a=a.slice(0,-1)),`${s.url}${a}`}}}]);