<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://ignite.apache.org/releases/2.7.5/cppdoc/classignite_1_1thin_1_1cache_1_1CacheClient.html" />

<META NAME="ROBOTS" CONTENT="NOINDEX">

<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>&nbsp; Apache Ignite C++: ignite::thin::cache::CacheClient&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ignite_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&nbsp; Apache Ignite C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignite.html">ignite</a></li><li class="navelem"><a class="el" href="namespaceignite_1_1thin.html">thin</a></li><li class="navelem"><a class="el" href="namespaceignite_1_1thin_1_1cache.html">cache</a></li><li class="navelem"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">CacheClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classignite_1_1thin_1_1cache_1_1CacheClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ignite::thin::cache::CacheClient&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cache client class template.  
 <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache__client_8h_source.html">cache_client.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a27d8e2533526122c277b1ea33d73f064"><td class="memItemLeft" align="right" valign="top">typedef K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a></td></tr>
<tr class="memdesc:a27d8e2533526122c277b1ea33d73f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type.  <a href="#a27d8e2533526122c277b1ea33d73f064">More...</a><br /></td></tr>
<tr class="separator:a27d8e2533526122c277b1ea33d73f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="memItemLeft" align="right" valign="top">typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a></td></tr>
<tr class="memdesc:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <a href="#a0c4c44b1cc3a1498df116a1d9265b7e9">More...</a><br /></td></tr>
<tr class="separator:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae942c7ae26b148076557a3cc9bf31ff8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae942c7ae26b148076557a3cc9bf31ff8">CacheClient</a> (common::concurrent::SharedPointer&lt; void &gt; impl)</td></tr>
<tr class="memdesc:ae942c7ae26b148076557a3cc9bf31ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae942c7ae26b148076557a3cc9bf31ff8">More...</a><br /></td></tr>
<tr class="separator:ae942c7ae26b148076557a3cc9bf31ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a6d86b6377a12c63f3509785482a08"><td class="memItemLeft" align="right" valign="top"><a id="a09a6d86b6377a12c63f3509785482a08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a09a6d86b6377a12c63f3509785482a08">CacheClient</a> ()</td></tr>
<tr class="memdesc:a09a6d86b6377a12c63f3509785482a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a09a6d86b6377a12c63f3509785482a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c8328d3f48722ab84285e5c24429a"><td class="memItemLeft" align="right" valign="top"><a id="a103c8328d3f48722ab84285e5c24429a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a103c8328d3f48722ab84285e5c24429a">~CacheClient</a> ()</td></tr>
<tr class="memdesc:a103c8328d3f48722ab84285e5c24429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a103c8328d3f48722ab84285e5c24429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303bc7dcd7699cb5aacd6af3301e870b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a303bc7dcd7699cb5aacd6af3301e870b">Put</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a303bc7dcd7699cb5aacd6af3301e870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate the specified value with the specified key in the cache.  <a href="#a303bc7dcd7699cb5aacd6af3301e870b">More...</a><br /></td></tr>
<tr class="separator:a303bc7dcd7699cb5aacd6af3301e870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac4e48549a40391e2a6cc45c6722f78"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:aeac4e48549a40391e2a6cc45c6722f78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aeac4e48549a40391e2a6cc45c6722f78">PutAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:aeac4e48549a40391e2a6cc45c6722f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="#aeac4e48549a40391e2a6cc45c6722f78">More...</a><br /></td></tr>
<tr class="separator:aeac4e48549a40391e2a6cc45c6722f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memTemplParams" colspan="2">template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad72cb7fec2922cde1b9879eb38c0f21f">PutAll</a> (const Map &amp;vals)</td></tr>
<tr class="memdesc:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="#ad72cb7fec2922cde1b9879eb38c0f21f">More...</a><br /></td></tr>
<tr class="separator:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d8d76f3fd30cf1963344b7a0d05571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a14d8d76f3fd30cf1963344b7a0d05571">Get</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a14d8d76f3fd30cf1963344b7a0d05571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value from the cache.  <a href="#a14d8d76f3fd30cf1963344b7a0d05571">More...</a><br /></td></tr>
<tr class="separator:a14d8d76f3fd30cf1963344b7a0d05571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e9314ac1c1c736a9836fd6a51890b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a492e9314ac1c1c736a9836fd6a51890b">Get</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a492e9314ac1c1c736a9836fd6a51890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value from cache.  <a href="#a492e9314ac1c1c736a9836fd6a51890b">More...</a><br /></td></tr>
<tr class="separator:a492e9314ac1c1c736a9836fd6a51890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b85d89fecdf1ff43e073bebae34407"><td class="memTemplParams" colspan="2">template&lt;typename InIter , typename OutIter &gt; </td></tr>
<tr class="memitem:af6b85d89fecdf1ff43e073bebae34407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6b85d89fecdf1ff43e073bebae34407">GetAll</a> (InIter begin, InIter end, OutIter dst)</td></tr>
<tr class="memdesc:af6b85d89fecdf1ff43e073bebae34407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="#af6b85d89fecdf1ff43e073bebae34407">More...</a><br /></td></tr>
<tr class="separator:af6b85d89fecdf1ff43e073bebae34407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b24cf4e80628f2fab07618a6105daca"><td class="memTemplParams" colspan="2">template&lt;typename Set , typename Map &gt; </td></tr>
<tr class="memitem:a4b24cf4e80628f2fab07618a6105daca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4b24cf4e80628f2fab07618a6105daca">GetAll</a> (const Set &amp;keys, Map &amp;res)</td></tr>
<tr class="memdesc:a4b24cf4e80628f2fab07618a6105daca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="#a4b24cf4e80628f2fab07618a6105daca">More...</a><br /></td></tr>
<tr class="separator:a4b24cf4e80628f2fab07618a6105daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54f108fda3ecf71c9a2863b760ea476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae54f108fda3ecf71c9a2863b760ea476">Replace</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:ae54f108fda3ecf71c9a2863b760ea476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if there is a previous mapping for it.  <a href="#ae54f108fda3ecf71c9a2863b760ea476">More...</a><br /></td></tr>
<tr class="separator:ae54f108fda3ecf71c9a2863b760ea476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb51208ea8838db113f5cd1ed0a3706b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#adb51208ea8838db113f5cd1ed0a3706b">ContainsKey</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:adb51208ea8838db113f5cd1ed0a3706b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cache contains a value for the specified key.  <a href="#adb51208ea8838db113f5cd1ed0a3706b">More...</a><br /></td></tr>
<tr class="separator:adb51208ea8838db113f5cd1ed0a3706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f05513691c5de09f3d2d557ac61394"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:a68f05513691c5de09f3d2d557ac61394"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a68f05513691c5de09f3d2d557ac61394">ContainsKeys</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:a68f05513691c5de09f3d2d557ac61394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="#a68f05513691c5de09f3d2d557ac61394">More...</a><br /></td></tr>
<tr class="separator:a68f05513691c5de09f3d2d557ac61394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a5e2ded2d1950dc4556ee4dbcf849a9eb">ContainsKeys</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="#a5e2ded2d1950dc4556ee4dbcf849a9eb">More...</a><br /></td></tr>
<tr class="separator:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beb441de7e564cc71415a757cc3be29"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a9beb441de7e564cc71415a757cc3be29">GetSize</a> (int32_t peekModes)</td></tr>
<tr class="memdesc:a9beb441de7e564cc71415a757cc3be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="#a9beb441de7e564cc71415a757cc3be29">More...</a><br /></td></tr>
<tr class="separator:a9beb441de7e564cc71415a757cc3be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6f6ee1de82feb3c8b4791f3b1632dc4">Remove</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache.  <a href="#af6f6ee1de82feb3c8b4791f3b1632dc4">More...</a><br /></td></tr>
<tr class="separator:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31ea272179b7424e6e59679d62759ba"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:ad31ea272179b7424e6e59679d62759ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad31ea272179b7424e6e59679d62759ba">RemoveAll</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:ad31ea272179b7424e6e59679d62759ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="#ad31ea272179b7424e6e59679d62759ba">More...</a><br /></td></tr>
<tr class="separator:ad31ea272179b7424e6e59679d62759ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ff3472405cdce705938f219544a3c9"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a45ff3472405cdce705938f219544a3c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a45ff3472405cdce705938f219544a3c9">RemoveAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a45ff3472405cdce705938f219544a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="#a45ff3472405cdce705938f219544a3c9">More...</a><br /></td></tr>
<tr class="separator:a45ff3472405cdce705938f219544a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b8b0d8c42003dffed552a65fc6b582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a79b8b0d8c42003dffed552a65fc6b582">RemoveAll</a> ()</td></tr>
<tr class="memdesc:a79b8b0d8c42003dffed552a65fc6b582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all mappings from cache.  <a href="#a79b8b0d8c42003dffed552a65fc6b582">More...</a><br /></td></tr>
<tr class="separator:a79b8b0d8c42003dffed552a65fc6b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad68bf064989c3fcfa31b14061b888c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a1ad68bf064989c3fcfa31b14061b888c">Clear</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a1ad68bf064989c3fcfa31b14061b888c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a1ad68bf064989c3fcfa31b14061b888c">More...</a><br /></td></tr>
<tr class="separator:a1ad68bf064989c3fcfa31b14061b888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="memItemLeft" align="right" valign="top"><a id="a83fbdf124a17e3564b3e9dc5302a2a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a83fbdf124a17e3564b3e9dc5302a2a52">Clear</a> ()</td></tr>
<tr class="memdesc:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear cache. <br /></td></tr>
<tr class="separator:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5213be2d0327207b29630527aff40a"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:a4e5213be2d0327207b29630527aff40a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4e5213be2d0327207b29630527aff40a">ClearAll</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:a4e5213be2d0327207b29630527aff40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a4e5213be2d0327207b29630527aff40a">More...</a><br /></td></tr>
<tr class="separator:a4e5213be2d0327207b29630527aff40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dad79827ec0125ba03a27d7eced1d97"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a8dad79827ec0125ba03a27d7eced1d97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a8dad79827ec0125ba03a27d7eced1d97">ClearAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a8dad79827ec0125ba03a27d7eced1d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a8dad79827ec0125ba03a27d7eced1d97">More...</a><br /></td></tr>
<tr class="separator:a8dad79827ec0125ba03a27d7eced1d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aa35aa36ae9914a0ded65714bdb4e9a37">RefreshAffinityMapping</a> ()</td></tr>
<tr class="memdesc:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh affinity mapping.  <a href="#aa35aa36ae9914a0ded65714bdb4e9a37">More...</a><br /></td></tr>
<tr class="separator:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aae56d34e47a3ce618371ec01b85d3819"><td class="memItemLeft" align="right" valign="top"><a id="aae56d34e47a3ce618371ec01b85d3819"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>impl::thin::cache::CacheClientProxy</b></td></tr>
<tr class="separator:aae56d34e47a3ce618371ec01b85d3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class ignite::thin::cache::CacheClient&lt; K, V &gt;</h3>

<p>Cache client class template. </p>
<p>Main entry point for all Data Grid APIs.</p>
<p>Both key and value types should be default-constructable, copy-constructable and assignable. Also BinaryType class template should be specialized for both types, if they are not one of the basic types.</p>
<p>This class implemented as a reference to an implementation so copying of this class instance will only create another reference to the same underlying object. Underlying object released automatically once all the instances are destructed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Cache key type. </td></tr>
    <tr><td class="paramname">V</td><td>Cache value type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a27d8e2533526122c277b1ea33d73f064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d8e2533526122c277b1ea33d73f064">&#9670;&nbsp;</a></span>KeyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef K <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::<a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key type. </p>

</div>
</div>
<a id="a0c4c44b1cc3a1498df116a1d9265b7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4c44b1cc3a1498df116a1d9265b7e9">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef V <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::<a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae942c7ae26b148076557a3cc9bf31ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae942c7ae26b148076557a3cc9bf31ff8">&#9670;&nbsp;</a></span>CacheClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::<a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">CacheClient</a> </td>
          <td>(</td>
          <td class="paramtype">common::concurrent::SharedPointer&lt; void &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>Implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ad68bf064989c3fcfa31b14061b888c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad68bf064989c3fcfa31b14061b888c">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5213be2d0327207b29630527aff40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5213be2d0327207b29630527aff40a">&#9670;&nbsp;</a></span>ClearAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dad79827ec0125ba03a27d7eced1d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dad79827ec0125ba03a27d7eced1d97">&#9670;&nbsp;</a></span>ClearAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb51208ea8838db113f5cd1ed0a3706b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb51208ea8838db113f5cd1ed0a3706b">&#9670;&nbsp;</a></span>ContainsKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the cache contains a value for the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose presence in this cache is to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the cache contains specified key. </dd></dl>

</div>
</div>
<a id="a68f05513691c5de09f3d2d557ac61394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f05513691c5de09f3d2d557ac61394">&#9670;&nbsp;</a></span>ContainsKeys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a id="a5e2ded2d1950dc4556ee4dbcf849a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2ded2d1950dc4556ee4dbcf849a9eb">&#9670;&nbsp;</a></span>ContainsKeys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a id="a14d8d76f3fd30cf1963344b7a0d05571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d8d76f3fd30cf1963344b7a0d05571">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value from the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a492e9314ac1c1c736a9836fd6a51890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e9314ac1c1c736a9836fd6a51890b">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value from cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a id="af6b85d89fecdf1ff43e073bebae34407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b85d89fecdf1ff43e073bebae34407">&#9670;&nbsp;</a></span>GetAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter , typename OutIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIter&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
    <tr><td class="paramname">dst</td><td>Output iterator. Should dereference to std::pair or CacheEntry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b24cf4e80628f2fab07618a6105daca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b24cf4e80628f2fab07618a6105daca">&#9670;&nbsp;</a></span>GetAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Set , typename Map &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">res</td><td>Map of key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9beb441de7e564cc71415a757cc3be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beb441de7e564cc71415a757cc3be29">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>This operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structignite_1_1thin_1_1cache_1_1CachePeekMode.html" title="Enumeration of all supported cache peek modes. ">CachePeekMode</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cache size across all nodes. </dd></dl>

</div>
</div>
<a id="a303bc7dcd7699cb5aacd6af3301e870b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303bc7dcd7699cb5aacd6af3301e870b">&#9670;&nbsp;</a></span>Put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate the specified value with the specified key in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeac4e48549a40391e2a6cc45c6722f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac4e48549a40391e2a6cc45c6722f78">&#9670;&nbsp;</a></span>PutAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key-value pair sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key-value pair sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72cb7fec2922cde1b9879eb38c0f21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72cb7fec2922cde1b9879eb38c0f21f">&#9670;&nbsp;</a></span>PutAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Map &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">const Map &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>Key-value pairs to store in cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa35aa36ae9914a0ded65714bdb4e9a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35aa36ae9914a0ded65714bdb4e9a37">&#9670;&nbsp;</a></span>RefreshAffinityMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RefreshAffinityMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh affinity mapping. </p>
<p>Retrieves affinity mapping information from remote server. This information uses to send data requests to the most appropriate nodes. This can lessen latency and improve overall performance.</p>
<p>It is recommended to refresh affinity mapping after every topology change, i.e. when a node enters or leaves cluster. </p>

</div>
</div>
<a id="af6f6ee1de82feb3c8b4791f3b1632dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f6ee1de82feb3c8b4791f3b1632dc4">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the disk-based swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method removex() should always be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if there was no matching key. </dd></dl>

</div>
</div>
<a id="ad31ea272179b7424e6e59679d62759ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31ea272179b7424e6e59679d62759ba">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys whose mappings are to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ff3472405cdce705938f219544a3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ff3472405cdce705938f219544a3c9">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b8b0d8c42003dffed552a65fc6b582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b8b0d8c42003dffed552a65fc6b582">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one. </p>

</div>
</div>
<a id="ae54f108fda3ecf71c9a2863b760ea476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54f108fda3ecf71c9a2863b760ea476">&#9670;&nbsp;</a></span>Replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if there is a previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, rom the underlying persistent storage. If write-through is enabled, the stored value will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value was replaced. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cache__client_8h_source.html">cache_client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 4 2019 17:13:58 for &nbsp; Apache Ignite C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
