<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>&nbsp; Apache Ignite C++: ignite::thin::cache::CacheClient&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ignite_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&nbsp; Apache Ignite C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignite.html">ignite</a></li><li class="navelem"><a class="el" href="namespaceignite_1_1thin.html">thin</a></li><li class="navelem"><a class="el" href="namespaceignite_1_1thin_1_1cache.html">cache</a></li><li class="navelem"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">CacheClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classignite_1_1thin_1_1cache_1_1CacheClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ignite::thin::cache::CacheClient&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cache client class template.  
 <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache__client_8h_source.html">cache_client.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a27d8e2533526122c277b1ea33d73f064"><td class="memItemLeft" align="right" valign="top"><a id="a27d8e2533526122c277b1ea33d73f064"></a>
typedef K&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a></td></tr>
<tr class="memdesc:a27d8e2533526122c277b1ea33d73f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type. <br /></td></tr>
<tr class="separator:a27d8e2533526122c277b1ea33d73f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="memItemLeft" align="right" valign="top"><a id="a0c4c44b1cc3a1498df116a1d9265b7e9"></a>
typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a></td></tr>
<tr class="memdesc:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type. <br /></td></tr>
<tr class="separator:a0c4c44b1cc3a1498df116a1d9265b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4257b7f7a16e130d6bd002233c0f31b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4257b7f7a16e130d6bd002233c0f31b5">CacheClient</a> (const common::concurrent::SharedPointer&lt; void &gt; &amp;impl)</td></tr>
<tr class="memdesc:a4257b7f7a16e130d6bd002233c0f31b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4257b7f7a16e130d6bd002233c0f31b5">More...</a><br /></td></tr>
<tr class="separator:a4257b7f7a16e130d6bd002233c0f31b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a6d86b6377a12c63f3509785482a08"><td class="memItemLeft" align="right" valign="top"><a id="a09a6d86b6377a12c63f3509785482a08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a09a6d86b6377a12c63f3509785482a08">CacheClient</a> ()</td></tr>
<tr class="memdesc:a09a6d86b6377a12c63f3509785482a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a09a6d86b6377a12c63f3509785482a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c8328d3f48722ab84285e5c24429a"><td class="memItemLeft" align="right" valign="top"><a id="a103c8328d3f48722ab84285e5c24429a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a103c8328d3f48722ab84285e5c24429a">~CacheClient</a> ()</td></tr>
<tr class="memdesc:a103c8328d3f48722ab84285e5c24429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a103c8328d3f48722ab84285e5c24429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303bc7dcd7699cb5aacd6af3301e870b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a303bc7dcd7699cb5aacd6af3301e870b">Put</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a303bc7dcd7699cb5aacd6af3301e870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate the specified value with the specified key in the cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a303bc7dcd7699cb5aacd6af3301e870b">More...</a><br /></td></tr>
<tr class="separator:a303bc7dcd7699cb5aacd6af3301e870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac4e48549a40391e2a6cc45c6722f78"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:aeac4e48549a40391e2a6cc45c6722f78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aeac4e48549a40391e2a6cc45c6722f78">PutAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:aeac4e48549a40391e2a6cc45c6722f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aeac4e48549a40391e2a6cc45c6722f78">More...</a><br /></td></tr>
<tr class="separator:aeac4e48549a40391e2a6cc45c6722f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memTemplParams" colspan="2">template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad72cb7fec2922cde1b9879eb38c0f21f">PutAll</a> (const Map &amp;vals)</td></tr>
<tr class="memdesc:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad72cb7fec2922cde1b9879eb38c0f21f">More...</a><br /></td></tr>
<tr class="separator:ad72cb7fec2922cde1b9879eb38c0f21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d8d76f3fd30cf1963344b7a0d05571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a14d8d76f3fd30cf1963344b7a0d05571">Get</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a14d8d76f3fd30cf1963344b7a0d05571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value from the cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a14d8d76f3fd30cf1963344b7a0d05571">More...</a><br /></td></tr>
<tr class="separator:a14d8d76f3fd30cf1963344b7a0d05571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e9314ac1c1c736a9836fd6a51890b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a492e9314ac1c1c736a9836fd6a51890b">Get</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a492e9314ac1c1c736a9836fd6a51890b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a492e9314ac1c1c736a9836fd6a51890b">More...</a><br /></td></tr>
<tr class="separator:a492e9314ac1c1c736a9836fd6a51890b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b85d89fecdf1ff43e073bebae34407"><td class="memTemplParams" colspan="2">template&lt;typename InIter , typename OutIter &gt; </td></tr>
<tr class="memitem:af6b85d89fecdf1ff43e073bebae34407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6b85d89fecdf1ff43e073bebae34407">GetAll</a> (InIter begin, InIter end, OutIter dst)</td></tr>
<tr class="memdesc:af6b85d89fecdf1ff43e073bebae34407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6b85d89fecdf1ff43e073bebae34407">More...</a><br /></td></tr>
<tr class="separator:af6b85d89fecdf1ff43e073bebae34407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b24cf4e80628f2fab07618a6105daca"><td class="memTemplParams" colspan="2">template&lt;typename Set , typename Map &gt; </td></tr>
<tr class="memitem:a4b24cf4e80628f2fab07618a6105daca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4b24cf4e80628f2fab07618a6105daca">GetAll</a> (const Set &amp;keys, Map &amp;res)</td></tr>
<tr class="memdesc:a4b24cf4e80628f2fab07618a6105daca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4b24cf4e80628f2fab07618a6105daca">More...</a><br /></td></tr>
<tr class="separator:a4b24cf4e80628f2fab07618a6105daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54f108fda3ecf71c9a2863b760ea476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae54f108fda3ecf71c9a2863b760ea476">Replace</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:ae54f108fda3ecf71c9a2863b760ea476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if there is a previous mapping for it.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae54f108fda3ecf71c9a2863b760ea476">More...</a><br /></td></tr>
<tr class="separator:ae54f108fda3ecf71c9a2863b760ea476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c79cd0c124d4dcd6a570fc53df629c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a7c79cd0c124d4dcd6a570fc53df629c9">Replace</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;oldVal, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;newVal)</td></tr>
<tr class="memdesc:a7c79cd0c124d4dcd6a570fc53df629c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if the previous value is equal to the old value passed as argument.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a7c79cd0c124d4dcd6a570fc53df629c9">More...</a><br /></td></tr>
<tr class="separator:a7c79cd0c124d4dcd6a570fc53df629c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb51208ea8838db113f5cd1ed0a3706b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#adb51208ea8838db113f5cd1ed0a3706b">ContainsKey</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:adb51208ea8838db113f5cd1ed0a3706b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cache contains a value for the specified key.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#adb51208ea8838db113f5cd1ed0a3706b">More...</a><br /></td></tr>
<tr class="separator:adb51208ea8838db113f5cd1ed0a3706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f05513691c5de09f3d2d557ac61394"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:a68f05513691c5de09f3d2d557ac61394"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a68f05513691c5de09f3d2d557ac61394">ContainsKeys</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:a68f05513691c5de09f3d2d557ac61394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a68f05513691c5de09f3d2d557ac61394">More...</a><br /></td></tr>
<tr class="separator:a68f05513691c5de09f3d2d557ac61394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a5e2ded2d1950dc4556ee4dbcf849a9eb">ContainsKeys</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a5e2ded2d1950dc4556ee4dbcf849a9eb">More...</a><br /></td></tr>
<tr class="separator:a5e2ded2d1950dc4556ee4dbcf849a9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9beb441de7e564cc71415a757cc3be29"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a9beb441de7e564cc71415a757cc3be29">GetSize</a> (int32_t peekModes)</td></tr>
<tr class="memdesc:a9beb441de7e564cc71415a757cc3be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a9beb441de7e564cc71415a757cc3be29">More...</a><br /></td></tr>
<tr class="separator:a9beb441de7e564cc71415a757cc3be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6f6ee1de82feb3c8b4791f3b1632dc4">Remove</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#af6f6ee1de82feb3c8b4791f3b1632dc4">More...</a><br /></td></tr>
<tr class="separator:af6f6ee1de82feb3c8b4791f3b1632dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb27dedabd63f7630fa23373f2df69fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#acb27dedabd63f7630fa23373f2df69fa">Remove</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:acb27dedabd63f7630fa23373f2df69fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache if one exists and value is equal to the passed in value.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#acb27dedabd63f7630fa23373f2df69fa">More...</a><br /></td></tr>
<tr class="separator:acb27dedabd63f7630fa23373f2df69fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31ea272179b7424e6e59679d62759ba"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:ad31ea272179b7424e6e59679d62759ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad31ea272179b7424e6e59679d62759ba">RemoveAll</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:ad31ea272179b7424e6e59679d62759ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ad31ea272179b7424e6e59679d62759ba">More...</a><br /></td></tr>
<tr class="separator:ad31ea272179b7424e6e59679d62759ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ff3472405cdce705938f219544a3c9"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a45ff3472405cdce705938f219544a3c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a45ff3472405cdce705938f219544a3c9">RemoveAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a45ff3472405cdce705938f219544a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a45ff3472405cdce705938f219544a3c9">More...</a><br /></td></tr>
<tr class="separator:a45ff3472405cdce705938f219544a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b8b0d8c42003dffed552a65fc6b582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a79b8b0d8c42003dffed552a65fc6b582">RemoveAll</a> ()</td></tr>
<tr class="memdesc:a79b8b0d8c42003dffed552a65fc6b582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all mappings from cache.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a79b8b0d8c42003dffed552a65fc6b582">More...</a><br /></td></tr>
<tr class="separator:a79b8b0d8c42003dffed552a65fc6b582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad68bf064989c3fcfa31b14061b888c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a1ad68bf064989c3fcfa31b14061b888c">Clear</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a1ad68bf064989c3fcfa31b14061b888c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a1ad68bf064989c3fcfa31b14061b888c">More...</a><br /></td></tr>
<tr class="separator:a1ad68bf064989c3fcfa31b14061b888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="memItemLeft" align="right" valign="top"><a id="a83fbdf124a17e3564b3e9dc5302a2a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a83fbdf124a17e3564b3e9dc5302a2a52">Clear</a> ()</td></tr>
<tr class="memdesc:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear cache. <br /></td></tr>
<tr class="separator:a83fbdf124a17e3564b3e9dc5302a2a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5213be2d0327207b29630527aff40a"><td class="memTemplParams" colspan="2">template&lt;typename Set &gt; </td></tr>
<tr class="memitem:a4e5213be2d0327207b29630527aff40a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4e5213be2d0327207b29630527aff40a">ClearAll</a> (const Set &amp;keys)</td></tr>
<tr class="memdesc:a4e5213be2d0327207b29630527aff40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a4e5213be2d0327207b29630527aff40a">More...</a><br /></td></tr>
<tr class="separator:a4e5213be2d0327207b29630527aff40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dad79827ec0125ba03a27d7eced1d97"><td class="memTemplParams" colspan="2">template&lt;typename InIter &gt; </td></tr>
<tr class="memitem:a8dad79827ec0125ba03a27d7eced1d97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a8dad79827ec0125ba03a27d7eced1d97">ClearAll</a> (InIter begin, InIter end)</td></tr>
<tr class="memdesc:a8dad79827ec0125ba03a27d7eced1d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a8dad79827ec0125ba03a27d7eced1d97">More...</a><br /></td></tr>
<tr class="separator:a8dad79827ec0125ba03a27d7eced1d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276bfba8f208a250adf92843955a97f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a276bfba8f208a250adf92843955a97f3">GetAndPut</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valOut)</td></tr>
<tr class="memdesc:a276bfba8f208a250adf92843955a97f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in this cache, returning an existing value if one existed.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a276bfba8f208a250adf92843955a97f3">More...</a><br /></td></tr>
<tr class="separator:a276bfba8f208a250adf92843955a97f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fe649399cd5831886757b6d73dec15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae0fe649399cd5831886757b6d73dec15">GetAndPut</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn)</td></tr>
<tr class="memdesc:ae0fe649399cd5831886757b6d73dec15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in this cache, returning an existing value if one existed.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ae0fe649399cd5831886757b6d73dec15">More...</a><br /></td></tr>
<tr class="separator:ae0fe649399cd5831886757b6d73dec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04838ac0cff480ca4173affafef804f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a04838ac0cff480ca4173affafef804f5">GetAndRemove</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valOut)</td></tr>
<tr class="memdesc:a04838ac0cff480ca4173affafef804f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the entry for a key only if currently mapped to some value.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a04838ac0cff480ca4173affafef804f5">More...</a><br /></td></tr>
<tr class="separator:a04838ac0cff480ca4173affafef804f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd6fe075807228e3bd60f0475e49e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a5ffd6fe075807228e3bd60f0475e49e1">GetAndRemove</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key)</td></tr>
<tr class="memdesc:a5ffd6fe075807228e3bd60f0475e49e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the entry for a key only if currently mapped to some value.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a5ffd6fe075807228e3bd60f0475e49e1">More...</a><br /></td></tr>
<tr class="separator:a5ffd6fe075807228e3bd60f0475e49e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c78cda25fd6e1e7ffc65a04e676e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ac67c78cda25fd6e1e7ffc65a04e676e8">GetAndReplace</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valOut)</td></tr>
<tr class="memdesc:ac67c78cda25fd6e1e7ffc65a04e676e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaces the value for a given key if and only if there is a value currently mapped by the key.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#ac67c78cda25fd6e1e7ffc65a04e676e8">More...</a><br /></td></tr>
<tr class="separator:ac67c78cda25fd6e1e7ffc65a04e676e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab00f0b4255e27d2cd70f6c162055571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aab00f0b4255e27d2cd70f6c162055571">GetAndReplace</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn)</td></tr>
<tr class="memdesc:aab00f0b4255e27d2cd70f6c162055571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaces the value for a given key if and only if there is a value currently mapped by the key.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aab00f0b4255e27d2cd70f6c162055571">More...</a><br /></td></tr>
<tr class="separator:aab00f0b4255e27d2cd70f6c162055571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0587a1dd8309b8fd1b3e339fa9d659af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0587a1dd8309b8fd1b3e339fa9d659af">PutIfAbsent</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:a0587a1dd8309b8fd1b3e339fa9d659af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically associates the specified key with the given value if it is not already associated with a value.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0587a1dd8309b8fd1b3e339fa9d659af">More...</a><br /></td></tr>
<tr class="separator:a0587a1dd8309b8fd1b3e339fa9d659af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798f809fa0b88f3268af0c348b1e05d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a798f809fa0b88f3268af0c348b1e05d9">GetAndPutIfAbsent</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valOut)</td></tr>
<tr class="memdesc:a798f809fa0b88f3268af0c348b1e05d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if cache had no previous mapping for it.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a798f809fa0b88f3268af0c348b1e05d9">More...</a><br /></td></tr>
<tr class="separator:a798f809fa0b88f3268af0c348b1e05d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fa8fd372aee7d51caf3c4f8cdc9966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a46fa8fd372aee7d51caf3c4f8cdc9966">GetAndPutIfAbsent</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;key, const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;valIn)</td></tr>
<tr class="memdesc:a46fa8fd372aee7d51caf3c4f8cdc9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if cache had no previous mapping for it.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a46fa8fd372aee7d51caf3c4f8cdc9966">More...</a><br /></td></tr>
<tr class="separator:a46fa8fd372aee7d51caf3c4f8cdc9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38660ee6bc4f9c8e46bd46a4937a08f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a38660ee6bc4f9c8e46bd46a4937a08f8">Query</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:a38660ee6bc4f9c8e46bd46a4937a08f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SQL fields query.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a38660ee6bc4f9c8e46bd46a4937a08f8">More...</a><br /></td></tr>
<tr class="separator:a38660ee6bc4f9c8e46bd46a4937a08f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e38ab68d65bcd9e8347a7921d16fc6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a>, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0e38ab68d65bcd9e8347a7921d16fc6b">Query</a> (const <a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:a0e38ab68d65bcd9e8347a7921d16fc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform scan query.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0e38ab68d65bcd9e8347a7921d16fc6b">More...</a><br /></td></tr>
<tr class="separator:a0e38ab68d65bcd9e8347a7921d16fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca45fe31d9b62d6f0fae2fbf4488a644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandleClient.html">query::continuous::ContinuousQueryHandleClient</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aca45fe31d9b62d6f0fae2fbf4488a644">QueryContinuous</a> (<a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryClient.html">query::continuous::ContinuousQueryClient</a>&lt; K, V &gt; continuousQuery)</td></tr>
<tr class="memdesc:aca45fe31d9b62d6f0fae2fbf4488a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the continuous query execution.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aca45fe31d9b62d6f0fae2fbf4488a644">More...</a><br /></td></tr>
<tr class="separator:aca45fe31d9b62d6f0fae2fbf4488a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aa35aa36ae9914a0ded65714bdb4e9a37">RefreshAffinityMapping</a> ()</td></tr>
<tr class="memdesc:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh affinity mapping.  <a href="classignite_1_1thin_1_1cache_1_1CacheClient.html#aa35aa36ae9914a0ded65714bdb4e9a37">More...</a><br /></td></tr>
<tr class="separator:aa35aa36ae9914a0ded65714bdb4e9a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aae56d34e47a3ce618371ec01b85d3819"><td class="memItemLeft" align="right" valign="top"><a id="aae56d34e47a3ce618371ec01b85d3819"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>impl::thin::cache::CacheClientProxy</b></td></tr>
<tr class="separator:aae56d34e47a3ce618371ec01b85d3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class ignite::thin::cache::CacheClient&lt; K, V &gt;</h3>

<p>Cache client class template. </p>
<p>Main entry point for all Data Grid APIs.</p>
<p>Both key and value types should be default-constructable, copy-constructable and assignable. Also BinaryType class template should be specialized for both types, if they are not one of the basic types.</p>
<p>This class is implemented as a reference to an implementation so copying of this class instance will only create another reference to the same underlying object. Underlying object will be released automatically once all the instances are destructed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Cache key type. </td></tr>
    <tr><td class="paramname">V</td><td>Cache value type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4257b7f7a16e130d6bd002233c0f31b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4257b7f7a16e130d6bd002233c0f31b5">&#9670;&nbsp;</a></span>CacheClient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::<a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">CacheClient</a> </td>
          <td>(</td>
          <td class="paramtype">const common::concurrent::SharedPointer&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>Implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1ad68bf064989c3fcfa31b14061b888c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad68bf064989c3fcfa31b14061b888c">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5213be2d0327207b29630527aff40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5213be2d0327207b29630527aff40a">&#9670;&nbsp;</a></span>ClearAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dad79827ec0125ba03a27d7eced1d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dad79827ec0125ba03a27d7eced1d97">&#9670;&nbsp;</a></span>ClearAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb51208ea8838db113f5cd1ed0a3706b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb51208ea8838db113f5cd1ed0a3706b">&#9670;&nbsp;</a></span>ContainsKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the cache contains a value for the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose presence in this cache is to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the cache contains specified key. </dd></dl>

</div>
</div>
<a id="a68f05513691c5de09f3d2d557ac61394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f05513691c5de09f3d2d557ac61394">&#9670;&nbsp;</a></span>ContainsKeys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a id="a5e2ded2d1950dc4556ee4dbcf849a9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2ded2d1950dc4556ee4dbcf849a9eb">&#9670;&nbsp;</a></span>ContainsKeys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a id="a492e9314ac1c1c736a9836fd6a51890b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e9314ac1c1c736a9836fd6a51890b">&#9670;&nbsp;</a></span>Get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value from cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a id="a14d8d76f3fd30cf1963344b7a0d05571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d8d76f3fd30cf1963344b7a0d05571">&#9670;&nbsp;</a></span>Get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get value from the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b24cf4e80628f2fab07618a6105daca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b24cf4e80628f2fab07618a6105daca">&#9670;&nbsp;</a></span>GetAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename Set , typename Map &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">res</td><td>Map of key-value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b85d89fecdf1ff43e073bebae34407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b85d89fecdf1ff43e073bebae34407">&#9670;&nbsp;</a></span>GetAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename InIter , typename OutIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIter&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
    <tr><td class="paramname">dst</td><td>Output iterator. Should dereference to std::pair or <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheEntry.html" title="Cache entry class template.">CacheEntry</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0fe649399cd5831886757b6d73dec15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fe649399cd5831886757b6d73dec15">&#9670;&nbsp;</a></span>GetAndPut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndPut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in this cache, returning an existing value if one existed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key at the start of the operation or null if none was associated. </dd></dl>

</div>
</div>
<a id="a276bfba8f208a250adf92843955a97f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276bfba8f208a250adf92843955a97f3">&#9670;&nbsp;</a></span>GetAndPut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndPut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in this cache, returning an existing value if one existed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">valOut</td><td>The value associated with the key at the start of the operation or null if none was associated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46fa8fd372aee7d51caf3c4f8cdc9966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fa8fd372aee7d51caf3c4f8cdc9966">&#9670;&nbsp;</a></span>GetAndPutIfAbsent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndPutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if cache had no previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned.</p>
<p>In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, from the underlying persistent storage.</p>
<p>If the returned value is not needed, method putxIfAbsent() should be used instead of this one to avoid the overhead associated with returning of the previous value.</p>
<p>If write-through is enabled, the stored value will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previously contained value regardless of whether put happened or not (null if there was no previous value). </dd></dl>

</div>
</div>
<a id="a798f809fa0b88f3268af0c348b1e05d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798f809fa0b88f3268af0c348b1e05d9">&#9670;&nbsp;</a></span>GetAndPutIfAbsent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndPutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if cache had no previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned.</p>
<p>In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, from the underlying persistent storage.</p>
<p>If the returned value is not needed, method putxIfAbsent() should be used instead of this one to avoid the overhead associated with returning of the previous value.</p>
<p>If write-through is enabled, the stored value will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the given key. </td></tr>
    <tr><td class="paramname">valOut</td><td>Previously contained value regardless of whether put happened or not (null if there was no previous value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ffd6fe075807228e3bd60f0475e49e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffd6fe075807228e3bd60f0475e49e1">&#9670;&nbsp;</a></span>GetAndRemove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndRemove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically removes the entry for a key only if currently mapped to some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key at the start of the operation or null if none was associated. </dd></dl>

</div>
</div>
<a id="a04838ac0cff480ca4173affafef804f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04838ac0cff480ca4173affafef804f5">&#9670;&nbsp;</a></span>GetAndRemove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndRemove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically removes the entry for a key only if currently mapped to some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">valOut</td><td>The value associated with the key at the start of the operation or null if none was associated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab00f0b4255e27d2cd70f6c162055571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab00f0b4255e27d2cd70f6c162055571">&#9670;&nbsp;</a></span>GetAndReplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndReplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically replaces the value for a given key if and only if there is a value currently mapped by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key at the start of the operation or null if none was associated. </dd></dl>

</div>
</div>
<a id="ac67c78cda25fd6e1e7ffc65a04e676e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67c78cda25fd6e1e7ffc65a04e676e8">&#9670;&nbsp;</a></span>GetAndReplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetAndReplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>valOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically replaces the value for a given key if and only if there is a value currently mapped by the key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">valIn</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">valOut</td><td>The value associated with the key at the start of the operation or null if none was associated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9beb441de7e564cc71415a757cc3be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9beb441de7e564cc71415a757cc3be29">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::GetSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>This operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structignite_1_1thin_1_1cache_1_1CachePeekMode.html" title="Enumeration of all supported cache peek modes.">CachePeekMode</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cache size across all nodes. </dd></dl>

</div>
</div>
<a id="a303bc7dcd7699cb5aacd6af3301e870b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303bc7dcd7699cb5aacd6af3301e870b">&#9670;&nbsp;</a></span>Put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate the specified value with the specified key in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72cb7fec2922cde1b9879eb38c0f21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72cb7fec2922cde1b9879eb38c0f21f">&#9670;&nbsp;</a></span>PutAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename Map &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">const Map &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>Key-value pairs to store in cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeac4e48549a40391e2a6cc45c6722f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac4e48549a40391e2a6cc45c6722f78">&#9670;&nbsp;</a></span>PutAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key-value pair sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key-value pair sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0587a1dd8309b8fd1b3e339fa9d659af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0587a1dd8309b8fd1b3e339fa9d659af">&#9670;&nbsp;</a></span>PutIfAbsent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::PutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically associates the specified key with the given value if it is not already associated with a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a value was set. </dd></dl>

</div>
</div>
<a id="a0e38ab68d65bcd9e8347a7921d16fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e38ab68d65bcd9e8347a7921d16fc6b">&#9670;&nbsp;</a></span>Query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;<a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a>, <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a>&gt; <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform scan query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a id="a38660ee6bc4f9c8e46bd46a4937a08f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38660ee6bc4f9c8e46bd46a4937a08f8">&#9670;&nbsp;</a></span>Query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SQL fields query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query fields cursor. </dd></dl>

</div>
</div>
<a id="aca45fe31d9b62d6f0fae2fbf4488a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca45fe31d9b62d6f0fae2fbf4488a644">&#9670;&nbsp;</a></span>QueryContinuous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandleClient.html">query::continuous::ContinuousQueryHandleClient</a> <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::QueryContinuous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1thin_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryClient.html">query::continuous::ContinuousQueryClient</a>&lt; K, V &gt;&#160;</td>
          <td class="paramname"><em>continuousQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the continuous query execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">continuousQuery</td><td>Continuous query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query handle. Once all instances are destroyed query execution stopped. </dd></dl>

</div>
</div>
<a id="aa35aa36ae9914a0ded65714bdb4e9a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35aa36ae9914a0ded65714bdb4e9a37">&#9670;&nbsp;</a></span>RefreshAffinityMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RefreshAffinityMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh affinity mapping. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Does nothing since Apache <a class="el" href="classignite_1_1Ignite.html" title="Main interface to operate with Ignite.">Ignite</a> 2.8. Affinity mapping is refreshed automatically now.</dd></dl>
<p>Retrieves affinity mapping information from remote server. This information uses to send data requests to the most appropriate nodes. This can lessen latency and improve overall performance.</p>
<p>It is recommended to refresh affinity mapping after every topology change, i.e. when a node enters or leaves cluster. </p>

</div>
</div>
<a id="af6f6ee1de82feb3c8b4791f3b1632dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f6ee1de82feb3c8b4791f3b1632dc4">&#9670;&nbsp;</a></span>Remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the disk-based swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method removex() should always be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if there was no matching key. </dd></dl>

</div>
</div>
<a id="acb27dedabd63f7630fa23373f2df69fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb27dedabd63f7630fa23373f2df69fa">&#9670;&nbsp;</a></span>Remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache if one exists and value is equal to the passed in value. </p>
<p>If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to match against currently cached value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entry was removed, false otherwise. </dd></dl>

</div>
</div>
<a id="a79b8b0d8c42003dffed552a65fc6b582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b8b0d8c42003dffed552a65fc6b582">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one. </p>

</div>
</div>
<a id="ad31ea272179b7424e6e59679d62759ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31ea272179b7424e6e59679d62759ba">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename Set &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">const Set &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys whose mappings are to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ff3472405cdce705938f219544a3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ff3472405cdce705938f219544a3c9">&#9670;&nbsp;</a></span>RemoveAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<div class="memtemplate">
template&lt;typename InIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beginning of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae54f108fda3ecf71c9a2863b760ea476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54f108fda3ecf71c9a2863b760ea476">&#9670;&nbsp;</a></span>Replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if there is a previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, rom the underlying persistent storage. If write-through is enabled, the stored value will be persisted to store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value was replaced. </dd></dl>

</div>
</div>
<a id="a7c79cd0c124d4dcd6a570fc53df629c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c79cd0c124d4dcd6a570fc53df629c9">&#9670;&nbsp;</a></span>Replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html">ignite::thin::cache::CacheClient</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a27d8e2533526122c277b1ea33d73f064">KeyType</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classignite_1_1thin_1_1cache_1_1CacheClient.html#a0c4c44b1cc3a1498df116a1d9265b7e9">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>newVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if the previous value is equal to the old value passed as argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">oldVal</td><td>Old value to match. </td></tr>
    <tr><td class="paramname">newVal</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if replace happened, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cache__client_8h_source.html">cache_client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 25 2023 18:31:45 for &nbsp; Apache Ignite C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
