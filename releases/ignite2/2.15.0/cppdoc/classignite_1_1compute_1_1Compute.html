<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>&nbsp; Apache Ignite C++: ignite::compute::Compute Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ignite_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&nbsp; Apache Ignite C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignite.html">ignite</a></li><li class="navelem"><b>compute</b></li><li class="navelem"><a class="el" href="classignite_1_1compute_1_1Compute.html">Compute</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classignite_1_1compute_1_1Compute-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ignite::compute::Compute Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.  
 <a href="classignite_1_1compute_1_1Compute.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compute_8h_source.html">compute.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46471b90d45dcc498687eb2c96c21a15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a46471b90d45dcc498687eb2c96c21a15">Compute</a> (common::concurrent::SharedPointer&lt; impl::compute::ComputeImpl &gt; impl)</td></tr>
<tr class="memdesc:a46471b90d45dcc498687eb2c96c21a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classignite_1_1compute_1_1Compute.html#a46471b90d45dcc498687eb2c96c21a15">More...</a><br /></td></tr>
<tr class="separator:a46471b90d45dcc498687eb2c96c21a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530a3cce23a9d2707c08d539f26c5006"><td class="memTemplParams" colspan="2">template&lt;typename R , typename K , typename F &gt; </td></tr>
<tr class="memitem:a530a3cce23a9d2707c08d539f26c5006"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a530a3cce23a9d2707c08d539f26c5006">AffinityCall</a> (const std::string &amp;cacheName, const K &amp;key, const F &amp;func)</td></tr>
<tr class="memdesc:a530a3cce23a9d2707c08d539f26c5006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given job on the node where data for provided affinity key is located (a.k.a.  <a href="classignite_1_1compute_1_1Compute.html#a530a3cce23a9d2707c08d539f26c5006">More...</a><br /></td></tr>
<tr class="separator:a530a3cce23a9d2707c08d539f26c5006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc07e207eac96a2f237ba88aef38aaf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename K , typename F &gt; </td></tr>
<tr class="memitem:a8bc07e207eac96a2f237ba88aef38aaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a8bc07e207eac96a2f237ba88aef38aaf">AffinityCallAsync</a> (const std::string &amp;cacheName, const K &amp;key, const F &amp;func)</td></tr>
<tr class="memdesc:a8bc07e207eac96a2f237ba88aef38aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given job asynchronously on the node where data for provided affinity key is located (a.k.a.  <a href="classignite_1_1compute_1_1Compute.html#a8bc07e207eac96a2f237ba88aef38aaf">More...</a><br /></td></tr>
<tr class="separator:a8bc07e207eac96a2f237ba88aef38aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6dc52f89ac7994ee603276997a4f71"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F &gt; </td></tr>
<tr class="memitem:a0a6dc52f89ac7994ee603276997a4f71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a0a6dc52f89ac7994ee603276997a4f71">AffinityRun</a> (const std::string &amp;cacheName, const K &amp;key, const F &amp;action)</td></tr>
<tr class="memdesc:a0a6dc52f89ac7994ee603276997a4f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given job on the node where data for provided affinity key is located (a.k.a.  <a href="classignite_1_1compute_1_1Compute.html#a0a6dc52f89ac7994ee603276997a4f71">More...</a><br /></td></tr>
<tr class="separator:a0a6dc52f89ac7994ee603276997a4f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03bdc90e6e895dd59186ad478a9ffff"><td class="memTemplParams" colspan="2">template&lt;typename K , typename F &gt; </td></tr>
<tr class="memitem:ae03bdc90e6e895dd59186ad478a9ffff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#ae03bdc90e6e895dd59186ad478a9ffff">AffinityRunAsync</a> (const std::string &amp;cacheName, const K &amp;key, const F &amp;action)</td></tr>
<tr class="memdesc:ae03bdc90e6e895dd59186ad478a9ffff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given job asynchronously on the node where data for provided affinity key is located (a.k.a.  <a href="classignite_1_1compute_1_1Compute.html#ae03bdc90e6e895dd59186ad478a9ffff">More...</a><br /></td></tr>
<tr class="separator:ae03bdc90e6e895dd59186ad478a9ffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca0cdfcd21e2b6999aa3831bd53b713"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a5ca0cdfcd21e2b6999aa3831bd53b713"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a5ca0cdfcd21e2b6999aa3831bd53b713">Call</a> (const F &amp;func)</td></tr>
<tr class="memdesc:a5ca0cdfcd21e2b6999aa3831bd53b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group.  <a href="classignite_1_1compute_1_1Compute.html#a5ca0cdfcd21e2b6999aa3831bd53b713">More...</a><br /></td></tr>
<tr class="separator:a5ca0cdfcd21e2b6999aa3831bd53b713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c478a31dec5a52a0f3cc99052941ea"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:a12c478a31dec5a52a0f3cc99052941ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a12c478a31dec5a52a0f3cc99052941ea">CallAsync</a> (const F &amp;func)</td></tr>
<tr class="memdesc:a12c478a31dec5a52a0f3cc99052941ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronuously calls provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group.  <a href="classignite_1_1compute_1_1Compute.html#a12c478a31dec5a52a0f3cc99052941ea">More...</a><br /></td></tr>
<tr class="separator:a12c478a31dec5a52a0f3cc99052941ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5552a0110ef5ef25429393416c6c7aa9"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5552a0110ef5ef25429393416c6c7aa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a5552a0110ef5ef25429393416c6c7aa9">Run</a> (const F &amp;action)</td></tr>
<tr class="memdesc:a5552a0110ef5ef25429393416c6c7aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group.  <a href="classignite_1_1compute_1_1Compute.html#a5552a0110ef5ef25429393416c6c7aa9">More...</a><br /></td></tr>
<tr class="separator:a5552a0110ef5ef25429393416c6c7aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925b1ce324d200b1a1646502a3153e9c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a925b1ce324d200b1a1646502a3153e9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a925b1ce324d200b1a1646502a3153e9c">RunAsync</a> (const F &amp;action)</td></tr>
<tr class="memdesc:a925b1ce324d200b1a1646502a3153e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronuously runs provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group.  <a href="classignite_1_1compute_1_1Compute.html#a925b1ce324d200b1a1646502a3153e9c">More...</a><br /></td></tr>
<tr class="separator:a925b1ce324d200b1a1646502a3153e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b18e881b65ac9c52d7e8ce926784bc"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:ae1b18e881b65ac9c52d7e8ce926784bc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#ae1b18e881b65ac9c52d7e8ce926784bc">Broadcast</a> (const F &amp;func)</td></tr>
<tr class="memdesc:ae1b18e881b65ac9c52d7e8ce926784bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group.  <a href="classignite_1_1compute_1_1Compute.html#ae1b18e881b65ac9c52d7e8ce926784bc">More...</a><br /></td></tr>
<tr class="separator:ae1b18e881b65ac9c52d7e8ce926784bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac88705f7750ccb045a0aa5f0cb1af1e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aac88705f7750ccb045a0aa5f0cb1af1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#aac88705f7750ccb045a0aa5f0cb1af1e">Broadcast</a> (const F &amp;func)</td></tr>
<tr class="memdesc:aac88705f7750ccb045a0aa5f0cb1af1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group.  <a href="classignite_1_1compute_1_1Compute.html#aac88705f7750ccb045a0aa5f0cb1af1e">More...</a><br /></td></tr>
<tr class="separator:aac88705f7750ccb045a0aa5f0cb1af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7706da990ae1627fe03068ba0d4348"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F &gt; </td></tr>
<tr class="memitem:aec7706da990ae1627fe03068ba0d4348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; std::vector&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#aec7706da990ae1627fe03068ba0d4348">BroadcastAsync</a> (const F &amp;func)</td></tr>
<tr class="memdesc:aec7706da990ae1627fe03068ba0d4348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronuously broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group.  <a href="classignite_1_1compute_1_1Compute.html#aec7706da990ae1627fe03068ba0d4348">More...</a><br /></td></tr>
<tr class="separator:aec7706da990ae1627fe03068ba0d4348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5219371ae17473ae0528494b9b0a64"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9a5219371ae17473ae0528494b9b0a64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a9a5219371ae17473ae0528494b9b0a64">BroadcastAsync</a> (const F &amp;func)</td></tr>
<tr class="memdesc:a9a5219371ae17473ae0528494b9b0a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronuously broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group.  <a href="classignite_1_1compute_1_1Compute.html#a9a5219371ae17473ae0528494b9b0a64">More...</a><br /></td></tr>
<tr class="separator:a9a5219371ae17473ae0528494b9b0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2537d13ab066ad8e215ef4374a3a3b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A &gt; </td></tr>
<tr class="memitem:ade2537d13ab066ad8e215ef4374a3a3b"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#ade2537d13ab066ad8e215ef4374a3a3b">ExecuteJavaTask</a> (const std::string &amp;taskName, const A &amp;taskArg)</td></tr>
<tr class="memdesc:ade2537d13ab066ad8e215ef4374a3a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given Java task on the grid projection.  <a href="classignite_1_1compute_1_1Compute.html#ade2537d13ab066ad8e215ef4374a3a3b">More...</a><br /></td></tr>
<tr class="separator:ade2537d13ab066ad8e215ef4374a3a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1087e047416a644a18f5faa5d9a5a172"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a1087e047416a644a18f5faa5d9a5a172"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a1087e047416a644a18f5faa5d9a5a172">ExecuteJavaTask</a> (const std::string &amp;taskName)</td></tr>
<tr class="memdesc:a1087e047416a644a18f5faa5d9a5a172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes given Java task on the grid projection.  <a href="classignite_1_1compute_1_1Compute.html#a1087e047416a644a18f5faa5d9a5a172">More...</a><br /></td></tr>
<tr class="separator:a1087e047416a644a18f5faa5d9a5a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b8eaba2140197487f2ba72c9617c49"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A &gt; </td></tr>
<tr class="memitem:a27b8eaba2140197487f2ba72c9617c49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a27b8eaba2140197487f2ba72c9617c49">ExecuteJavaTaskAsync</a> (const std::string &amp;taskName, const A &amp;taskArg)</td></tr>
<tr class="memdesc:a27b8eaba2140197487f2ba72c9617c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes given Java task on the grid projection.  <a href="classignite_1_1compute_1_1Compute.html#a27b8eaba2140197487f2ba72c9617c49">More...</a><br /></td></tr>
<tr class="separator:a27b8eaba2140197487f2ba72c9617c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de1ab442d8e3bbc860b742ad5ebe230"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a7de1ab442d8e3bbc860b742ad5ebe230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1compute_1_1Compute.html#a7de1ab442d8e3bbc860b742ad5ebe230">ExecuteJavaTaskAsync</a> (const std::string &amp;taskName)</td></tr>
<tr class="memdesc:a7de1ab442d8e3bbc860b742ad5ebe230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes given Java task on the grid projection.  <a href="classignite_1_1compute_1_1Compute.html#a7de1ab442d8e3bbc860b742ad5ebe230">More...</a><br /></td></tr>
<tr class="separator:a7de1ab442d8e3bbc860b742ad5ebe230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup. </p>
<p>Instance of <a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> is obtained from <a class="el" href="classignite_1_1Ignite.html" title="Main interface to operate with Ignite.">Ignite</a> as follows: </p><div class="fragment"><div class="line">Ignite node = <a class="code" href="classignite_1_1Ignition.html#a315203f10279abb51fded37725cfff5a">Ignition::Get</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Compute over all nodes in the cluster.</span></div>
<div class="line"><a class="code" href="classignite_1_1compute_1_1Compute.html#a46471b90d45dcc498687eb2c96c21a15">Compute</a> c = node.GetCompute();</div>
</div><!-- fragment --><dl class="section user"><dt>Load Balancing</dt><dd>In all cases other than <code>Broadcast(...)</code>, <a class="el" href="classignite_1_1Ignite.html" title="Main interface to operate with Ignite.">Ignite</a> must select a node for a computation to be executed. The node will be selected based on the underlying <code>LoadBalancingSpi</code>, which by default sequentially picks next available node from the underlying cluster group. Other load balancing policies, such as <code>random</code> or <code>adaptive</code>, can be configured as well by selecting a different load balancing SPI in <a class="el" href="classignite_1_1Ignite.html" title="Main interface to operate with Ignite.">Ignite</a> configuration.</dd></dl>
<dl class="section user"><dt>Fault Tolerance</dt><dd><a class="el" href="classignite_1_1Ignite.html" title="Main interface to operate with Ignite.">Ignite</a> guarantees that as long as there is at least one grid node standing, every job will be executed. Jobs will automatically failover to another node if a remote node crashed or has rejected execution due to lack of resources. By default, in case of failover, next load balanced node will be picked for job execution. Also jobs will never be re-routed to the nodes they have failed on. This behavior can be changed by configuring any of the existing or a custom FailoverSpi in grid configuration.</dd></dl>
<dl class="section user"><dt>Computation SPIs</dt><dd>Note that regardless of which method is used for executing computations, all relevant SPI implementations configured for this compute instance will be used (i.e. failover, load balancing, collision resolution, checkpoints, etc.). </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46471b90d45dcc498687eb2c96c21a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46471b90d45dcc498687eb2c96c21a15">&#9670;&nbsp;</a></span>Compute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ignite::compute::Compute::Compute </td>
          <td>(</td>
          <td class="paramtype">common::concurrent::SharedPointer&lt; impl::compute::ComputeImpl &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Internal method. Should not be used by user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>Implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a530a3cce23a9d2707c08d539f26c5006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530a3cce23a9d2707c08d539f26c5006">&#9670;&nbsp;</a></span>AffinityCall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R ignite::compute::Compute::AffinityCall </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cacheName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given job on the node where data for provided affinity key is located (a.k.a. </p>
<p>affinity co-location).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Call return type. BinaryType should be specialized for the type if it is not primitive. Should not be void. For non-returning methods see <a class="el" href="classignite_1_1compute_1_1Compute.html#a0a6dc52f89ac7994ee603276997a4f71" title="Executes given job on the node where data for provided affinity key is located (a....">Compute::AffinityRun()</a>. </td></tr>
    <tr><td class="paramname">K</td><td>Affinity key type. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheName</td><td>Cache name to use for affinity co-location. </td></tr>
    <tr><td class="paramname">key</td><td>Affinity key. </td></tr>
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computation result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc07e207eac96a2f237ba88aef38aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc07e207eac96a2f237ba88aef38aaf">&#9670;&nbsp;</a></span>AffinityCallAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;R&gt; ignite::compute::Compute::AffinityCallAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cacheName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given job asynchronously on the node where data for provided affinity key is located (a.k.a. </p>
<p>affinity co-location).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Call return type. BinaryType should be specialized for the type if it is not primitive. Should not be void. For non-returning methods see <a class="el" href="classignite_1_1compute_1_1Compute.html#a0a6dc52f89ac7994ee603276997a4f71" title="Executes given job on the node where data for provided affinity key is located (a....">Compute::AffinityRun()</a>. </td></tr>
    <tr><td class="paramname">K</td><td>Affinity key type. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheName</td><td>Cache name to use for affinity co-location. </td></tr>
    <tr><td class="paramname">key</td><td>Affinity key. </td></tr>
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to access computation result once it's ready. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a6dc52f89ac7994ee603276997a4f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6dc52f89ac7994ee603276997a4f71">&#9670;&nbsp;</a></span>AffinityRun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ignite::compute::Compute::AffinityRun </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cacheName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given job on the node where data for provided affinity key is located (a.k.a. </p>
<p>affinity co-location).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Affinity key type. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheName</td><td>Cache names to use for affinity co-location. </td></tr>
    <tr><td class="paramname">key</td><td>Affinity key. </td></tr>
    <tr><td class="paramname">action</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> action to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03bdc90e6e895dd59186ad478a9ffff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03bdc90e6e895dd59186ad478a9ffff">&#9670;&nbsp;</a></span>AffinityRunAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;void&gt; ignite::compute::Compute::AffinityRunAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cacheName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given job asynchronously on the node where data for provided affinity key is located (a.k.a. </p>
<p>affinity co-location).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Affinity key type. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheName</td><td>Cache names to use for affinity co-location. </td></tr>
    <tr><td class="paramname">key</td><td>Affinity key. </td></tr>
    <tr><td class="paramname">action</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> action to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to access computation result once it's ready. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1b18e881b65ac9c52d7e8ce926784bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b18e881b65ac9c52d7e8ce926784bc">&#9670;&nbsp;</a></span>Broadcast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;R&gt; ignite::compute::Compute::Broadcast </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Function return type. BinaryType should be specialized for the type if it is not primitive. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing computation results. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac88705f7750ccb045a0aa5f0cb1af1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac88705f7750ccb045a0aa5f0cb1af1e">&#9670;&nbsp;</a></span>Broadcast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ignite::compute::Compute::Broadcast </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec7706da990ae1627fe03068ba0d4348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7706da990ae1627fe03068ba0d4348">&#9670;&nbsp;</a></span>BroadcastAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt; std::vector&lt;R&gt; &gt; ignite::compute::Compute::BroadcastAsync </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronuously broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Function return type. BinaryType should be specialized for the type if it is not primitive. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to access computation results once they are ready. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a5219371ae17473ae0528494b9b0a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5219371ae17473ae0528494b9b0a64">&#9670;&nbsp;</a></span>BroadcastAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;void&gt; ignite::compute::Compute::BroadcastAsync </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronuously broadcasts provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> to all nodes in the cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to wait for action to complete. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca0cdfcd21e2b6999aa3831bd53b713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca0cdfcd21e2b6999aa3831bd53b713">&#9670;&nbsp;</a></span>Call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R ignite::compute::Compute::Call </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Call return type. BinaryType should be specialized for the type if it is not primitive. Should not be void. For non-returning methods see <a class="el" href="classignite_1_1compute_1_1Compute.html#a5552a0110ef5ef25429393416c6c7aa9" title="Runs provided ComputeFunc on a node within the underlying cluster group.">Compute::Run()</a>. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computation result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c478a31dec5a52a0f3cc99052941ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c478a31dec5a52a0f3cc99052941ea">&#9670;&nbsp;</a></span>CallAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;R&gt; ignite::compute::Compute::CallAsync </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronuously calls provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Call return type. BinaryType should be specialized for the type if it is not primitive. Should not be void. For non-returning methods see <a class="el" href="classignite_1_1compute_1_1Compute.html#a5552a0110ef5ef25429393416c6c7aa9" title="Runs provided ComputeFunc on a node within the underlying cluster group.">Compute::Run()</a>. </td></tr>
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;R&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to access computation result once it's ready. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1087e047416a644a18f5faa5d9a5a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1087e047416a644a18f5faa5d9a5a172">&#9670;&nbsp;</a></span>ExecuteJavaTask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R ignite::compute::Compute::ExecuteJavaTask </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>taskName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given Java task on the grid projection. </p>
<p>If task for given name has not been deployed yet, then 'taskName' will be used as task class name to auto-deploy the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskName</td><td>Java task name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task result of type <code>R</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of task result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade2537d13ab066ad8e215ef4374a3a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2537d13ab066ad8e215ef4374a3a3b">&#9670;&nbsp;</a></span>ExecuteJavaTask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R ignite::compute::Compute::ExecuteJavaTask </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>taskName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>taskArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes given Java task on the grid projection. </p>
<p>If task for given name has not been deployed yet, then 'taskName' will be used as task class name to auto-deploy the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskName</td><td>Java task name. </td></tr>
    <tr><td class="paramname">taskArg</td><td>Argument of task execution of type A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task result of type <code>R</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of task result. </td></tr>
    <tr><td class="paramname">A</td><td>Type of task argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7de1ab442d8e3bbc860b742ad5ebe230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de1ab442d8e3bbc860b742ad5ebe230">&#9670;&nbsp;</a></span>ExecuteJavaTaskAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;R&gt; ignite::compute::Compute::ExecuteJavaTaskAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>taskName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes given Java task on the grid projection. </p>
<p>If task for given name has not been deployed yet, then 'taskName' will be used as task class name to auto-deploy the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskName</td><td>Java task name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> containing a result of type <code>R</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of task result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27b8eaba2140197487f2ba72c9617c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b8eaba2140197487f2ba72c9617c49">&#9670;&nbsp;</a></span>ExecuteJavaTaskAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;R&gt; ignite::compute::Compute::ExecuteJavaTaskAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>taskName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>taskArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes given Java task on the grid projection. </p>
<p>If task for given name has not been deployed yet, then 'taskName' will be used as task class name to auto-deploy the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskName</td><td>Java task name. </td></tr>
    <tr><td class="paramname">taskArg</td><td>Argument of task execution of type A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> containing a result of type <code>R</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Type of task result. </td></tr>
    <tr><td class="paramname">A</td><td>Type of task argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5552a0110ef5ef25429393416c6c7aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5552a0110ef5ef25429393416c6c7aa9">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ignite::compute::Compute::Run </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;void&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a925b1ce324d200b1a1646502a3153e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925b1ce324d200b1a1646502a3153e9c">&#9670;&nbsp;</a></span>RunAsync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1Future.html">Future</a>&lt;void&gt; ignite::compute::Compute::RunAsync </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asyncronuously runs provided <a class="el" href="classignite_1_1compute_1_1ComputeFunc.html" title="Interface for a simple compute function that can be serialized and called on the remote nodes.">ComputeFunc</a> on a node within the underlying cluster group. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function type. Should implement ComputeFunc&lt;void&gt; class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td><a class="el" href="classignite_1_1compute_1_1Compute.html" title="Defines compute grid functionality for executing tasks and closures over nodes in the ClusterGroup.">Compute</a> function to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1Future.html" title="Future class template.">Future</a> that can be used to wait for action to complete. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information.">IgniteError</a></td><td>in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="compute_8h_source.html">compute.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassignite_1_1compute_1_1Compute_html_a46471b90d45dcc498687eb2c96c21a15"><div class="ttname"><a href="classignite_1_1compute_1_1Compute.html#a46471b90d45dcc498687eb2c96c21a15">ignite::compute::Compute::Compute</a></div><div class="ttdeci">Compute(common::concurrent::SharedPointer&lt; impl::compute::ComputeImpl &gt; impl)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> compute.h:84</div></div>
<div class="ttc" id="aclassignite_1_1Ignition_html_a315203f10279abb51fded37725cfff5a"><div class="ttname"><a href="classignite_1_1Ignition.html#a315203f10279abb51fded37725cfff5a">ignite::Ignition::Get</a></div><div class="ttdeci">static Ignite Get()</div><div class="ttdoc">Get default Ignite instance.</div><div class="ttdef"><b>Definition:</b> ignition.cpp:361</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 25 2023 18:31:45 for &nbsp; Apache Ignite C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
