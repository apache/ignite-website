<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Ignite C++ Client: ignite::key_value_view&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Apache_Ignite_logo_128x128.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Ignite C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ignite</b></li><li class="navelem"><a class="el" href="classignite_1_1key__value__view.html">key_value_view</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classignite_1_1key__value__view-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ignite::key_value_view&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="key__value__view_8h_source.html">key_value_view.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a946ca3e30cbd58770e31852157cc59d0"><td class="memItemLeft" align="right" valign="top"><a id="a946ca3e30cbd58770e31852157cc59d0"></a>
typedef std::decay&lt; K &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a946ca3e30cbd58770e31852157cc59d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c780c11c64ab01312aeb68d58ffc03"><td class="memItemLeft" align="right" valign="top"><a id="ae1c780c11c64ab01312aeb68d58ffc03"></a>
typedef std::decay&lt; V &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ae1c780c11c64ab01312aeb68d58ffc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0bee087c3c606c5cea359ce80b37d78"><td class="memItemLeft" align="right" valign="top"><a id="ac0bee087c3c606c5cea359ce80b37d78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_value_view</b> (const <a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;)=delete</td></tr>
<tr class="separator:ac0bee087c3c606c5cea359ce80b37d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf91de3fc61293096fc4fa6930fe2524"><td class="memItemLeft" align="right" valign="top"><a id="abf91de3fc61293096fc4fa6930fe2524"></a>
<a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;)=delete</td></tr>
<tr class="separator:abf91de3fc61293096fc4fa6930fe2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63076819fce475264031a2d42006c523"><td class="memItemLeft" align="right" valign="top"><a id="a63076819fce475264031a2d42006c523"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>key_value_view</b> (<a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a63076819fce475264031a2d42006c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb0f784122f070dc96414dc30287a85"><td class="memItemLeft" align="right" valign="top"><a id="aaeb0f784122f070dc96414dc30287a85"></a>
<a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classignite_1_1key__value__view.html">key_value_view</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:aaeb0f784122f070dc96414dc30287a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddd192e80c68baabdf76dcdef686f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a2ddd192e80c68baabdf76dcdef686f07">get_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, ignite_callback&lt; std::optional&lt; value_type &gt;&gt; callback)</td></tr>
<tr class="separator:a2ddd192e80c68baabdf76dcdef686f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c18efe43788ca16bf38285e4fa014ab"><td class="memItemLeft" align="right" valign="top">std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a6c18efe43788ca16bf38285e4fa014ab">get</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key)</td></tr>
<tr class="separator:a6c18efe43788ca16bf38285e4fa014ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4b6502058cccabbbf091fec8e43a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a3a4b6502058cccabbbf091fec8e43a49">get_all_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, std::vector&lt; key_type &gt; keys, ignite_callback&lt; std::vector&lt; std::optional&lt; value_type &gt;&gt;&gt; callback)</td></tr>
<tr class="separator:a3a4b6502058cccabbbf091fec8e43a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a26af50af3ce6114417f629e5bea0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::optional&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ae1a26af50af3ce6114417f629e5bea0b">get_all</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, std::vector&lt; key_type &gt; keys)</td></tr>
<tr class="separator:ae1a26af50af3ce6114417f629e5bea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce102f9ba020aedd1adca8582ab82bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#acce102f9ba020aedd1adca8582ab82bb">contains_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:acce102f9ba020aedd1adca8582ab82bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438aa22c2abc2b685fe46cebcf625382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a438aa22c2abc2b685fe46cebcf625382">contains</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key)</td></tr>
<tr class="separator:a438aa22c2abc2b685fe46cebcf625382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b585507e739e8fee6ee7289d2ae7944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a1b585507e739e8fee6ee7289d2ae7944">put_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; void &gt; callback)</td></tr>
<tr class="separator:a1b585507e739e8fee6ee7289d2ae7944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb041efc7731c63c9069526096958bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a8fb041efc7731c63c9069526096958bc">put</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:a8fb041efc7731c63c9069526096958bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acd283697bc12ccda4090385236c77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a7acd283697bc12ccda4090385236c77a">put_all_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;pairs, ignite_callback&lt; void &gt; callback)</td></tr>
<tr class="separator:a7acd283697bc12ccda4090385236c77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79e5905a7d005d12d40a62a4e48f047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#af79e5905a7d005d12d40a62a4e48f047">put_all</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;pairs)</td></tr>
<tr class="separator:af79e5905a7d005d12d40a62a4e48f047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96617404aaabb28ba34f9d3349f67982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a96617404aaabb28ba34f9d3349f67982">get_and_put_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; std::optional&lt; value_type &gt;&gt; callback)</td></tr>
<tr class="separator:a96617404aaabb28ba34f9d3349f67982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f5cb2f87044820213ee3f55e737cd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ad51f5cb2f87044820213ee3f55e737cd">get_and_put</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:ad51f5cb2f87044820213ee3f55e737cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c18824a8f9840c21b2a5c8d8d4a404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a11c18824a8f9840c21b2a5c8d8d4a404">put_if_absent_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:a11c18824a8f9840c21b2a5c8d8d4a404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cca74ae89c7e078b9b8e703d5d0c1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a12cca74ae89c7e078b9b8e703d5d0c1a">put_if_absent</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:a12cca74ae89c7e078b9b8e703d5d0c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb6f8d6805afb211a11631d74ca7d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#aabbb6f8d6805afb211a11631d74ca7d9">remove_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:aabbb6f8d6805afb211a11631d74ca7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c83d98b919e846c7ef990846a5d383c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a9c83d98b919e846c7ef990846a5d383c">remove</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key)</td></tr>
<tr class="separator:a9c83d98b919e846c7ef990846a5d383c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b403a8358e2e6a24795c0b64c3b0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a13b403a8358e2e6a24795c0b64c3b0cd">remove_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:a13b403a8358e2e6a24795c0b64c3b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4618966f2fe95c44fa74176ef99c748f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a4618966f2fe95c44fa74176ef99c748f">remove</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:a4618966f2fe95c44fa74176ef99c748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac132466d367ba5073e41115b38d2ceeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ac132466d367ba5073e41115b38d2ceeb">remove_all_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, std::vector&lt; key_type &gt; keys, ignite_callback&lt; std::vector&lt; key_type &gt;&gt; callback)</td></tr>
<tr class="separator:ac132466d367ba5073e41115b38d2ceeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67658701cbd4471eacc767137cb44e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; key_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ade67658701cbd4471eacc767137cb44e">remove_all</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, std::vector&lt; key_type &gt; keys)</td></tr>
<tr class="separator:ade67658701cbd4471eacc767137cb44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e6facf045a5c6b04d06c585d790127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ac9e6facf045a5c6b04d06c585d790127">remove_all_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;pairs, ignite_callback&lt; std::vector&lt; key_type &gt;&gt; callback)</td></tr>
<tr class="separator:ac9e6facf045a5c6b04d06c585d790127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7982268dee85d093eafd62b16baf25"><td class="memItemLeft" align="right" valign="top">std::vector&lt; key_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#adc7982268dee85d093eafd62b16baf25">remove_all</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; pairs)</td></tr>
<tr class="separator:adc7982268dee85d093eafd62b16baf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53de299cc12e494c44bc3621f522a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ae53de299cc12e494c44bc3621f522a68">get_and_remove_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, ignite_callback&lt; std::optional&lt; value_type &gt;&gt; callback)</td></tr>
<tr class="separator:ae53de299cc12e494c44bc3621f522a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6494d215cac0386280987ea355939"><td class="memItemLeft" align="right" valign="top">std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ac4b6494d215cac0386280987ea355939">get_and_remove</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key)</td></tr>
<tr class="separator:ac4b6494d215cac0386280987ea355939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2c0a91dfc24af4da405b6fb48c5065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a6b2c0a91dfc24af4da405b6fb48c5065">replace_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:a6b2c0a91dfc24af4da405b6fb48c5065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054542741f66dd662444c2a7a31c6693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a054542741f66dd662444c2a7a31c6693">replace</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:a054542741f66dd662444c2a7a31c6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a70ffc61f77778275710891303b5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ad8a70ffc61f77778275710891303b5e2">replace_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;old_value, const value_type &amp;new_value, ignite_callback&lt; bool &gt; callback)</td></tr>
<tr class="separator:ad8a70ffc61f77778275710891303b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20476ecf30b8d9ffa5294457ced6ee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ab20476ecf30b8d9ffa5294457ced6ee4">replace</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;old_value, const value_type &amp;new_value)</td></tr>
<tr class="separator:ab20476ecf30b8d9ffa5294457ced6ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583b7bb017c77f043d2a48e80b93c063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#a583b7bb017c77f043d2a48e80b93c063">get_and_replace_async</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value, ignite_callback&lt; std::optional&lt; value_type &gt;&gt; callback)</td></tr>
<tr class="separator:a583b7bb017c77f043d2a48e80b93c063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078e3553118fdd99c4eabf8998dbbdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1key__value__view.html#ab078e3553118fdd99c4eabf8998dbbdc">get_and_replace</a> (<a class="el" href="classignite_1_1transaction.html">transaction</a> *tx, const key_type &amp;key, const value_type &amp;value)</td></tr>
<tr class="separator:ab078e3553118fdd99c4eabf8998dbbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5124a0653fef2dbc83bb943d7cb0f927"><td class="memItemLeft" align="right" valign="top"><a id="a5124a0653fef2dbc83bb943d7cb0f927"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:a5124a0653fef2dbc83bb943d7cb0f927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class ignite::key_value_view&lt; K, V &gt;</h3>

<p>Key-Value view interface provides methods to access table records in form of separate key and value parts. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a438aa22c2abc2b685fe46cebcf625382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438aa22c2abc2b685fe46cebcf625382">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the table contains an entry for the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value indicating whether value exists or not. </dd></dl>

</div>
</div>
<a id="acce102f9ba020aedd1adca8582ab82bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce102f9ba020aedd1adca8582ab82bb">&#9670;&nbsp;</a></span>contains_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::contains_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously determines if the table contains a value for the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback which is called on success with value indicating whether value exists or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c18efe43788ca16bf38285e4fa014ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c18efe43788ca16bf38285e4fa014ab">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;value_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a value by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value if exists and <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae1a26af50af3ce6114417f629e5bea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a26af50af3ce6114417f629e5bea0b">&#9670;&nbsp;</a></span>get_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::optional&lt;value_type&gt; &gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; key_type &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets multiple values by keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting records with all columns filled from the table. The order of elements is guaranteed to be the same as the order of keys. If a record does not exist, the resulting element of the corresponding order is <code>std::nullopt</code>. </dd></dl>

</div>
</div>
<a id="a3a4b6502058cccabbbf091fec8e43a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4b6502058cccabbbf091fec8e43a49">&#9670;&nbsp;</a></span>get_all_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_all_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; key_type &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::vector&lt; std::optional&lt; value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets multiple values by keys asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with resulting records with all columns filled from the table. The order of elements is guaranteed to be the same as the order of keys. If a record does not exist, the resulting element of the corresponding order is <code>std::nullopt</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad51f5cb2f87044820213ee3f55e737cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51f5cb2f87044820213ee3f55e737cd">&#9670;&nbsp;</a></span>get_and_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;value_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts a value with a given key and returns previous value for the key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A replaced value or <code>std::nullopt</code> if it did not exist. </dd></dl>

</div>
</div>
<a id="a96617404aaabb28ba34f9d3349f67982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96617404aaabb28ba34f9d3349f67982">&#9670;&nbsp;</a></span>get_and_put_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_put_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::optional&lt; value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts a value with a given key and returns previous value for the key asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. Called with a value which contains replaced value or <code>std::nullopt</code> if it did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4b6494d215cac0386280987ea355939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b6494d215cac0386280987ea355939">&#9670;&nbsp;</a></span>get_and_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;value_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets and removes a value associated with the given key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A removed record or <code>std::nullopt</code> if it did not exist. </dd></dl>

</div>
</div>
<a id="ae53de299cc12e494c44bc3621f522a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53de299cc12e494c44bc3621f522a68">&#9670;&nbsp;</a></span>get_and_remove_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_remove_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::optional&lt; value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets and removes a value associated with the given key asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with a removed record or <code>std::nullopt</code> if it did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab078e3553118fdd99c4eabf8998dbbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab078e3553118fdd99c4eabf8998dbbdc">&#9670;&nbsp;</a></span>get_and_replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;value_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces a record with the given key if it exists returning previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>A previous value for the given key, or <code>std::nullopt</code> if it did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583b7bb017c77f043d2a48e80b93c063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583b7bb017c77f043d2a48e80b93c063">&#9670;&nbsp;</a></span>get_and_replace_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_and_replace_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::optional&lt; value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously replaces a record with the given key if it exists returning previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. Called with a previous value for the given key, or <code>std::nullopt</code> if it did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ddd192e80c68baabdf76dcdef686f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddd192e80c68baabdf76dcdef686f07">&#9670;&nbsp;</a></span>get_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::get_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::optional&lt; value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a value by key asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback which is called on success with value if it exists and <code>std::nullopt</code> otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb041efc7731c63c9069526096958bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb041efc7731c63c9069526096958bc">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts a value with a given key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af79e5905a7d005d12d40a62a4e48f047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79e5905a7d005d12d40a62a4e48f047">&#9670;&nbsp;</a></span>put_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts multiple key-value pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">pairs</td><td>Pairs to put. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7acd283697bc12ccda4090385236c77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acd283697bc12ccda4090385236c77a">&#9670;&nbsp;</a></span>put_all_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put_all_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; void &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts multiple key-value pairs asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">pairs</td><td>Pairs to put. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b585507e739e8fee6ee7289d2ae7944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b585507e739e8fee6ee7289d2ae7944">&#9670;&nbsp;</a></span>put_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; void &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts a value with a given key asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12cca74ae89c7e078b9b8e703d5d0c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cca74ae89c7e078b9b8e703d5d0c1a">&#9670;&nbsp;</a></span>put_if_absent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put_if_absent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts a value with a given key if the specified key is not present in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c18824a8f9840c21b2a5c8d8d4a404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c18824a8f9840c21b2a5c8d8d4a404">&#9670;&nbsp;</a></span>put_if_absent_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::put_if_absent_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously puts a value with a given key if the specified key is not present in the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. Called with a value indicating whether the record was inserted. Equals <code>false</code> if a record with the same key already exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c83d98b919e846c7ef990846a5d383c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c83d98b919e846c7ef990846a5d383c">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a value with the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value indicating whether a record with the specified key was deleted. </dd></dl>

</div>
</div>
<a id="a4618966f2fe95c44fa74176ef99c748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4618966f2fe95c44fa74176ef99c748f">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a value with a given key from the table only if it is equal to the specified value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value indicating whether a record with the specified key was deleted. </dd></dl>

</div>
</div>
<a id="ade67658701cbd4471eacc767137cb44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade67658701cbd4471eacc767137cb44e">&#9670;&nbsp;</a></span>remove_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;key_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; key_type &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes values with given keys from the table. If one or more keys do not exist, other values are still removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Records from <code>keys</code> that did not exist. </dd></dl>

</div>
</div>
<a id="adc7982268dee85d093eafd62b16baf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7982268dee85d093eafd62b16baf25">&#9670;&nbsp;</a></span>remove_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;key_type&gt; <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes records with given keys and values from the table. If one or more records do not exist, other records are still removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">pairs</td><td>Pairs to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Records from <code>records</code> that did not exist. </dd></dl>

</div>
</div>
<a id="ac9e6facf045a5c6b04d06c585d790127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e6facf045a5c6b04d06c585d790127">&#9670;&nbsp;</a></span>remove_all_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_all_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; key_type, value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::vector&lt; key_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes records with given keys and values from the table asynchronously. If one or more records do not exist, other records are still removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">pairs</td><td>Pairs to remove. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with records from <code>records</code> that did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac132466d367ba5073e41115b38d2ceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac132466d367ba5073e41115b38d2ceeb">&#9670;&nbsp;</a></span>remove_all_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_all_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; key_type &gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; std::vector&lt; key_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes values with given keys from the table asynchronously. If one or more keys do not exist, other values are still removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with records from <code>keys</code> that did not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b403a8358e2e6a24795c0b64c3b0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b403a8358e2e6a24795c0b64c3b0cd">&#9670;&nbsp;</a></span>remove_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously removes a value with a given key from the table only if it is equal to the specified value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with a value indicating whether a record with the specified key was deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabbb6f8d6805afb211a11631d74ca7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb6f8d6805afb211a11631d74ca7d9">&#9670;&nbsp;</a></span>remove_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::remove_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a value with the specified key asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called on operation completion. Called with a value indicating whether a record with the specified key was deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20476ecf30b8d9ffa5294457ced6ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20476ecf30b8d9ffa5294457ced6ee4">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces a value with a <code>new_value</code> one only if existing value equals to the specified <code>old_value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">old_value</td><td>Value to be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>New value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value indicating whether a specified record was replaced. </dd></dl>

</div>
</div>
<a id="a054542741f66dd662444c2a7a31c6693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054542741f66dd662444c2a7a31c6693">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces a record with the same key columns if it exists, otherwise does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value indicating whether a record with the specified key was replaced. </dd></dl>

</div>
</div>
<a id="ad8a70ffc61f77778275710891303b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a70ffc61f77778275710891303b5e2">&#9670;&nbsp;</a></span>replace_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::replace_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously replaces a value with a <code>new_value</code> one only if existing value equals to the specified <code>old_value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">old_value</td><td>Value to be replaced. </td></tr>
    <tr><td class="paramname">new_value</td><td>New value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. Called with a value indicating whether a specified record was replaced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2c0a91dfc24af4da405b6fb48c5065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2c0a91dfc24af4da405b6fb48c5065">&#9670;&nbsp;</a></span>replace_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1key__value__view.html">ignite::key_value_view</a>&lt; K, V &gt;::replace_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1transaction.html">transaction</a> *&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignite_callback&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously replaces a record with the specified key if it exists, otherwise does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>Optional transaction. If nullptr implicit transaction for this single operation is used. </td></tr>
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">value</td><td>Value. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback. Called with a value indicating whether a record with the specified key was replaced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ignite/client/table/<a class="el" href="key__value__view_8h_source.html">key_value_view.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
