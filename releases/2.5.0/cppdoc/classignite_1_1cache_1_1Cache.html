<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://ignite.apache.org/releases/2.5.0/cppdoc/classignite_1_1cache_1_1Cache.html" />
<META NAME="ROBOTS" CONTENT="NOINDEX">

<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>&nbsp; Apache Ignite C++: ignite::cache::Cache&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ignite_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">&nbsp; Apache Ignite C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignite.html">ignite</a></li><li class="navelem"><a class="el" href="namespaceignite_1_1cache.html">cache</a></li><li class="navelem"><a class="el" href="classignite_1_1cache_1_1Cache.html">Cache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classignite_1_1cache_1_1Cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ignite::cache::Cache&lt; K, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main entry point for all Data Grid APIs.  
 <a href="classignite_1_1cache_1_1Cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache_8h_source.html">cache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5028ce3aa42ed7f8c3e4304e7b5653b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ad5028ce3aa42ed7f8c3e4304e7b5653b">Cache</a> (impl::cache::CacheImpl *impl)</td></tr>
<tr class="memdesc:ad5028ce3aa42ed7f8c3e4304e7b5653b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad5028ce3aa42ed7f8c3e4304e7b5653b">More...</a><br /></td></tr>
<tr class="separator:ad5028ce3aa42ed7f8c3e4304e7b5653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd752b6d7b94c716504c91d3f4553b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a1edd752b6d7b94c716504c91d3f4553b">GetName</a> () const </td></tr>
<tr class="memdesc:a1edd752b6d7b94c716504c91d3f4553b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of this cache (null for default cache).  <a href="#a1edd752b6d7b94c716504c91d3f4553b">More...</a><br /></td></tr>
<tr class="separator:a1edd752b6d7b94c716504c91d3f4553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60db60b4b35fbaf00e542c76b1927707"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a60db60b4b35fbaf00e542c76b1927707">IsEmpty</a> ()</td></tr>
<tr class="memdesc:a60db60b4b35fbaf00e542c76b1927707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this cache contains no key-value mappings.  <a href="#a60db60b4b35fbaf00e542c76b1927707">More...</a><br /></td></tr>
<tr class="separator:a60db60b4b35fbaf00e542c76b1927707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2e29657a3ad0f8be0c82db1d6dd78f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aac2e29657a3ad0f8be0c82db1d6dd78f">IsEmpty</a> (<a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:aac2e29657a3ad0f8be0c82db1d6dd78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this cache contains no key-value mappings.  <a href="#aac2e29657a3ad0f8be0c82db1d6dd78f">More...</a><br /></td></tr>
<tr class="separator:aac2e29657a3ad0f8be0c82db1d6dd78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dc8bbe041c277eb2c8f546cd343167"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a50dc8bbe041c277eb2c8f546cd343167">ContainsKey</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a50dc8bbe041c277eb2c8f546cd343167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for this key.  <a href="#a50dc8bbe041c277eb2c8f546cd343167">More...</a><br /></td></tr>
<tr class="separator:a50dc8bbe041c277eb2c8f546cd343167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab73114323001dbb7edebbcf011be0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#afab73114323001dbb7edebbcf011be0d">ContainsKey</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:afab73114323001dbb7edebbcf011be0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for this key.  <a href="#afab73114323001dbb7edebbcf011be0d">More...</a><br /></td></tr>
<tr class="separator:afab73114323001dbb7edebbcf011be0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2059398f1e0dcb39daf0f437a99fb9be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a2059398f1e0dcb39daf0f437a99fb9be">ContainsKeys</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a2059398f1e0dcb39daf0f437a99fb9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="#a2059398f1e0dcb39daf0f437a99fb9be">More...</a><br /></td></tr>
<tr class="separator:a2059398f1e0dcb39daf0f437a99fb9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089a84634bfe5ddf0f4db0c31f7a6a26"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a089a84634bfe5ddf0f4db0c31f7a6a26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a089a84634bfe5ddf0f4db0c31f7a6a26">ContainsKeys</a> (InputIter begin, InputIter end)</td></tr>
<tr class="memdesc:a089a84634bfe5ddf0f4db0c31f7a6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="#a089a84634bfe5ddf0f4db0c31f7a6a26">More...</a><br /></td></tr>
<tr class="separator:a089a84634bfe5ddf0f4db0c31f7a6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdca32b50dba8b000e6dcb3ed6f893a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a6cdca32b50dba8b000e6dcb3ed6f893a">ContainsKeys</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a6cdca32b50dba8b000e6dcb3ed6f893a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cache contains mapping for these keys.  <a href="#a6cdca32b50dba8b000e6dcb3ed6f893a">More...</a><br /></td></tr>
<tr class="separator:a6cdca32b50dba8b000e6dcb3ed6f893a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ad1e06c09574e7008b417a27eba5f3"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a02ad1e06c09574e7008b417a27eba5f3">LocalPeek</a> (const K &amp;key, int32_t peekModes)</td></tr>
<tr class="memdesc:a02ad1e06c09574e7008b417a27eba5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at cached value using optional set of peek modes.  <a href="#a02ad1e06c09574e7008b417a27eba5f3">More...</a><br /></td></tr>
<tr class="separator:a02ad1e06c09574e7008b417a27eba5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ea86d2b3f19ffd7c024eeb03cb2124"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a16ea86d2b3f19ffd7c024eeb03cb2124">LocalPeek</a> (const K &amp;key, int32_t peekModes, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a16ea86d2b3f19ffd7c024eeb03cb2124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at cached value using optional set of peek modes.  <a href="#a16ea86d2b3f19ffd7c024eeb03cb2124">More...</a><br /></td></tr>
<tr class="separator:a16ea86d2b3f19ffd7c024eeb03cb2124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca8ec1f2d66762816de72b57c5cbdb0"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a5ca8ec1f2d66762816de72b57c5cbdb0">Get</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a5ca8ec1f2d66762816de72b57c5cbdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves value mapped to the specified key from cache.  <a href="#a5ca8ec1f2d66762816de72b57c5cbdb0">More...</a><br /></td></tr>
<tr class="separator:a5ca8ec1f2d66762816de72b57c5cbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf114b9d8b45f2588659b217ffd9d9"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a54bf114b9d8b45f2588659b217ffd9d9">Get</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a54bf114b9d8b45f2588659b217ffd9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves value mapped to the specified key from cache.  <a href="#a54bf114b9d8b45f2588659b217ffd9d9">More...</a><br /></td></tr>
<tr class="separator:a54bf114b9d8b45f2588659b217ffd9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba088938308bb2a01233a55cfd8ef546"><td class="memItemLeft" align="right" valign="top">std::map&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aba088938308bb2a01233a55cfd8ef546">GetAll</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:aba088938308bb2a01233a55cfd8ef546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="#aba088938308bb2a01233a55cfd8ef546">More...</a><br /></td></tr>
<tr class="separator:aba088938308bb2a01233a55cfd8ef546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac341a3ac21b498e0a393851b1a0844c9"><td class="memItemLeft" align="right" valign="top">std::map&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ac341a3ac21b498e0a393851b1a0844c9">GetAll</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ac341a3ac21b498e0a393851b1a0844c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="#ac341a3ac21b498e0a393851b1a0844c9">More...</a><br /></td></tr>
<tr class="separator:ac341a3ac21b498e0a393851b1a0844c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96ce4a9292d05c1937383fb576a936"><td class="memTemplParams" colspan="2">template&lt;typename InIter , typename OutIter &gt; </td></tr>
<tr class="memitem:a5e96ce4a9292d05c1937383fb576a936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a5e96ce4a9292d05c1937383fb576a936">GetAll</a> (InIter begin, InIter end, OutIter dst)</td></tr>
<tr class="memdesc:a5e96ce4a9292d05c1937383fb576a936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values mapped to the specified keys from cache.  <a href="#a5e96ce4a9292d05c1937383fb576a936">More...</a><br /></td></tr>
<tr class="separator:a5e96ce4a9292d05c1937383fb576a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ef50fa610c713e5284cefa4a325a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a236ef50fa610c713e5284cefa4a325a9">Put</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:a236ef50fa610c713e5284cefa4a325a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in the cache.  <a href="#a236ef50fa610c713e5284cefa4a325a9">More...</a><br /></td></tr>
<tr class="separator:a236ef50fa610c713e5284cefa4a325a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bbcdeb410146e389f751c8ec94bf95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a31bbcdeb410146e389f751c8ec94bf95">Put</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a31bbcdeb410146e389f751c8ec94bf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in the cache.  <a href="#a31bbcdeb410146e389f751c8ec94bf95">More...</a><br /></td></tr>
<tr class="separator:a31bbcdeb410146e389f751c8ec94bf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26753649804a932daee2e3e43c4df74c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a26753649804a932daee2e3e43c4df74c">PutAll</a> (const std::map&lt; K, V &gt; &amp;vals)</td></tr>
<tr class="memdesc:a26753649804a932daee2e3e43c4df74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="#a26753649804a932daee2e3e43c4df74c">More...</a><br /></td></tr>
<tr class="separator:a26753649804a932daee2e3e43c4df74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84472f375ba3fcc1a4af80756dfd6ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ac84472f375ba3fcc1a4af80756dfd6ba">PutAll</a> (const std::map&lt; K, V &gt; &amp;vals, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ac84472f375ba3fcc1a4af80756dfd6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="#ac84472f375ba3fcc1a4af80756dfd6ba">More...</a><br /></td></tr>
<tr class="separator:ac84472f375ba3fcc1a4af80756dfd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef0fa0e9ab2c0d6194149f9084dd2af"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:abef0fa0e9ab2c0d6194149f9084dd2af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#abef0fa0e9ab2c0d6194149f9084dd2af">PutAll</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:abef0fa0e9ab2c0d6194149f9084dd2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pairs in cache.  <a href="#abef0fa0e9ab2c0d6194149f9084dd2af">More...</a><br /></td></tr>
<tr class="separator:abef0fa0e9ab2c0d6194149f9084dd2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b537114aa4c59439d56c1ce33f707c"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#af7b537114aa4c59439d56c1ce33f707c">GetAndPut</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:af7b537114aa4c59439d56c1ce33f707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in this cache, returning an existing value if one existed.  <a href="#af7b537114aa4c59439d56c1ce33f707c">More...</a><br /></td></tr>
<tr class="separator:af7b537114aa4c59439d56c1ce33f707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4c1512f82c0dee61e39834edc2aae3"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#acc4c1512f82c0dee61e39834edc2aae3">GetAndPut</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:acc4c1512f82c0dee61e39834edc2aae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the specified value with the specified key in this cache, returning an existing value if one existed.  <a href="#acc4c1512f82c0dee61e39834edc2aae3">More...</a><br /></td></tr>
<tr class="separator:acc4c1512f82c0dee61e39834edc2aae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248126e1b19e58616e0b82915b41b71b"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a248126e1b19e58616e0b82915b41b71b">GetAndReplace</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:a248126e1b19e58616e0b82915b41b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaces the value for a given key if and only if there is a value currently mapped by the key.  <a href="#a248126e1b19e58616e0b82915b41b71b">More...</a><br /></td></tr>
<tr class="separator:a248126e1b19e58616e0b82915b41b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70362d6d3e9ec212d8bbfe3b33049b58"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a70362d6d3e9ec212d8bbfe3b33049b58">GetAndReplace</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a70362d6d3e9ec212d8bbfe3b33049b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaces the value for a given key if and only if there is a value currently mapped by the key.  <a href="#a70362d6d3e9ec212d8bbfe3b33049b58">More...</a><br /></td></tr>
<tr class="separator:a70362d6d3e9ec212d8bbfe3b33049b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff04aec634d377836ae597e6e1f34e9b"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aff04aec634d377836ae597e6e1f34e9b">GetAndRemove</a> (const K &amp;key)</td></tr>
<tr class="memdesc:aff04aec634d377836ae597e6e1f34e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the entry for a key only if currently mapped to some value.  <a href="#aff04aec634d377836ae597e6e1f34e9b">More...</a><br /></td></tr>
<tr class="separator:aff04aec634d377836ae597e6e1f34e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ed66837afc1e20a93faa0500522ba2"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#af3ed66837afc1e20a93faa0500522ba2">GetAndRemove</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:af3ed66837afc1e20a93faa0500522ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically removes the entry for a key only if currently mapped to some value.  <a href="#af3ed66837afc1e20a93faa0500522ba2">More...</a><br /></td></tr>
<tr class="separator:af3ed66837afc1e20a93faa0500522ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70354d0a96bb4f5174beb0f90188e24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a70354d0a96bb4f5174beb0f90188e24d">PutIfAbsent</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:a70354d0a96bb4f5174beb0f90188e24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically associates the specified key with the given value if it is not already associated with a value.  <a href="#a70354d0a96bb4f5174beb0f90188e24d">More...</a><br /></td></tr>
<tr class="separator:a70354d0a96bb4f5174beb0f90188e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ad65a7a78decf7c23c38935f27ea03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a63ad65a7a78decf7c23c38935f27ea03">PutIfAbsent</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a63ad65a7a78decf7c23c38935f27ea03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically associates the specified key with the given value if it is not already associated with a value.  <a href="#a63ad65a7a78decf7c23c38935f27ea03">More...</a><br /></td></tr>
<tr class="separator:a63ad65a7a78decf7c23c38935f27ea03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ae216436a9ea4c84f7a0b05d21af25"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a48ae216436a9ea4c84f7a0b05d21af25">GetAndPutIfAbsent</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:a48ae216436a9ea4c84f7a0b05d21af25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if cache had no previous mapping for it.  <a href="#a48ae216436a9ea4c84f7a0b05d21af25">More...</a><br /></td></tr>
<tr class="separator:a48ae216436a9ea4c84f7a0b05d21af25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b4492873790a2fe44d33b177a397e"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ab70b4492873790a2fe44d33b177a397e">GetAndPutIfAbsent</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ab70b4492873790a2fe44d33b177a397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if cache had no previous mapping for it.  <a href="#ab70b4492873790a2fe44d33b177a397e">More...</a><br /></td></tr>
<tr class="separator:ab70b4492873790a2fe44d33b177a397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf5d383274b5a54635fe28af2bdf84f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#adbf5d383274b5a54635fe28af2bdf84f">Replace</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:adbf5d383274b5a54635fe28af2bdf84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if there is a previous mapping for it.  <a href="#adbf5d383274b5a54635fe28af2bdf84f">More...</a><br /></td></tr>
<tr class="separator:adbf5d383274b5a54635fe28af2bdf84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41425d05762324590ca3d4c814cad23e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a41425d05762324590ca3d4c814cad23e">Replace</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a41425d05762324590ca3d4c814cad23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if there is a previous mapping for it.  <a href="#a41425d05762324590ca3d4c814cad23e">More...</a><br /></td></tr>
<tr class="separator:a41425d05762324590ca3d4c814cad23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be61c6ec616c6fea26ee4e18a1cfd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a33be61c6ec616c6fea26ee4e18a1cfd1">Replace</a> (const K &amp;key, const V &amp;oldVal, const V &amp;newVal)</td></tr>
<tr class="memdesc:a33be61c6ec616c6fea26ee4e18a1cfd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if only if the previous value is equal to the old value passed as argument.  <a href="#a33be61c6ec616c6fea26ee4e18a1cfd1">More...</a><br /></td></tr>
<tr class="separator:a33be61c6ec616c6fea26ee4e18a1cfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869a2263724a63d61d9739631f9b0b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#af869a2263724a63d61d9739631f9b0b4">Replace</a> (const K &amp;key, const V &amp;oldVal, const V &amp;newVal, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:af869a2263724a63d61d9739631f9b0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores given key-value pair in cache only if only if the previous value is equal to the old value passed as argument.  <a href="#af869a2263724a63d61d9739631f9b0b4">More...</a><br /></td></tr>
<tr class="separator:af869a2263724a63d61d9739631f9b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6028b210b519abdac1d921871dd483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ace6028b210b519abdac1d921871dd483">LocalEvict</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:ace6028b210b519abdac1d921871dd483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to evict all entries associated with keys.  <a href="#ace6028b210b519abdac1d921871dd483">More...</a><br /></td></tr>
<tr class="separator:ace6028b210b519abdac1d921871dd483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b8c00cf7141805cf163a3b39c6e537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a70b8c00cf7141805cf163a3b39c6e537">LocalEvict</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a70b8c00cf7141805cf163a3b39c6e537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to evict all entries associated with keys.  <a href="#a70b8c00cf7141805cf163a3b39c6e537">More...</a><br /></td></tr>
<tr class="separator:a70b8c00cf7141805cf163a3b39c6e537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf0d8032946a206346a087465b280c1"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a2cf0d8032946a206346a087465b280c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a2cf0d8032946a206346a087465b280c1">LocalEvict</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:a2cf0d8032946a206346a087465b280c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to evict all entries associated with keys.  <a href="#a2cf0d8032946a206346a087465b280c1">More...</a><br /></td></tr>
<tr class="separator:a2cf0d8032946a206346a087465b280c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dff73e2749850adff3b8604a2b11b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a32dff73e2749850adff3b8604a2b11b4">Clear</a> ()</td></tr>
<tr class="memdesc:a32dff73e2749850adff3b8604a2b11b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear cache.  <a href="#a32dff73e2749850adff3b8604a2b11b4">More...</a><br /></td></tr>
<tr class="separator:a32dff73e2749850adff3b8604a2b11b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1b88838a8bb62d95eb6a9f2b3ca734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a3c1b88838a8bb62d95eb6a9f2b3ca734">Clear</a> (<a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a3c1b88838a8bb62d95eb6a9f2b3ca734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear cache.  <a href="#a3c1b88838a8bb62d95eb6a9f2b3ca734">More...</a><br /></td></tr>
<tr class="separator:a3c1b88838a8bb62d95eb6a9f2b3ca734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70e1d43fe5ea51cac26068feee04de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ac70e1d43fe5ea51cac26068feee04de1">Clear</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ac70e1d43fe5ea51cac26068feee04de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#ac70e1d43fe5ea51cac26068feee04de1">More...</a><br /></td></tr>
<tr class="separator:ac70e1d43fe5ea51cac26068feee04de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d93b727b494c0edcb6d3820c8b2a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a111d93b727b494c0edcb6d3820c8b2a7">Clear</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a111d93b727b494c0edcb6d3820c8b2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a111d93b727b494c0edcb6d3820c8b2a7">More...</a><br /></td></tr>
<tr class="separator:a111d93b727b494c0edcb6d3820c8b2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ad2c0ff97c08272a5d2e8e5ef3426f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a75ad2c0ff97c08272a5d2e8e5ef3426f">ClearAll</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a75ad2c0ff97c08272a5d2e8e5ef3426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a75ad2c0ff97c08272a5d2e8e5ef3426f">More...</a><br /></td></tr>
<tr class="separator:a75ad2c0ff97c08272a5d2e8e5ef3426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9b9a2ddbe63804e3ae5ed08dd78d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a2b9b9a2ddbe63804e3ae5ed08dd78d0e">ClearAll</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a2b9b9a2ddbe63804e3ae5ed08dd78d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a2b9b9a2ddbe63804e3ae5ed08dd78d0e">More...</a><br /></td></tr>
<tr class="separator:a2b9b9a2ddbe63804e3ae5ed08dd78d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5547f59dee13bfa94ff3c6f633bbe3"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a0d5547f59dee13bfa94ff3c6f633bbe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a0d5547f59dee13bfa94ff3c6f633bbe3">ClearAll</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:a0d5547f59dee13bfa94ff3c6f633bbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a0d5547f59dee13bfa94ff3c6f633bbe3">More...</a><br /></td></tr>
<tr class="separator:a0d5547f59dee13bfa94ff3c6f633bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76b287cd40718a7df7d2cdd0cfd40ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#af76b287cd40718a7df7d2cdd0cfd40ef">LocalClear</a> (const K &amp;key)</td></tr>
<tr class="memdesc:af76b287cd40718a7df7d2cdd0cfd40ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#af76b287cd40718a7df7d2cdd0cfd40ef">More...</a><br /></td></tr>
<tr class="separator:af76b287cd40718a7df7d2cdd0cfd40ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479871cf2fae779ee53a73f2869870c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a479871cf2fae779ee53a73f2869870c9">LocalClear</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a479871cf2fae779ee53a73f2869870c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entry from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a479871cf2fae779ee53a73f2869870c9">More...</a><br /></td></tr>
<tr class="separator:a479871cf2fae779ee53a73f2869870c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485a96fc3ad6809637c8395ebd9a752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a6485a96fc3ad6809637c8395ebd9a752">LocalClearAll</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a6485a96fc3ad6809637c8395ebd9a752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a6485a96fc3ad6809637c8395ebd9a752">More...</a><br /></td></tr>
<tr class="separator:a6485a96fc3ad6809637c8395ebd9a752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad026122ff49517efa2f34cd3e6552d1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ad026122ff49517efa2f34cd3e6552d1e">LocalClearAll</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ad026122ff49517efa2f34cd3e6552d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#ad026122ff49517efa2f34cd3e6552d1e">More...</a><br /></td></tr>
<tr class="separator:ad026122ff49517efa2f34cd3e6552d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0f770f3d807ac3574043f45445fce2"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a7d0f770f3d807ac3574043f45445fce2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a7d0f770f3d807ac3574043f45445fce2">LocalClearAll</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:a7d0f770f3d807ac3574043f45445fce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear entries from the cache and swap storage, without notifying listeners or CacheWriters.  <a href="#a7d0f770f3d807ac3574043f45445fce2">More...</a><br /></td></tr>
<tr class="separator:a7d0f770f3d807ac3574043f45445fce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afe0c34aa31c4ed34132ba0d9023dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a7afe0c34aa31c4ed34132ba0d9023dce">Remove</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a7afe0c34aa31c4ed34132ba0d9023dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache.  <a href="#a7afe0c34aa31c4ed34132ba0d9023dce">More...</a><br /></td></tr>
<tr class="separator:a7afe0c34aa31c4ed34132ba0d9023dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1cd72a8461a74705147362630a5468"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a7c1cd72a8461a74705147362630a5468">Remove</a> (const K &amp;key, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a7c1cd72a8461a74705147362630a5468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache.  <a href="#a7c1cd72a8461a74705147362630a5468">More...</a><br /></td></tr>
<tr class="separator:a7c1cd72a8461a74705147362630a5468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa6f4df34659d8c74dd4ff74e4b113f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a4aa6f4df34659d8c74dd4ff74e4b113f">Remove</a> (const K &amp;key, const V &amp;val)</td></tr>
<tr class="memdesc:a4aa6f4df34659d8c74dd4ff74e4b113f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache if one exists and value is equal to the passed in value.  <a href="#a4aa6f4df34659d8c74dd4ff74e4b113f">More...</a><br /></td></tr>
<tr class="separator:a4aa6f4df34659d8c74dd4ff74e4b113f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abed26f01885d904a601fd3fa7cb64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a3abed26f01885d904a601fd3fa7cb64f">Remove</a> (const K &amp;key, const V &amp;val, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a3abed26f01885d904a601fd3fa7cb64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mapping from cache if one exists and value is equal to the passed in value.  <a href="#a3abed26f01885d904a601fd3fa7cb64f">More...</a><br /></td></tr>
<tr class="separator:a3abed26f01885d904a601fd3fa7cb64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3a3babb2f45897b2acf23bb5e22cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a9a3a3babb2f45897b2acf23bb5e22cb8">RemoveAll</a> (const std::set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a9a3a3babb2f45897b2acf23bb5e22cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="#a9a3a3babb2f45897b2acf23bb5e22cb8">More...</a><br /></td></tr>
<tr class="separator:a9a3a3babb2f45897b2acf23bb5e22cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3f15ffb50519f230fad7122fea6c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a4f3f15ffb50519f230fad7122fea6c82">RemoveAll</a> (const std::set&lt; K &gt; &amp;keys, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a4f3f15ffb50519f230fad7122fea6c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="#a4f3f15ffb50519f230fad7122fea6c82">More...</a><br /></td></tr>
<tr class="separator:a4f3f15ffb50519f230fad7122fea6c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0f4e52fcb03dcb1d86529da29f6a29"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a3e0f4e52fcb03dcb1d86529da29f6a29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a3e0f4e52fcb03dcb1d86529da29f6a29">RemoveAll</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:a3e0f4e52fcb03dcb1d86529da29f6a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes given key mappings from cache.  <a href="#a3e0f4e52fcb03dcb1d86529da29f6a29">More...</a><br /></td></tr>
<tr class="separator:a3e0f4e52fcb03dcb1d86529da29f6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc61c53d3c3b0fcd138674e8ffa3f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#afcc61c53d3c3b0fcd138674e8ffa3f2c">RemoveAll</a> ()</td></tr>
<tr class="memdesc:afcc61c53d3c3b0fcd138674e8ffa3f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all mappings from cache.  <a href="#afcc61c53d3c3b0fcd138674e8ffa3f2c">More...</a><br /></td></tr>
<tr class="separator:afcc61c53d3c3b0fcd138674e8ffa3f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab597e0d2f3ac758a76a785099b772776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ab597e0d2f3ac758a76a785099b772776">RemoveAll</a> (<a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ab597e0d2f3ac758a76a785099b772776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all mappings from cache.  <a href="#ab597e0d2f3ac758a76a785099b772776">More...</a><br /></td></tr>
<tr class="separator:ab597e0d2f3ac758a76a785099b772776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4fca8717947a1935d089cc63393de4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#add4fca8717947a1935d089cc63393de4">LocalSize</a> ()</td></tr>
<tr class="memdesc:add4fca8717947a1935d089cc63393de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached on this node.  <a href="#add4fca8717947a1935d089cc63393de4">More...</a><br /></td></tr>
<tr class="separator:add4fca8717947a1935d089cc63393de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb18b3985531d3410e1e3daafb322001"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#abb18b3985531d3410e1e3daafb322001">LocalSize</a> (<a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:abb18b3985531d3410e1e3daafb322001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached on this node.  <a href="#abb18b3985531d3410e1e3daafb322001">More...</a><br /></td></tr>
<tr class="separator:abb18b3985531d3410e1e3daafb322001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9ba547e9b5a427a1e03234ff41dc5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aafe9ba547e9b5a427a1e03234ff41dc5">LocalSize</a> (int32_t peekModes)</td></tr>
<tr class="memdesc:aafe9ba547e9b5a427a1e03234ff41dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached on this node.  <a href="#aafe9ba547e9b5a427a1e03234ff41dc5">More...</a><br /></td></tr>
<tr class="separator:aafe9ba547e9b5a427a1e03234ff41dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3113831235e6ac280961f0b673a726d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ad3113831235e6ac280961f0b673a726d">LocalSize</a> (int32_t peekModes, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:ad3113831235e6ac280961f0b673a726d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached on this node.  <a href="#ad3113831235e6ac280961f0b673a726d">More...</a><br /></td></tr>
<tr class="separator:ad3113831235e6ac280961f0b673a726d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03574797da901a76180aad88476ef8ce"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a03574797da901a76180aad88476ef8ce">Size</a> ()</td></tr>
<tr class="memdesc:a03574797da901a76180aad88476ef8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="#a03574797da901a76180aad88476ef8ce">More...</a><br /></td></tr>
<tr class="separator:a03574797da901a76180aad88476ef8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceeba2bacfa25940980144204457857"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aeceeba2bacfa25940980144204457857">Size</a> (<a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:aeceeba2bacfa25940980144204457857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="#aeceeba2bacfa25940980144204457857">More...</a><br /></td></tr>
<tr class="separator:aeceeba2bacfa25940980144204457857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a4bc2ff23bb72bd6338d3003c8d9f7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ae2a4bc2ff23bb72bd6338d3003c8d9f7">Size</a> (int32_t peekModes)</td></tr>
<tr class="memdesc:ae2a4bc2ff23bb72bd6338d3003c8d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="#ae2a4bc2ff23bb72bd6338d3003c8d9f7">More...</a><br /></td></tr>
<tr class="separator:ae2a4bc2ff23bb72bd6338d3003c8d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e93893fa8836baad3d10d3174fe13"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a601e93893fa8836baad3d10d3174fe13">Size</a> (int32_t peekModes, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a601e93893fa8836baad3d10d3174fe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of all entries cached across all nodes.  <a href="#a601e93893fa8836baad3d10d3174fe13">More...</a><br /></td></tr>
<tr class="separator:a601e93893fa8836baad3d10d3174fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26119f98c463ef80945e26efc6e83a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a26119f98c463ef80945e26efc6e83a89">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlQuery.html">query::SqlQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:a26119f98c463ef80945e26efc6e83a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SQL query.  <a href="#a26119f98c463ef80945e26efc6e83a89">More...</a><br /></td></tr>
<tr class="separator:a26119f98c463ef80945e26efc6e83a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556b6842f84e7f280b0c595c1a0007f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a556b6842f84e7f280b0c595c1a0007f0">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlQuery.html">query::SqlQuery</a> &amp;qry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a556b6842f84e7f280b0c595c1a0007f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform SQL query.  <a href="#a556b6842f84e7f280b0c595c1a0007f0">More...</a><br /></td></tr>
<tr class="separator:a556b6842f84e7f280b0c595c1a0007f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e778ca7800bc44e458aadcfd44c871d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a2e778ca7800bc44e458aadcfd44c871d">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1TextQuery.html">query::TextQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:a2e778ca7800bc44e458aadcfd44c871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform text query.  <a href="#a2e778ca7800bc44e458aadcfd44c871d">More...</a><br /></td></tr>
<tr class="separator:a2e778ca7800bc44e458aadcfd44c871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44d92bcc1d6c8b0e82351f84b6176d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#af44d92bcc1d6c8b0e82351f84b6176d5">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1TextQuery.html">query::TextQuery</a> &amp;qry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:af44d92bcc1d6c8b0e82351f84b6176d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform text query.  <a href="#af44d92bcc1d6c8b0e82351f84b6176d5">More...</a><br /></td></tr>
<tr class="separator:af44d92bcc1d6c8b0e82351f84b6176d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314862911a062fbb7584ebc40db138f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a314862911a062fbb7584ebc40db138f7">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:a314862911a062fbb7584ebc40db138f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform scan query.  <a href="#a314862911a062fbb7584ebc40db138f7">More...</a><br /></td></tr>
<tr class="separator:a314862911a062fbb7584ebc40db138f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c61d79d3faef75affbe34d1349e4b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a3c61d79d3faef75affbe34d1349e4b01">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;qry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a3c61d79d3faef75affbe34d1349e4b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform scan query.  <a href="#a3c61d79d3faef75affbe34d1349e4b01">More...</a><br /></td></tr>
<tr class="separator:a3c61d79d3faef75affbe34d1349e4b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03e67d01500b9fef49608e80f6e5f6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ab03e67d01500b9fef49608e80f6e5f6e">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;qry)</td></tr>
<tr class="memdesc:ab03e67d01500b9fef49608e80f6e5f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sql fields query.  <a href="#ab03e67d01500b9fef49608e80f6e5f6e">More...</a><br /></td></tr>
<tr class="separator:ab03e67d01500b9fef49608e80f6e5f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e814db47b3f864eb2f23eb2f9e15a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a3e814db47b3f864eb2f23eb2f9e15a47">Query</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;qry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a3e814db47b3f864eb2f23eb2f9e15a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sql fields query.  <a href="#a3e814db47b3f864eb2f23eb2f9e15a47">More...</a><br /></td></tr>
<tr class="separator:a3e814db47b3f864eb2f23eb2f9e15a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d816384f6ecc3f6f5b0b298e08a338"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P , typename A &gt; </td></tr>
<tr class="memitem:ad3d816384f6ecc3f6f5b0b298e08a338"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ad3d816384f6ecc3f6f5b0b298e08a338">Invoke</a> (const K &amp;key, const P &amp;processor, const A &amp;arg)</td></tr>
<tr class="memdesc:ad3d816384f6ecc3f6f5b0b298e08a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes an <a class="el" href="classignite_1_1cache_1_1CacheEntryProcessor.html" title="Cache entry processor class template. ">CacheEntryProcessor</a> against the <a class="el" href="classignite_1_1cache_1_1MutableCacheEntry.html" title="Mutable representation of CacheEntry class template. ">MutableCacheEntry</a> specified by the provided key.  <a href="#ad3d816384f6ecc3f6f5b0b298e08a338">More...</a><br /></td></tr>
<tr class="separator:ad3d816384f6ecc3f6f5b0b298e08a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646c6a21a8c17aabf2ad936ae4a7ec0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P , typename A &gt; </td></tr>
<tr class="memitem:a6646c6a21a8c17aabf2ad936ae4a7ec0"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a6646c6a21a8c17aabf2ad936ae4a7ec0">Invoke</a> (const K &amp;key, const P &amp;processor, const A &amp;arg, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a6646c6a21a8c17aabf2ad936ae4a7ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes an <a class="el" href="classignite_1_1cache_1_1CacheEntryProcessor.html" title="Cache entry processor class template. ">CacheEntryProcessor</a> against the <a class="el" href="classignite_1_1cache_1_1MutableCacheEntry.html" title="Mutable representation of CacheEntry class template. ">MutableCacheEntry</a> specified by the provided key.  <a href="#a6646c6a21a8c17aabf2ad936ae4a7ec0">More...</a><br /></td></tr>
<tr class="separator:a6646c6a21a8c17aabf2ad936ae4a7ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa593e6059eaad9122a1ea2c7d55386cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#aa593e6059eaad9122a1ea2c7d55386cb">QueryContinuous</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;qry)</td></tr>
<tr class="memdesc:aa593e6059eaad9122a1ea2c7d55386cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start continuous query execution.  <a href="#aa593e6059eaad9122a1ea2c7d55386cb">More...</a><br /></td></tr>
<tr class="separator:aa593e6059eaad9122a1ea2c7d55386cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbb8679a5b106fab9d4402e56e2ffdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt; K, V &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a7fbb8679a5b106fab9d4402e56e2ffdd">QueryContinuous</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;qry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:a7fbb8679a5b106fab9d4402e56e2ffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start continuous query execution.  <a href="#a7fbb8679a5b106fab9d4402e56e2ffdd">More...</a><br /></td></tr>
<tr class="separator:a7fbb8679a5b106fab9d4402e56e2ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a499c5a62d5272edd495079bec95f"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a536a499c5a62d5272edd495079bec95f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a536a499c5a62d5272edd495079bec95f">QueryContinuous</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;qry, const Q &amp;initialQry)</td></tr>
<tr class="memdesc:a536a499c5a62d5272edd495079bec95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start continuous query execution with the initial query.  <a href="#a536a499c5a62d5272edd495079bec95f">More...</a><br /></td></tr>
<tr class="separator:a536a499c5a62d5272edd495079bec95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba6a82f00990d4e753dbdeeddf0de83"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:afba6a82f00990d4e753dbdeeddf0de83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#afba6a82f00990d4e753dbdeeddf0de83">QueryContinuous</a> (const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;qry, const Q &amp;initialQry, <a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;err)</td></tr>
<tr class="memdesc:afba6a82f00990d4e753dbdeeddf0de83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start continuous query execution with the initial query.  <a href="#afba6a82f00990d4e753dbdeeddf0de83">More...</a><br /></td></tr>
<tr class="separator:afba6a82f00990d4e753dbdeeddf0de83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363578f939ce910975bb84f58e91904a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a363578f939ce910975bb84f58e91904a">IsValid</a> () const </td></tr>
<tr class="memdesc:a363578f939ce910975bb84f58e91904a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the instance is valid.  <a href="#a363578f939ce910975bb84f58e91904a">More...</a><br /></td></tr>
<tr class="separator:a363578f939ce910975bb84f58e91904a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c9608d3044bd944e1c348e77426bc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c9608d3044bd944e1c348e77426bc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#a70c9608d3044bd944e1c348e77426bc6">LoadCache</a> ()</td></tr>
<tr class="memdesc:a70c9608d3044bd944e1c348e77426bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes LocalLoadCache on all cache nodes. <br /></td></tr>
<tr class="separator:a70c9608d3044bd944e1c348e77426bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5021acbd56235ca7aeda93d409b360e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignite_1_1cache_1_1Cache.html#ab5021acbd56235ca7aeda93d409b360e">LocalLoadCache</a> ()</td></tr>
<tr class="memdesc:ab5021acbd56235ca7aeda93d409b360e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads state from the underlying persistent storage.  <a href="#ab5021acbd56235ca7aeda93d409b360e">More...</a><br /></td></tr>
<tr class="separator:ab5021acbd56235ca7aeda93d409b360e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename K, typename V&gt;<br />
class ignite::cache::Cache&lt; K, V &gt;</h3>

<p>Main entry point for all Data Grid APIs. </p>
<p>Both key and value types should be default-constructable, copy-constructable and assignable. Also BinaryType class template should be specialized for both types.</p>
<p>This class implemented as a reference to an implementation so copying of this class instance will only create another reference to the same underlying object. Underlying object released automatically once all the instances are destructed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> key type. </td></tr>
    <tr><td class="paramname">V</td><td><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> value type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad5028ce3aa42ed7f8c3e4304e7b5653b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::<a class="el" href="classignite_1_1cache_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">impl::cache::CacheImpl *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Internal method. Should not be used by user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>Implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a32dff73e2749850adff3b8604a2b11b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear cache. </p>
<p>This method should only be used on the valid instance. </p>

</div>
</div>
<a class="anchor" id="a3c1b88838a8bb62d95eb6a9f2b3ca734"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear cache. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac70e1d43fe5ea51cac26068feee04de1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a111d93b727b494c0edcb6d3820c8b2a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75ad2c0ff97c08272a5d2e8e5ef3426f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b9b9a2ddbe63804e3ae5ed08dd78d0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d5547f59dee13bfa94ff3c6f633bbe3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ClearAll </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50dc8bbe041c277eb2c8f546cd343167"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for this key. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for this key. </dd></dl>

</div>
</div>
<a class="anchor" id="afab73114323001dbb7edebbcf011be0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for this key. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for this key. </dd></dl>

</div>
</div>
<a class="anchor" id="a2059398f1e0dcb39daf0f437a99fb9be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a class="anchor" id="a089a84634bfe5ddf0f4db0c31f7a6a26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cdca32b50dba8b000e6dcb3ed6f893a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::ContainsKeys </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cache contains mapping for these keys. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache contains mapping for all these keys. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ca8ec1f2d66762816de72b57c5cbdb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves value mapped to the specified key from cache. </p>
<p>If the value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a class="anchor" id="a54bf114b9d8b45f2588659b217ffd9d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves value mapped to the specified key from cache. </p>
<p>If the value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a class="anchor" id="aba088938308bb2a01233a55cfd8ef546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of key-value pairs. </dd></dl>

</div>
</div>
<a class="anchor" id="ac341a3ac21b498e0a393851b1a0844c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map of key-value pairs. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e96ce4a9292d05c1937383fb576a936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename InIter , typename OutIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAll </td>
          <td>(</td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIter&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves values mapped to the specified keys from cache. </p>
<p>If some value is not present in cache, then it will be looked up from swap storage. If it's not present in swap, or if swap is disabled, and if read-through is allowed, value will be loaded from persistent store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
    <tr><td class="paramname">dst</td><td>Output iterator. Should dereference to std::pair or <a class="el" href="classignite_1_1cache_1_1CacheEntry.html" title="Cache entry class template. ">CacheEntry</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7b537114aa4c59439d56c1ce33f707c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndPut </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in this cache, returning an existing value if one existed. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key at the start of the operation or null if none was associated. </dd></dl>

</div>
</div>
<a class="anchor" id="acc4c1512f82c0dee61e39834edc2aae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndPut </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in this cache, returning an existing value if one existed. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key at the start of the operation or null if none was associated. </dd></dl>

</div>
</div>
<a class="anchor" id="a48ae216436a9ea4c84f7a0b05d21af25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndPutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if cache had no previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method putxIfAbsent() should be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the stored value will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previously contained value regardless of whether put happened or not (null if there was no previous value). </dd></dl>

</div>
</div>
<a class="anchor" id="ab70b4492873790a2fe44d33b177a397e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndPutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if cache had no previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method putxIfAbsent() should be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the stored value will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the given key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previously contained value regardless of whether put happened or not (null if there was no previous value). </dd></dl>

</div>
</div>
<a class="anchor" id="aff04aec634d377836ae597e6e1f34e9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndRemove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically removes the entry for a key only if currently mapped to some value. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is associated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if one existed or null if no mapping existed for this key. </dd></dl>

</div>
</div>
<a class="anchor" id="af3ed66837afc1e20a93faa0500522ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndRemove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically removes the entry for a key only if currently mapped to some value. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is associated. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if one existed or null if no mapping existed for this key. </dd></dl>

</div>
</div>
<a class="anchor" id="a248126e1b19e58616e0b82915b41b71b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndReplace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically replaces the value for a given key if and only if there is a value currently mapped by the key. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value associated with the specified key, or null if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a70362d6d3e9ec212d8bbfe3b33049b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetAndReplace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically replaces the value for a given key if and only if there is a value currently mapped by the key. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value associated with the specified key, or null if there was no mapping for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a1edd752b6d7b94c716504c91d3f4553b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of this cache (null for default cache). </p>
<p>This method should only be used on the valid instance.</p>
<dl class="section return"><dt>Returns</dt><dd>Name of this cache (null for default cache). </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d816384f6ecc3f6f5b0b298e08a338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename R , typename P , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Invoke </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes an <a class="el" href="classignite_1_1cache_1_1CacheEntryProcessor.html" title="Cache entry processor class template. ">CacheEntryProcessor</a> against the <a class="el" href="classignite_1_1cache_1_1MutableCacheEntry.html" title="Mutable representation of CacheEntry class template. ">MutableCacheEntry</a> specified by the provided key. </p>
<p>If an entry does not exist for the specified key, an attempt is made to load it (if a loader is configured) or a surrogate entry, consisting of the key with a null value is used instead.</p>
<p>Return value, processor and argument classes should all be default-constructable, copy-constructable and assignable. Also, BinaryType class template should be specialized for every custom class.</p>
<p>Processor class should be registered as a cache entry processor using <a class="el" href="classignite_1_1IgniteBinding.html#ae1deb2ba19e1b0e15b8a8f2779daf134" title="Register type as Cache Entry Processor. ">IgniteBinding::RegisterCacheEntryProcessor()</a> method. You can declare #IgniteModuleInit() function to register your cache processors upon module loading. There should be at most one instance of such function per module.</p>
<p>See the example below for details: </p><div class="fragment"><div class="line">IGNITE_EXPORTED_CALL <span class="keywordtype">void</span> IgniteModuleInit(<a class="code" href="classignite_1_1IgniteBindingContext.html">ignite::IgniteBindingContext</a>&amp; context)</div><div class="line">{</div><div class="line">    IgniteBinding binding = context.<a class="code" href="classignite_1_1IgniteBindingContext.html#a87478e3181e0bbae480fce722211c929">GetBinding</a>();</div><div class="line"></div><div class="line">    binding.<a class="code" href="classignite_1_1IgniteBinding.html#ae1deb2ba19e1b0e15b8a8f2779daf134">RegisterCacheEntryProcessor</a>&lt;MyProcessor1&gt;();</div><div class="line">    binding.RegisterCacheEntryProcessor&lt;MyProcessor2&gt;();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    binding.RegisterCacheEntryProcessor&lt;MyProcessorN&gt;();</div><div class="line">}</div></div><!-- fragment --><p>Additionally, processor class should be derived from the ignite::CacheEntryProcessor class.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classignite_1_1IgniteError.html" title="Ignite error information. ">IgniteError</a></td><td>on fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramname">processor</td><td>The processor. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the processing. </dd></dl>

</div>
</div>
<a class="anchor" id="a6646c6a21a8c17aabf2ad936ae4a7ec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename R , typename P , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Invoke </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes an <a class="el" href="classignite_1_1cache_1_1CacheEntryProcessor.html" title="Cache entry processor class template. ">CacheEntryProcessor</a> against the <a class="el" href="classignite_1_1cache_1_1MutableCacheEntry.html" title="Mutable representation of CacheEntry class template. ">MutableCacheEntry</a> specified by the provided key. </p>
<p>If an entry does not exist for the specified key, an attempt is made to load it (if a loader is configured) or a surrogate entry, consisting of the key with a null value is used instead.</p>
<p>Return value, processor and argument classes should all be default-constructable, copy-constructable and assignable. Also, BinaryType class template should be specialized for every custom class.</p>
<p>Processor class should be registered as a cache entry processor using <a class="el" href="classignite_1_1IgniteBinding.html#ae1deb2ba19e1b0e15b8a8f2779daf134" title="Register type as Cache Entry Processor. ">IgniteBinding::RegisterCacheEntryProcessor()</a> method. You can declare #IgniteModuleInit() function to register your cache processors upon module loading. There should be at most one instance of such function per module.</p>
<p>See the example below for details: </p><div class="fragment"><div class="line">IGNITE_EXPORTED_CALL <span class="keywordtype">void</span> IgniteModuleInit(<a class="code" href="classignite_1_1IgniteBindingContext.html">ignite::IgniteBindingContext</a>&amp; context)</div><div class="line">{</div><div class="line">    IgniteBinding binding = context.<a class="code" href="classignite_1_1IgniteBindingContext.html#a87478e3181e0bbae480fce722211c929">GetBinding</a>();</div><div class="line"></div><div class="line">    binding.<a class="code" href="classignite_1_1IgniteBinding.html#ae1deb2ba19e1b0e15b8a8f2779daf134">RegisterCacheEntryProcessor</a>&lt;MyProcessor1&gt;();</div><div class="line">    binding.RegisterCacheEntryProcessor&lt;MyProcessor2&gt;();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    binding.RegisterCacheEntryProcessor&lt;MyProcessorN&gt;();</div><div class="line">}</div></div><!-- fragment --><p>Additionally, processor class should be derived from the ignite::CacheEntryProcessor class.</p>
<p>Sets err param which should be checked for the operation result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key. </td></tr>
    <tr><td class="paramname">processor</td><td>The processor. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the processing. Default-constructed value on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a60db60b4b35fbaf00e542c76b1927707"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this cache contains no key-value mappings. </p>
<p>Semantically equals to Cache.Size(CachePeekMode::PRIMARY) == 0.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="section return"><dt>Returns</dt><dd>True if cache is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aac2e29657a3ad0f8be0c82db1d6dd78f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this cache contains no key-value mappings. </p>
<p>Semantically equals to Cache.Size(CachePeekMode::PRIMARY) == 0.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cache is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a363578f939ce910975bb84f58e91904a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the instance is valid. </p>
<p>Invalid instance can be returned if some of the previous operations have resulted in a failure. For example invalid instance can be returned by not-throwing version of method in case of error. Invalid instances also often can be created using default constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the instance is valid and can be used. </dd></dl>

</div>
</div>
<a class="anchor" id="af76b287cd40718a7df7d2cdd0cfd40ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalClear </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is local as it merely clears an entry from local cache, it does not remove entries from remote caches.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a479871cf2fae779ee53a73f2869870c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalClear </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entry from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is local as it merely clears an entry from local cache, it does not remove entries from remote caches.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to clear. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6485a96fc3ad6809637c8395ebd9a752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalClearAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is local as it merely clears entries from local cache, it does not remove entries from remote caches.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad026122ff49517efa2f34cd3e6552d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalClearAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is local as it merely clears entries from local cache, it does not remove entries from remote caches.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to clear. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d0f770f3d807ac3574043f45445fce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalClearAll </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear entries from the cache and swap storage, without notifying listeners or CacheWriters. </p>
<p>Entry is cleared only if it is not currently locked, and is not participating in a transaction.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is local as it merely clears entries from local cache, it does not remove entries from remote caches.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace6028b210b519abdac1d921871dd483"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalEvict </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to evict all entries associated with keys. </p>
<dl class="section note"><dt>Note</dt><dd>Entry will be evicted only if it's not used (not participating in any locks or transactions).</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to evict from cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70b8c00cf7141805cf163a3b39c6e537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalEvict </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to evict all entries associated with keys. </p>
<dl class="section note"><dt>Note</dt><dd>Entry will be evicted only if it's not used (not participating in any locks or transactions).</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys to evict from cache. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cf0d8032946a206346a087465b280c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalEvict </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to evict all entries associated with keys. </p>
<dl class="section note"><dt>Note</dt><dd>Entry will be evicted only if it's not used (not participating in any locks or transactions).</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5021acbd56235ca7aeda93d409b360e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalLoadCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads state from the underlying persistent storage. </p>
<p>This method is not transactional and may end up loading a stale value into cache if another thread has updated the value immediately after it has been loaded. It is mostly useful when pre-loading the cache from underlying data store before start, or for read-only caches. </p>

</div>
</div>
<a class="anchor" id="a02ad1e06c09574e7008b417a27eba5f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalPeek </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at cached value using optional set of peek modes. </p>
<p>This method will sequentially iterate over given peek modes, and try to peek at value using each peek mode. Once a non-null value is found, it will be immediately returned. This method does not participate in any transactions, however, it may peek at transactional value depending on the peek modes used.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a class="anchor" id="a16ea86d2b3f19ffd7c024eeb03cb2124"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalPeek </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peeks at cached value using optional set of peek modes. </p>
<p>This method will sequentially iterate over given peek modes, and try to peek at value using each peek mode. Once a non-null value is found, it will be immediately returned. This method does not participate in any transactions, however, it may peek at transactional value depending on the peek modes used.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key. </td></tr>
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value. </dd></dl>

</div>
</div>
<a class="anchor" id="add4fca8717947a1935d089cc63393de4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached on this node. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size on this node. </dd></dl>

</div>
</div>
<a class="anchor" id="abb18b3985531d3410e1e3daafb322001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached on this node. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size on this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aafe9ba547e9b5a427a1e03234ff41dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached on this node. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size on this node. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3113831235e6ac280961f0b673a726d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::LocalSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached on this node. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size on this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a236ef50fa610c713e5284cefa4a325a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in the cache. </p>
<p>If the cache previously contained a mapping for the key, the old value is replaced by the specified value.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31bbcdeb410146e389f751c8ec94bf95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the specified value with the specified key in the cache. </p>
<p>If the cache previously contained a mapping for the key, the old value is replaced by the specified value.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26753649804a932daee2e3e43c4df74c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>Key-value pairs to store in cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac84472f375ba3fcc1a4af80756dfd6ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>Key-value pairs to store in cache. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abef0fa0e9ab2c0d6194149f9084dd2af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::PutAll </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pairs in cache. </p>
<p>If write-through is enabled, the stored values will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key-value pair sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key-value pair sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70354d0a96bb4f5174beb0f90188e24d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::PutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically associates the specified key with the given value if it is not already associated with a value. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a value was set. </dd></dl>

</div>
</div>
<a class="anchor" id="a63ad65a7a78decf7c23c38935f27ea03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::PutIfAbsent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically associates the specified key with the given value if it is not already associated with a value. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a value was set. </dd></dl>

</div>
</div>
<a class="anchor" id="a26119f98c463ef80945e26efc6e83a89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlQuery.html">query::SqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SQL query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="a556b6842f84e7f280b0c595c1a0007f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlQuery.html">query::SqlQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform SQL query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e778ca7800bc44e458aadcfd44c871d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1TextQuery.html">query::TextQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform text query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="af44d92bcc1d6c8b0e82351f84b6176d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1TextQuery.html">query::TextQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform text query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="a314862911a062fbb7584ebc40db138f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform scan query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c61d79d3faef75affbe34d1349e4b01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryCursor.html">query::QueryCursor</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1ScanQuery.html">query::ScanQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform scan query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="ab03e67d01500b9fef49608e80f6e5f6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a> <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sql fields query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e814db47b3f864eb2f23eb2f9e15a47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1QueryFieldsCursor.html">query::QueryFieldsCursor</a> <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1SqlFieldsQuery.html">query::SqlFieldsQuery</a> &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform sql fields query. </p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Query. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Query cursor. </dd></dl>

</div>
</div>
<a class="anchor" id="aa593e6059eaad9122a1ea2c7d55386cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::QueryContinuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>qry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start continuous query execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Continuous query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Continuous query handle. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fbb8679a5b106fab9d4402e56e2ffdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::QueryContinuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start continuous query execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Continuous query. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Continuous query handle. </dd></dl>

</div>
</div>
<a class="anchor" id="a536a499c5a62d5272edd495079bec95f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::QueryContinuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>initialQry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start continuous query execution with the initial query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Continuous query. </td></tr>
    <tr><td class="paramname">initialQry</td><td>Initial query to be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Continuous query handle. </dd></dl>

</div>
</div>
<a class="anchor" id="afba6a82f00990d4e753dbdeeddf0de83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQueryHandle.html">query::continuous::ContinuousQueryHandle</a>&lt;K, V&gt; <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::QueryContinuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classignite_1_1cache_1_1query_1_1continuous_1_1ContinuousQuery.html">query::continuous::ContinuousQuery</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>qry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>initialQry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start continuous query execution with the initial query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qry</td><td>Continuous query. </td></tr>
    <tr><td class="paramname">initialQry</td><td>Initial query to be executed. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Continuous query handle. </dd></dl>

</div>
</div>
<a class="anchor" id="a7afe0c34aa31c4ed34132ba0d9023dce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the disk-based swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method removex() should always be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if there was no matching key. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1cd72a8461a74705147362630a5468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the disk-based swap storage, and consecutively, if it's not in swap, from the underlying persistent storage. If the returned value is not needed, method removex() should always be used instead of this one to avoid the overhead associated with returning of the previous value. If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if there was no matching key. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aa6f4df34659d8c74dd4ff74e4b113f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache if one exists and value is equal to the passed in value. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to match against currently cached value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entry was removed, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3abed26f01885d904a601fd3fa7cb64f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mapping from cache if one exists and value is equal to the passed in value. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose mapping is to be removed from cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to match against currently cached value. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if entry was removed, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3a3babb2f45897b2acf23bb5e22cb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys whose mappings are to be removed from cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f3f15ffb50519f230fad7122fea6c82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>Keys whose mappings are to be removed from cache. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e0f4e52fcb03dcb1d86529da29f6a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes given key mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator pointing to the beggining of the key sequence. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator pointing to the end of the key sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcc61c53d3c3b0fcd138674e8ffa3f2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance. </p>

</div>
</div>
<a class="anchor" id="ab597e0d2f3ac758a76a785099b772776"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::RemoveAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all mappings from cache. </p>
<p>If write-through is enabled, the value will be removed from store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbf5d383274b5a54635fe28af2bdf84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if there is a previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, rom the underlying persistent storage. If write-through is enabled, the stored value will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value was replaced. </dd></dl>

</div>
</div>
<a class="anchor" id="a41425d05762324590ca3d4c814cad23e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if there is a previous mapping for it. </p>
<p>If cache previously contained value for the given key, then this value is returned. In case of PARTITIONED or REPLICATED caches, the value will be loaded from the primary node, which in its turn may load the value from the swap storage, and consecutively, if it's not in swap, rom the underlying persistent storage. If write-through is enabled, the stored value will be persisted to store. This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">val</td><td>Value to be associated with the given key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the value was replaced. </dd></dl>

</div>
</div>
<a class="anchor" id="a33be61c6ec616c6fea26ee4e18a1cfd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>newVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if only if the previous value is equal to the old value passed as argument. </p>
<p>This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">oldVal</td><td>Old value to match. </td></tr>
    <tr><td class="paramname">newVal</td><td>Value to be associated with the given key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if replace happened, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af869a2263724a63d61d9739631f9b0b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>oldVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>newVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores given key-value pair in cache only if only if the previous value is equal to the old value passed as argument. </p>
<p>This method is transactional and will enlist the entry into ongoing transaction if there is one.</p>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to store in cache. </td></tr>
    <tr><td class="paramname">oldVal</td><td>Old value to match. </td></tr>
    <tr><td class="paramname">newVal</td><td>Value to be associated with the given key. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if replace happened, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a03574797da901a76180aad88476ef8ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>this operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size across all nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="aeceeba2bacfa25940980144204457857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>This operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size across all nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a4bc2ff23bb72bd6338d3003c8d9f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>This operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size across all nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a601e93893fa8836baad3d10d3174fe13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classignite_1_1cache_1_1Cache.html">ignite::cache::Cache</a>&lt; K, V &gt;::Size </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>peekModes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classignite_1_1IgniteError.html">IgniteError</a> &amp;&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of all entries cached across all nodes. </p>
<dl class="section note"><dt>Note</dt><dd>This operation is distributed and will query all participating nodes for their cache sizes.</dd></dl>
<p>This method should only be used on the valid instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peekModes</td><td>Peek modes. </td></tr>
    <tr><td class="paramname">err</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classignite_1_1cache_1_1Cache.html" title="Main entry point for all Data Grid APIs. ">Cache</a> size across all nodes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cache_8h_source.html">cache.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 23 2018 17:47:00 for &nbsp; Apache Ignite C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
