---
title: "Getting to Know Apache Ignite 3: A Schema-Driven Distributed Computing Platform"
author: "Michael Aglietti"
date: 2025-11-11
tags:
    - apache
    - ignite
---

p Apache Ignite 3 is a memory-first distributed SQL database platform that consolidates transactions, analytics, and compute workloads previously requiring separate systems. Built from the ground up, it represents a complete departure from traditional caching solutions toward a unified distributed computing platform with microsecond latencies and collocated processing capabilities.

<!-- end -->

p
  strong Forget everything you knew about Apache Ignite.
  |  Version 3.0 is a complete architectural rewrite that transforms Ignite from a caching platform into a memory-first distributed computing platform with microsecond latencies and collocated processing.

h3 Architectural Foundation: Schema-Driven Design

p The core architectural shift in Ignite 3 is that your schema becomes the foundation for data placement, query optimization, and compute job scheduling. Instead of managing separate systems with different data models, you define your schema once and it drives everything.

pre
  code.
    // Unified platform connection
    IgniteClient ignite = IgniteClient.builder()
        .addresses("node1:10800", "node2:10800", "node3:10800")
        .build();

p
  strong Schema Creation:
    |  Ignite 3 supports three approaches for schema creation:
ul
  li
    strong SQL DDL
    |  - Traditional 
    code CREATE TABLE
    |  statements
  li
    strong Java Annotations API
    |  - POJO markup with 
    code @Table
    | , 
    code @Column
    | , etc.
  li
    strong Java Builder API
    |  - Programmatic 
    code TableDefinition.builder()
    |  approach

p We use the Java Annotations API in this blog for their compile-time type safety and clear colocation syntax.

pre
  code.
    @Table(zone = @Zone(value = "MusicStore", storageProfiles = "default"))
    public class Artist {
        @Id
        private Integer ArtistId;

        @Column(value = "Name", length = 120, nullable = false)
        private String Name;

        // Constructors, getters, setters...
    }

    @Table(
        zone = @Zone(value = "MusicStore", storageProfiles = "default"),
        colocateBy = @ColumnRef("ArtistId"),
        indexes = @Index(value = "IFK_AlbumArtistId", columns = { 
            @ColumnRef("ArtistId") })
    )
    public class Album {
        @Id
        private Integer AlbumId;

        @Id
        private Integer ArtistId;

        @Column(value = "Title", length = 160, nullable = false)
        private String Title;

        // Constructors, getters, setters...
    }

p The 
  code colocateBy
  |  annotation ensures that albums are stored on the same nodes as their corresponding artists, eliminating distributed join overhead and enabling local processing.

h3 Multiple APIs, Single Schema

p Ignite 3 provides different API views into the same schema, eliminating impedance mismatch between operational and analytical workloads:

pre
  code.
    // RecordView for structured operations
    RecordView&lt;Artist&gt; artists = ignite.tables()
        .table("Artist")
        .recordView(Artist.class);

    // KeyValueView for high-performance access patterns
    KeyValueView&lt;Long, Album&gt; albums = ignite.tables()
        .table("Album")
        .keyValueView(Long.class, Album.class);

    // SQL for analytics using Apache Calcite engine
    SqlStatement analytics = ignite.sql()
        .statementBuilder()
        .query("SELECT a.Name, COUNT(al.AlbumId) as AlbumCount " +
                "FROM Artist a JOIN Album al ON a.ArtistId = al.ArtistId " +
                "GROUP BY a.Name");

    // Collocated compute jobs
    ComputeJob&lt;String&gt; job = ComputeJob.colocated("Artist", 42,
        RecommendationJob.class);
    JobExecution&lt;String&gt; recommendation = ignite.compute()
        .submit(ignite.clusterNodes(), job, "rock");

p This approach eliminates the typical data serialization and movement overhead between different systems while maintaining type safety and schema evolution capabilities.

blockquote
  p This represents a fundamental architectural shift from Ignite 2.x, that accessed data as key-value operations using the cache API. Ignite 3 puts an evolvable schema first and uses memory-centric storage to deliver microsecond latencies for all operations, not just cache hits.

h3 Memory-First Storage Architecture

p Unlike disk-first distributed databases, Ignite 3 uses a memory-first storage model with configurable persistence options:

ul
  li
    strong
      code aimem
    | : Pure in-memory storage for maximum performance
  li
    strong
      code aipersist
    | : Memory-first with persistence for durability
  li
    strong
      code RocksDB
    | : Disk-based storage for write-heavy workloads

p The memory-first approach delivers microsecond response times for hot data while providing flexible cost-performance trade-offs through configurable memory-to-disk ratios.

h4 Storage Engine Characteristics

table(style="border-collapse: collapse; margin: 20px 0; width: 100%;")
  thead
    tr
      th(style="border: 1px solid #ddd; padding: 12px; background-color: #f5f5f5; text-align: left;") Engine
      th(style="border: 1px solid #ddd; padding: 12px; background-color: #f5f5f5; text-align: left;") Primary Use Case
      th(style="border: 1px solid #ddd; padding: 12px; background-color: #f5f5f5; text-align: left;") Latency Profile
      th(style="border: 1px solid #ddd; padding: 12px; background-color: #f5f5f5; text-align: left;") Durability
  tbody
    tr
      td(style="border: 1px solid #ddd; padding: 12px;") aimem
      td(style="border: 1px solid #ddd; padding: 12px;") Ultra-low latency
      td(style="border: 1px solid #ddd; padding: 12px;") Microseconds
      td(style="border: 1px solid #ddd; padding: 12px;") Volatile
    tr
      td(style="border: 1px solid #ddd; padding: 12px;") aipersist
      td(style="border: 1px solid #ddd; padding: 12px;") Balanced performance
      td(style="border: 1px solid #ddd; padding: 12px;") Microseconds (memory)
      td(style="border: 1px solid #ddd; padding: 12px;") Persistent
    tr
      td(style="border: 1px solid #ddd; padding: 12px;") RocksDB
      td(style="border: 1px solid #ddd; padding: 12px;") Write-heavy workloads
      td(style="border: 1px solid #ddd; padding: 12px;") Variable
      td(style="border: 1px solid #ddd; padding: 12px;") Persistent

h3 Consistency and Concurrency Model

p Ignite 3 implements Raft consensus for strong consistency and MVCC (Multi-Version Concurrency Control) for transaction isolation:

ul
  li
    strong Raft consensus
    | : Ensures data consistency across replicas without split-brain scenarios
  li
    strong MVCC transactions
    | : Provides snapshot isolation and deadlock-free concurrency
  li
    strong ACID compliance
    | : Full transactional guarantees across distributed operations

p This consistency model applies uniformly across all APIs, whether you're using RecordView operations, SQL queries, or compute jobs.

h3 Collocated Processing: Compute-to-Data Architecture

p One of Ignite 3's key architectural advantages is collocated processing, which brings computation to where data is stored rather than moving data to compute resources:

pre
  code.
    // Traditional approach: data movement overhead
    // 1. Query data from database
    // 2. Move data to compute cluster  
    // 3. Process data remotely
    // 4. Return results

    // Ignite 3 approach: compute colocation
    ComputeJob&lt;Result&gt; job = ComputeJob.colocated("Customer", customerId,
        RiskAnalysisJob.class);
    CompletableFuture&lt;Result&gt; result = ignite.compute()
        .submitAsync(job, parameters);

p This compute-to-data pattern eliminates network serialization overhead and enables processing of large datasets without data movement. Instead of moving terabytes of data to processing nodes, you move kilobytes of code to where the data lives.

h3 System Consolidation Benefits

p Traditional distributed architectures typically require separate systems for different workloads:

p
  strong Traditional Multi-System Architecture:

ul
  li Transactional database (PostgreSQL, MySQL) - millisecond latencies
  li Analytics database (ClickHouse, Snowflake) - batch processing
  li Caching layer (Redis, Hazelcast) - separate consistency model
  li Compute cluster (Spark, Flink) - data movement overhead
  li Message queue (Kafka, RabbitMQ) - separate operational model
  li Stream processing (Kafka Streams, Pulsar) - additional complexity

p
  strong Ignite 3 Unified Platform:

ul
  li Schema-driven storage with multiple storage engines - microsecond latencies
  li SQL analytics through Apache Calcite - real-time processing
  li Collocated compute processing - zero data movement
  li Built-in streaming with flow control - integrated backpressure
  li ACID transactions across all operations - single consistency model
  li One operational model and consistency guarantee

h4 Operational Advantages

ul
  li
    strong Unified Schema Evolution
    | : Schema changes propagate automatically across all access patterns
  li
    strong Single Consistency Model
    | : ACID guarantees across transactions, analytics, and compute
  li
    strong Reduced Operational Complexity
    | : One system to monitor, tune, and scale
  li
    strong Eliminated Data Movement
    | : Processing happens where data lives
  li
    strong Cost-Elastic Scaling
    | : Adjust memory-to-disk ratios based on performance requirements

h3 Streaming and Flow Control

p Ignite 3 includes built-in streaming capabilities with configurable backpressure mechanisms:

pre
  code.
    // Publisher with flow control configuration
    StreamingOptions options = StreamingOptions.builder()
        .pageSize(1000)
        .autoFlushFrequency(Duration.ofMillis(100))
        .retryLimit(3)
        .build();

    // Handle millions of events with automatic backpressure
    CompletableFuture&lt;Void&gt; streaming = ignite.sql()
        .streamAsync("INSERT INTO events VALUES (?, ?, ?)", 
                     eventStream, 
                     options);

p The streaming API provides automatic flow control through configurable page sizes, flush intervals, and retry policies, preventing system overload without data loss.

h3 Performance Characteristics

p Ignite 3's memory-first architecture delivers significantly different performance characteristics compared to disk-based distributed databases:

ul
  li
    strong Latency
    | : Microsecond response times for memory-resident data vs. millisecond latencies for disk-based systems
  li
    strong Throughput
    | : Handles millions of operations per second per node
  li
    strong Scalability
    | : Linear scaling through data partitioning and colocation
  li
    strong Consistency
    | : ACID transactions with minimal overhead due to memory speeds

p The 10-1000x performance improvement comes from eliminating disk I/O bottlenecks and data movement overhead through collocated processing.

h3 Migration and Adoption Strategy

p For technical teams considering Ignite 3:

h4 Assessment Phase

ul
  li
    strong Workload Analysis
    | : Identify performance-critical paths requiring microsecond latencies
  li
    strong Data Model Mapping
    | : Design colocation strategies for your entities
  li
    strong Integration Points
    | : Plan API migration from current multi-system architecture
  li
    strong Performance Benchmarking
    | : Compare memory-first vs. disk-first performance for your workloads

h4 Implementation Approach

ul
  li
    strong Start with New Features
    | : Use Ignite 3 for new development requiring low latency
  li
    strong Gradual Migration
    | : Move performance-critical workloads first
  li
    strong Schema Design
    | : Leverage colocation for optimal data locality
  li
    strong Operational Integration
    | : Integrate monitoring and deployment pipelines

h3 Technical Considerations

h4 Schema Design Best Practices

ul
  li Use 
    code colocateBy
    |  annotations to ensure related data stays together
  li Design partition keys to distribute load evenly across nodes
  li Consider query patterns when defining indexes and colocation strategies
  li Plan for schema evolution with backward-compatible changes

h4 Performance Optimization

ul
  li Size memory regions appropriately for your working set
  li Use collocated compute jobs to minimize data movement
  li Leverage appropriate storage engines for different workload patterns
  li Monitor memory usage and adjust disk ratios as needed

h4 Operational Requirements

ul
  li Plan for Raft consensus network requirements (low-latency, reliable connectivity)
  li Design backup and recovery procedures for persistent storage engines
  li Implement monitoring for memory usage, query performance, and compute job execution
  li Establish capacity planning procedures for memory-first architecture

h3 Summary

p Apache Ignite 3 represents a schema-driven distributed computing platform that consolidates transaction processing, analytics, and compute workloads into a single memory-first architecture. Key architectural elements include:

ul
  li
    strong Schema-driven design
    | : Single schema definition drives data placement, query optimization, and compute colocation
  li
    strong Memory-first storage
    | : Multiple storage engines with microsecond latency characteristics
  li
    strong Collocated processing
    | : Compute-to-data architecture that eliminates data movement overhead
  li
    strong Unified APIs
    | : Multiple access patterns (RecordView, KeyValueView, SQL, Compute) for the same schema
  li
    strong ACID consistency
    | : Raft consensus and MVCC transactions across all operations
  li
    strong Built-in streaming
    | : Flow control and backpressure mechanisms for high-velocity data ingestion

p The platform addresses scenarios where traditional multi-system architectures create operational complexity and performance bottlenecks through data movement between separate databases, compute clusters, and analytics systems.

p Explore the 
  a(href="https://ignite.apache.org/docs/ignite3/latest/") Ignite 3 documentation
  |  for detailed implementation guides and API references.