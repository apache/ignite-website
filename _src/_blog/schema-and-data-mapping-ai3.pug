---
title: "Schema and Data Mapping in Apache Ignite 3"
author: "Michael Aglietti"
date: 2026-01-27
tags:
  - technical
  - ignite3
  - java
---

p
  | Your schema came from somewhere. Maybe SQL scripts, maybe another developer, maybe your own DDL. Your application uses
  |
  code Mapper.of()
  |  for data access, and the workflow is functional. But if your POJO field names don't exactly match your column names, you're writing
  |
  code map()
  |  calls to bridge them, and that can start to feel heavy.
<!-- end -->

h2 Schema and Data Mapping in Apache Ignite 3
br
p
  | When you use
  |
  code automap()
  |  from the
  |
  code table.mapper
  |  package, it reads those annotations and builds the mappings for you.

p Learn how these packages work together, and your future self will thank you.
br
h2 Connecting Schema to Code
br
p
  | Database columns typically use names like
  |
  code order_date
  | . Java fields typically use names like
  |
  code orderDate
  | . When Ignite normalizes these to uppercase, the SQL column becomes
  |
  code ORDER_DATE
  |  while the Java field becomes
  |
  code ORDERDATE
  | . Different strings that don't map.

p
  | The
  |
  code catalog.annotations
  |  package gives you a way to declare mappings in your POJO:

pre
  code.java.
    // @Column declares the column mapping at the source
    public class Order {
        @Id
        @Column("ORDER_ID")
        Integer orderId;
        @Column("CUSTOMER_ID")
        String customerId;
        @Column("ORDER_DATE")
        LocalDate orderDate;
        @Column("TOTAL_AMOUNT")
        BigDecimal totalAmount;
        @Column("STATUS")
        String status;
    }

p
  | Each
  |
  code @Column
  |  annotation tells Ignite exactly which column the field maps to. The annotation value goes through the same normalization as SQL identifiers, so everything lines up.

p Now your mapper call becomes straightforward:

pre
  code.java.
    // automap() reads @Column annotations and builds mappings automatically
    Mapper&lt;Order&gt mapper = Mapper.builder(Order.class)
        .automap()
        .build();

p
  | The
  |
  code automap()
  |  method scans your class, finds the annotations, and builds the mappings. You annotate the POJO once. Every developer who writes a service or batch job using that class gets the mapping without thinking about it. The SRE debugging at 2am can read the class and understand the schema.

p
  | If you built your schema with SQL, this approach still works. Add
  |
  code @Column
  |  annotations to your POJO fields, and
  |
  code automap()
  |  handles the mapping. Your schema stays in SQL. Your mappings stay visible in your code.

p
  | If you want to go further, the
  |
  code catalog.annotations
  |  package lets you define your entire schema in Java. Annotations like
  |
  code @Table
  | ,
  |
  code @Zone
  | , and
  |
  code @Index
  |  replace your DDL scripts with compile-time-checked code. The POJO becomes the single source of truth for both schema and mapping. That's a topic for another post, but worth exploring if you prefer keeping schema close to your application code.

br
h2 Why This Matters
br
p When the mapping lives on the field, you get benefits that compound over time.

p
  | Your IDE becomes more helpful. The
  |
  code @Column
  |  annotation uses
  |
  code @Retention(RUNTIME)
  | , so IntelliJ sees it and can provide context. Hover over a field to see the column name. Use Find Usages to trace references. Refactor with confidence because the annotation moves with the field.

p Future you can quickly jump back into the code. When you return to this class in six months, the column name is right there on the field. No hunting through mapper files. No tracing string literals across your codebase. The mapping is visible where you're already looking.

p
  | The alternative is explicit
  |
  code map()
  |  calls scattered through your mapper code:

pre
  code.java.
    // Explicit mapping: column names scattered in mapper code, far from fields
    Mapper&lt;Order&gt mapper = Mapper.builder(Order.class)
        .map("orderId", "ORDER_ID")
        .map("customerId", "CUSTOMER_ID")
        .map("orderDate", "ORDER_DATE")
        .map("totalAmount", "TOTAL_AMOUNT")
        .map("status", "STATUS")
        .build();

p This works, and sometimes it's the right choice. But the column names live far from the fields they describe, which makes the code harder to maintain and gives your IDE less to work with.
br
h2 The Packages Work Together
br
p
  | The
  |
  code @Column
  |  annotation comes from
  |
  code org.apache.ignite.catalog.annotations
  | . The
  |
  code automap()
  |  method comes from
  |
  code org.apache.ignite.table.mapper
  | . These are separate packages with separate purposes, but they were designed to complement each other.

p
  | When you call
  |
  code automap()
  |  on a
  |
  code MapperBuilder
  | , it scans your class for fields. For each field, it checks for a
  |
  code @Column
  |  annotation and uses that value as the column name. If there's no annotation, it falls back to the field name, normalized to uppercase. Fields you've already mapped explicitly with
  |
  code map()
  |  are skipped.

p
  | The scanning finds only fields declared directly in your class. If your POJO extends a parent class, inherited fields won't be discovered, even if they have
  |
  code @Column
  |  annotations. The same applies to
  |
  code createTable(Class)
  | . For shared fields across multiple tables, define them in each class or use composition.

p This means you can mix approaches when you need to. Use annotations for most fields and explicit mapping for edge cases that require type conversion:

pre
  code.java.
    // Mix explicit mapping for type conversion with automap() for everything else
    Mapper&lt;Event&gt mapper = Mapper.builder(Event.class)
        .map("eventDate", "EVENT_DATE", new LocalDateConverter())
        .automap()
        .build();

p
  | The explicit
  |
  code map()
  |  handles the field that needs special treatment. The
  |
  code automap()
  |  handles everything else based on your annotations.

p The relationship between these components looks like this:

pre.mermaid.
  graph TB
      ANN["@Column Annotations"]
      subgraph CAT["Catalog API - Schema"]
          OPT1["@Table/@Zone/@Index on POJO"]
          OPT2[SQL DDL]
          OPT3[Java Catalog DSL]
      end
      subgraph MAP["Mapper API - Data Mapping"]
          OPT4["automap() reads @Column"]
          OPT5["Explicit map() no annotations"]
      end
      ANN -.Shared by.-> OPT1
      ANN -.Shared by.-> OPT4
      OPT1 --> SCHEMA[Table Schema]
      OPT2 --> SCHEMA
      OPT3 --> SCHEMA
      OPT4 --> MAPPING[Runtime Mapping]
      OPT5 --> MAPPING
      SCHEMA -.Work Together.-> MAPPING

p
  | The
  |
  code @Column
  |  annotation bridges both APIs, and each API has alternatives. You can define schema with SQL DDL and still use
  |
  code automap()
  |  for mapping. You can create tables from annotations and still use explicit
  |
  code map()
  |  calls. The APIs work together but remain independent.

br
h2 The Full Annotation Set
br
p
  | Now that you understand how
  |
  code automap()
  |  reads
  |
  code @Column
  | , here's the full toolkit. The
  |
  code catalog.annotations
  |  package includes more than just
  |
  code @Column
  | . If you want to define your entire schema from Java classes, you have the tools:

table
  thead
    tr
      th Annotation
      th Purpose
  tbody
    tr
      td
        code @Table
      td Table name, zone, indexes, colocation
    tr
      td
        code @Column
      td Column name and properties
    tr
      td
        code @Id
      td Primary key field
    tr
      td
        code @Index
      td Secondary index
    tr
      td
        code @ColumnRef
      td Column reference for indexes
    tr
      td
        code @Zone
      td Distribution zone configuration

p You can use these annotations to generate your schema instead of writing SQL. Or you can use just
  |
  code @Column
  |  to help your mappers while managing schema separately. The packages support both workflows.

p
  | The
  |
  code table.mapper
  |  package provides the runtime side:

table
  thead
    tr
      th Component
      th Purpose
  tbody
    tr
      td
        code Mapper.of()
      td Factory for standard mappings
    tr
      td
        code MapperBuilder
      td Fluent API for custom mappings
    tr
      td
        code TypeConverter
      td Type transformation
    tr
      td
        code automap()
      td Automatic mapping using annotations

br
h2 Complete Example
br
p Here's a complete example using both packages. The POJO becomes your single source of truth for schema, distribution strategy, and field mappings:

pre
  code.java.
    // Single POJO defines everything: schema, zone, indexes, and column mappings
    // This class is the source of truth for both DDL generation and runtime mapping
    @Table(
        value = "orders",
        zone = @Zone(value = "orders_zone", storageProfiles = "default"),
        colocateBy = @ColumnRef("CUSTOMER_ID"),
        indexes = @Index(value = "idx_order_date", columns = {
            @ColumnRef(value = "ORDER_DATE", sort = SortOrder.DESC)
        })
    )
    public class Order {
        @Id
        @Column(value = "ORDER_ID", nullable = false)
        Integer orderId;
        @Id
        @Column(value = "CUSTOMER_ID", nullable = false)
        String customerId;
        @Column(value = "ORDER_DATE", nullable = false)
        LocalDate orderDate;
        @Column(value = "TOTAL_AMOUNT", precision = 10, scale = 2)
        BigDecimal totalAmount;
        @Column(value = "STATUS", length = 20)
        String status;
        // Constructors, getters, setters...
    }

p Create the table from your annotated class:

pre
  code.java.
    // Schema generated from annotations, table created in one call
    Table ordersTable = client.catalog().createTable(Order.class);

p Use the data with a mapper that reads those same annotations:

pre
  code.java.
    // RecordView uses your POJO directly
    // Mapper reads @Column annotations through automap()
    RecordView&lt;Order&gt orders = ordersTable.recordView(Mapper.of(Order.class));
    Order order = new Order(1001, "cust-001", LocalDate.now(),
        new BigDecimal("299.99"), "PENDING");
    orders.upsert(null, order);
    Order retrieved = orders.get(null, order);

br
h2 Beyond Annotations
br
p
  | The examples use annotations for both schema definition (
  |
  code @Table
  | ,
  |
  code @Zone
  | ,
  |
  code @Index
  | ) and data mapping (
  |
  code @Column
  | ). This is the simplest approach when you control both schema and code, but both APIs can also work independently.

p #[strong Alternative schema definition:]

ul
  li Use SQL DDL instead of
    |
    |
    code catalog.createTable(Class)
    |  if your schema already exists or your team prefers SQL
  li Use the Java Catalog DSL for programmatic schema creation without annotations
  li These approaches support schema evolution with
    |
    |
    code ALTER TABLE
    |  operations

p #[strong Alternative data mapping:]

ul
  li Use
    |
    code Mapper.builder().map("field", "COLUMN")
    |
    |  for explicit control without annotations
  li Mix explicit mapping with
    |
    code automap()
    |  for type conversions or special cases
  li Create custom
    |
    code Mapper
    |  implementations for advanced scenarios
  li The mapper works regardless of how you created the table

p #[strong Schema evolution consideration:]

p
  | Annotations provide convenience for the create-once pattern. The
  |
  code createTable(Class)
  |  method generates schema from your POJO, but it doesn't support altering existing tables. If your application needs to evolve the schema over time, define your tables with SQL DDL. You can still use
  |
  code @Column
  |  annotations on your POJOs for mapping, even if the table was created with DDL.

p The key is that annotations bridge the two APIs when you want them to, but you're not locked into using them for both. Pick the approach that fits your workflow.

br
h2 Summary
br

table
  thead
    tr
      th Want to...
      th Use this
  tbody
    tr
      td Define column name for a field
      td
        code @Column("COLUMN_NAME")
    tr
      td Map fields automatically
      td
        code Mapper.builder(Class).automap().build()
    tr
      td Map a specific field manually
      td
        code .map("fieldName", "COLUMN_NAME")
    tr
      td Convert types during mapping
      td
        code .map("field", "COLUMN", new TypeConverter())
    tr
      td Create table from annotations
      td
        code client.catalog().createTable(Order.class)

p
  | Database conventions and Java conventions don't naturally align, and Ignite's identifier normalization adds another consideration. The
  |
  code catalog.annotations
  |  package lets you declare the mapping at the source, right on your fields. The
  |
  code table.mapper
  |  package reads those declarations through
  |
  code automap()
  | , turning what could be scattered configuration into a single point of truth.

p The result is code that your IDE can help you navigate and that future you can understand without archaeology.

p
  | For more details, see the
  |
  a(href="https://ignite.apache.org/docs/ignite3/latest/developers-guide/java-to-tables") Creating Tables from Java Classes
  |  and
  |
  a(href="https://ignite.apache.org/docs/ignite3/latest/developers-guide/table-api") Table API
  |  documentation.
