"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6210],{26215:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"api-reference/native-clients/java/tables-api","title":"Tables API","description":"The Tables API provides structured access to data stored in Ignite tables. Applications interact with tables through views that offer different perspectives on the data: record views for full row operations and key-value views for key-based access patterns.","source":"@site/docs/api-reference/native-clients/java/tables-api.md","sourceDirName":"api-reference/native-clients/java","slug":"/api-reference/native-clients/java/tables-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/tables-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Tables API","id":"tables-api","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Server API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/server-api"},"next":{"title":"Data Streamer API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/data-streamer-api"}}');var i=r(74848),a=r(28453);const t={title:"Tables API",id:"tables-api",sidebar_position:3},s="Tables API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Table Discovery",id:"table-discovery",level:2},{value:"Record View",id:"record-view",level:2},{value:"Typed Record View",id:"typed-record-view",level:2},{value:"Key-Value View",id:"key-value-view",level:2},{value:"Typed Key-Value View",id:"typed-key-value-view",level:2},{value:"Batch Operations",id:"batch-operations",level:2},{value:"Key-Value Batch Operations",id:"key-value-batch-operations",level:2},{value:"Conditional Operations",id:"conditional-operations",level:2},{value:"Asynchronous Operations",id:"asynchronous-operations",level:2},{value:"Partition Information",id:"partition-information",level:2},{value:"Tuple Construction",id:"tuple-construction",level:2},{value:"Tuple Value Access",id:"tuple-value-access",level:2},{value:"Reference",id:"reference",level:2},{value:"IgniteTables Methods",id:"ignitetables-methods",level:3},{value:"Table View Methods",id:"table-view-methods",level:3},{value:"RecordView CRUD Methods",id:"recordview-crud-methods",level:3},{value:"KeyValueView Methods",id:"keyvalueview-methods",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"tables-api",children:"Tables API"})}),"\n",(0,i.jsx)(n.p,{children:"The Tables API provides structured access to data stored in Ignite tables. Applications interact with tables through views that offer different perspectives on the data: record views for full row operations and key-value views for key-based access patterns."}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.p,{children:"Tables store data in rows with typed columns. The API provides three access patterns through views. RecordView treats each row as a complete record. KeyValueView separates rows into key and value portions. Both support binary Tuple access and typed object mapping."}),"\n",(0,i.jsx)(n.p,{children:"Operations execute within optional transaction contexts. Pass null for auto-commit behavior or provide a Transaction for multi-operation atomicity."}),"\n",(0,i.jsx)(n.h2,{id:"table-discovery",children:"Table Discovery"}),"\n",(0,i.jsx)(n.p,{children:"Access tables through the tables manager:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Table users = ignite.tables().table("users");\r\nif (users == null) {\r\n    System.out.println("Table does not exist");\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For qualified names with schemas:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Table products = ignite.tables().table(QualifiedName.of("inventory", "products"));\n'})}),"\n",(0,i.jsx)(n.p,{children:"List all tables asynchronously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"CompletableFuture<List<Table>> tablesFuture = ignite.tables().tablesAsync();\r\ntablesFuture.thenAccept(tables -> {\r\n    for (Table table : tables) {\r\n        System.out.println(table.name());\r\n    }\r\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"record-view",children:"Record View"}),"\n",(0,i.jsx)(n.p,{children:"RecordView operations work with complete rows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\r\n\r\n// Insert or update\r\nTuple record = Tuple.create()\r\n    .set("id", 1)\r\n    .set("name", "Alice")\r\n    .set("age", 30);\r\nview.upsert(null, record);\r\n\r\n// Retrieve\r\nTuple key = Tuple.create().set("id", 1);\r\nTuple result = view.get(null, key);\r\nSystem.out.println(result.stringValue("name"));\r\n\r\n// Check existence\r\nboolean exists = view.contains(null, key);\r\n\r\n// Delete\r\nboolean deleted = view.delete(null, key);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Pass null as the transaction parameter for operations outside transactions."}),"\n",(0,i.jsx)(n.h2,{id:"typed-record-view",children:"Typed Record View"}),"\n",(0,i.jsx)(n.p,{children:"Map rows to Java objects using typed views:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class User {\r\n    public int id;\r\n    public String name;\r\n    public int age;\r\n}\r\n\r\nRecordView<User> view = table.recordView(User.class);\r\n\r\nUser user = new User();\r\nuser.id = 1;\r\nuser.name = "Alice";\r\nuser.age = 30;\r\n\r\nview.upsert(null, user);\r\n\r\nUser key = new User();\r\nkey.id = 1;\r\nUser retrieved = view.get(null, key);\n'})}),"\n",(0,i.jsx)(n.p,{children:"The view automatically maps between object fields and table columns."}),"\n",(0,i.jsx)(n.h2,{id:"key-value-view",children:"Key-Value View"}),"\n",(0,i.jsx)(n.p,{children:"KeyValueView separates key and value portions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\r\n\r\nTuple key = Tuple.create().set("id", 1);\r\nTuple value = Tuple.create()\r\n    .set("name", "Alice")\r\n    .set("age", 30);\r\n\r\nview.put(null, key, value);\r\n\r\nTuple retrieved = view.get(null, key);\r\nSystem.out.println(retrieved.stringValue("name"));\r\n\r\n// Check for null vs missing\r\nNullableValue<Tuple> nullable = view.getNullable(null, key);\r\nif (nullable != null) {\r\n    System.out.println("Found: " + nullable.get());\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"NullableValue distinguishes between missing entries and entries with null values."}),"\n",(0,i.jsx)(n.h2,{id:"typed-key-value-view",children:"Typed Key-Value View"}),"\n",(0,i.jsx)(n.p,{children:"Map keys and values to separate types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class ProductKey {\r\n    public int id;\r\n}\r\n\r\npublic class ProductValue {\r\n    public String name;\r\n    public double price;\r\n}\r\n\r\nKeyValueView<ProductKey, ProductValue> view =\r\n    table.keyValueView(ProductKey.class, ProductValue.class);\r\n\r\nProductKey key = new ProductKey();\r\nkey.id = 100;\r\n\r\nProductValue value = new ProductValue();\r\nvalue.name = "Widget";\r\nvalue.price = 29.99;\r\n\r\nview.put(null, key, value);\r\n\r\nProductValue retrieved = view.get(null, key);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,i.jsx)(n.p,{children:"Process multiple records in single operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\r\n\r\nList<Tuple> records = Arrays.asList(\r\n    Tuple.create().set("id", 1).set("name", "Alice"),\r\n    Tuple.create().set("id", 2).set("name", "Bob"),\r\n    Tuple.create().set("id", 3).set("name", "Carol")\r\n);\r\n\r\nview.upsertAll(null, records);\r\n\r\nList<Tuple> keys = Arrays.asList(\r\n    Tuple.create().set("id", 1),\r\n    Tuple.create().set("id", 2)\r\n);\r\n\r\nList<Tuple> results = view.getAll(null, keys);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Batch operations reduce network overhead for multiple operations."}),"\n",(0,i.jsx)(n.h2,{id:"key-value-batch-operations",children:"Key-Value Batch Operations"}),"\n",(0,i.jsx)(n.p,{children:"Similar batch support for key-value views:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\r\n\r\nMap<Tuple, Tuple> entries = new HashMap<>();\r\nentries.put(\r\n    Tuple.create().set("id", 1),\r\n    Tuple.create().set("name", "Alice")\r\n);\r\nentries.put(\r\n    Tuple.create().set("id", 2),\r\n    Tuple.create().set("name", "Bob")\r\n);\r\n\r\nview.putAll(null, entries);\r\n\r\nCollection<Tuple> keys = Arrays.asList(\r\n    Tuple.create().set("id", 1),\r\n    Tuple.create().set("id", 2)\r\n);\r\n\r\nMap<Tuple, Tuple> results = view.getAll(null, keys);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-operations",children:"Conditional Operations"}),"\n",(0,i.jsx)(n.p,{children:"Execute operations based on current values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\r\n\r\nTuple key = Tuple.create().set("id", 1);\r\nTuple oldValue = Tuple.create().set("status", "pending");\r\nTuple newValue = Tuple.create().set("status", "active");\r\n\r\n// Replace only if current value matches\r\nboolean replaced = view.replace(null, key, oldValue, newValue);\r\n\r\nif (replaced) {\r\n    System.out.println("Value updated");\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Conditional operations provide atomic compare-and-set semantics."}),"\n",(0,i.jsx)(n.h2,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,i.jsx)(n.p,{children:"All operations support asynchronous execution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\r\n\r\nTuple record = Tuple.create()\r\n    .set("id", 1)\r\n    .set("name", "Alice");\r\n\r\nCompletableFuture<Void> upsertFuture = view.upsertAsync(null, record);\r\n\r\nTuple key = Tuple.create().set("id", 1);\r\nCompletableFuture<Tuple> getFuture = view.getAsync(null, key);\r\n\r\ngetFuture.thenAccept(result -> {\r\n    System.out.println(result.stringValue("name"));\r\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Asynchronous operations return immediately without blocking the calling thread."}),"\n",(0,i.jsx)(n.h2,{id:"partition-information",children:"Partition Information"}),"\n",(0,i.jsx)(n.p,{children:"Access partition metadata through the partition manager:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'PartitionManager partitions = table.partitionManager();\r\nCompletableFuture<Partition> partition =\r\n    partitions.partitionAsync(Tuple.create().set("id", 1));\r\n\r\npartition.thenAccept(p -> {\r\n    System.out.println("Record belongs to partition: " + p.id());\r\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Partition information enables colocated compute operations."}),"\n",(0,i.jsx)(n.h2,{id:"tuple-construction",children:"Tuple Construction"}),"\n",(0,i.jsx)(n.p,{children:"Create tuples with various approaches:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Empty tuple\r\nTuple tuple1 = Tuple.create();\r\n\r\n// With capacity hint\r\nTuple tuple2 = Tuple.create(10);\r\n\r\n// From map\r\nMap<String, Object> data = new HashMap<>();\r\ndata.put("id", 1);\r\ndata.put("name", "Alice");\r\nTuple tuple3 = Tuple.create(data);\r\n\r\n// Copy existing\r\nTuple tuple4 = Tuple.copy(tuple3);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Set values by name:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Tuple tuple = Tuple.create()\r\n    .set("id", 1)\r\n    .set("name", "Alice")\r\n    .set("age", 30)\r\n    .set("balance", 1000.50)\r\n    .set("created", LocalDateTime.now());\n'})}),"\n",(0,i.jsx)(n.h2,{id:"tuple-value-access",children:"Tuple Value Access"}),"\n",(0,i.jsx)(n.p,{children:"Retrieve values by column name with type-specific methods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'int id = tuple.intValue("id");\r\nString name = tuple.stringValue("name");\r\nInteger age = tuple.value("age");\r\nLocalDateTime created = tuple.value("created");\r\n\r\n// Access by index\r\nObject value = tuple.value(0);\r\nString columnName = tuple.columnName(0);\r\nint columnIndex = tuple.columnIndex("name");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Type-specific accessors avoid boxing for primitive types."}),"\n",(0,i.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Table management: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.IgniteTables"})]}),"\n",(0,i.jsxs)(n.li,{children:["Table interface: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.Table"})]}),"\n",(0,i.jsxs)(n.li,{children:["Record access: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.RecordView<R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Key-value access: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.KeyValueView<K, V>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Binary records: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.Tuple"})]}),"\n",(0,i.jsxs)(n.li,{children:["Partition info: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.table.partition.PartitionManager"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"ignitetables-methods",children:"IgniteTables Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"List<Table> tables()"})," - Get all tables synchronously"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<List<Table>> tablesAsync()"})," - Get all tables asynchronously"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Table table(String name)"})," - Get table by simple name"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Table table(QualifiedName name)"})," - Get table by qualified name"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Table> tableAsync(String name)"})," - Get table asynchronously"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Table> tableAsync(QualifiedName name)"})," - Get table asynchronously with qualified name"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"table-view-methods",children:"Table View Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RecordView<Tuple> recordView()"})," - Get binary record view"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RecordView<R> recordView(Class<R>)"})," - Get typed record view"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RecordView<R> recordView(Mapper<R>)"})," - Get record view with custom mapper"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KeyValueView<Tuple, Tuple> keyValueView()"})," - Get binary key-value view"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KeyValueView<K, V> keyValueView(Class<K>, Class<V>)"})," - Get typed key-value view"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"KeyValueView<K, V> keyValueView(Mapper<K>, Mapper<V>)"})," - Get key-value view with custom mappers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"recordview-crud-methods",children:"RecordView CRUD Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"R get(Transaction, R keyRec)"})," - Get record by key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<R> getAsync(Transaction, R keyRec)"})," - Async get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"List<R> getAll(Transaction, Collection<R>)"})," - Get multiple records"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<List<R>> getAllAsync(Transaction, Collection<R>)"})," - Async get multiple"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"boolean contains(Transaction, R keyRec)"})," - Check existence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void upsert(Transaction, R rec)"})," - Insert or update record"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Void> upsertAsync(Transaction, R rec)"})," - Async upsert"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void upsertAll(Transaction, Collection<R>)"})," - Insert or update multiple"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"boolean delete(Transaction, R keyRec)"})," - Delete record"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Boolean> deleteAsync(Transaction, R keyRec)"})," - Async delete"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"keyvalueview-methods",children:"KeyValueView Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"V get(Transaction, K key)"})," - Get value by key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<V> getAsync(Transaction, K key)"})," - Async get"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NullableValue<V> getNullable(Transaction, K key)"})," - Get with null distinction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Map<K, V> getAll(Transaction, Collection<K>)"})," - Get multiple values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void put(Transaction, K key, V value)"})," - Put key-value pair"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Void> putAsync(Transaction, K key, V value)"})," - Async put"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void putAll(Transaction, Map<K, V>)"})," - Put multiple pairs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"boolean replace(Transaction, K key, V old, V new)"})," - Conditional replace"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void remove(Transaction, K key)"})," - Remove by key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"void removeAll(Transaction, Collection<K>)"})," - Remove multiple"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>s});var l=r(96540);const i={},a=l.createContext(i);function t(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);