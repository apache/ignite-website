"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6647],{7705:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-reference/native-clients/dotnet/transactions-api","title":"Transactions API","description":"The Transactions API provides ACID transaction support for coordinating multiple operations across tables. Transactions ensure atomicity, consistency, isolation, and durability for distributed data modifications.","source":"@site/docs/api-reference/native-clients/dotnet/transactions-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/transactions-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/transactions-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Transactions API","id":"transactions-api","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"ADO.NET API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/ado-net-api"},"next":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/compute-api"}}');var r=a(74848),i=a(28453);const s={title:"Transactions API",id:"transactions-api",sidebar_position:5},c="Transactions API",o={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:3},{value:"Auto-Commit Mode",id:"auto-commit-mode",level:3},{value:"Transaction Scope",id:"transaction-scope",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Transaction",id:"basic-transaction",level:3},{value:"Using Statement Pattern",id:"using-statement-pattern",level:3},{value:"Transaction with Exception Handling",id:"transaction-with-exception-handling",level:3},{value:"RunInTransactionAsync Pattern",id:"runintransactionasync-pattern",level:3},{value:"Mixing Key-Value and SQL Operations",id:"mixing-key-value-and-sql-operations",level:3},{value:"Cross-Table Transaction",id:"cross-table-transaction",level:3},{value:"Read-Only Transaction",id:"read-only-transaction",level:3},{value:"Transaction Timeout",id:"transaction-timeout",level:3},{value:"Reference",id:"reference",level:2},{value:"ITransactions Interface",id:"itransactions-interface",level:3},{value:"ITransaction Interface",id:"itransaction-interface",level:3},{value:"TransactionOptions Record Struct",id:"transactionoptions-record-struct",level:3},{value:"Best Practices",id:"best-practices",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"transactions-api",children:"Transactions API"})}),"\n",(0,r.jsx)(e.p,{children:"The Transactions API provides ACID transaction support for coordinating multiple operations across tables. Transactions ensure atomicity, consistency, isolation, and durability for distributed data modifications."}),"\n",(0,r.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(e.p,{children:"Transactions group multiple operations into a single atomic unit. Either all operations succeed and commit together, or all operations fail and roll back together."}),"\n",(0,r.jsx)(e.h3,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,r.jsx)(e.p,{children:"Begin a transaction using the Transactions API, pass the transaction object to data operations, and explicitly commit or roll back when done. The transaction must be disposed after use."}),"\n",(0,r.jsx)(e.h3,{id:"auto-commit-mode",children:"Auto-Commit Mode"}),"\n",(0,r.jsx)(e.p,{children:"Operations that receive null for the transaction parameter execute in auto-commit mode. Each operation commits immediately after completion. Use this for single operations that do not require coordination."}),"\n",(0,r.jsx)(e.h3,{id:"transaction-scope",children:"Transaction Scope"}),"\n",(0,r.jsx)(e.p,{children:"Pass the same transaction object to multiple operations to include them in the transaction scope. Operations can span different tables and mix key-value and SQL operations."}),"\n",(0,r.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(e.h3,{id:"basic-transaction",children:"Basic Transaction"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\r\nvar tx = await transactions.BeginAsync();\r\n\r\ntry\r\n{\r\n    var table = await client.Tables.GetTableAsync("accounts");\r\n    var view = table.GetRecordView<Account>();\r\n\r\n    // Multiple operations in transaction\r\n    var account1 = new Account { Id = 1 };\r\n    var account1Data = await view.GetAsync(tx, account1);\r\n\r\n    var account2 = new Account { Id = 2 };\r\n    var account2Data = await view.GetAsync(tx, account2);\r\n\r\n    // Update balances\r\n    account1Data.Value.Balance -= 100;\r\n    account2Data.Value.Balance += 100;\r\n\r\n    await view.UpsertAsync(tx, account1Data.Value);\r\n    await view.UpsertAsync(tx, account2Data.Value);\r\n\r\n    // Commit transaction\r\n    await tx.CommitAsync();\r\n}\r\ncatch\r\n{\r\n    await tx.RollbackAsync();\r\n    throw;\r\n}\r\nfinally\r\n{\r\n    await tx.DisposeAsync();\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"using-statement-pattern",children:"Using Statement Pattern"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\r\n\r\nawait using (var tx = await transactions.BeginAsync())\r\n{\r\n    var table = await client.Tables.GetTableAsync("orders");\r\n    var view = table.GetRecordView<Order>();\r\n\r\n    var order = new Order\r\n    {\r\n        OrderId = 1000,\r\n        CustomerId = 5,\r\n        Amount = 99.99m,\r\n        Status = "pending"\r\n    };\r\n\r\n    await view.UpsertAsync(tx, order);\r\n    await tx.CommitAsync();\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"transaction-with-exception-handling",children:"Transaction with Exception Handling"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'try\r\n{\r\n    await using var tx = await client.Transactions.BeginAsync();\r\n\r\n    var table = await client.Tables.GetTableAsync("inventory");\r\n    var view = table.GetRecordView<Product>();\r\n\r\n    var product = new Product { Id = 100 };\r\n    var productData = await view.GetAsync(tx, product);\r\n\r\n    if (!productData.HasValue)\r\n    {\r\n        throw new Exception("Product not found");\r\n    }\r\n\r\n    if (productData.Value.Stock < 10)\r\n    {\r\n        throw new Exception("Insufficient stock");\r\n    }\r\n\r\n    productData.Value.Stock -= 10;\r\n    await view.UpsertAsync(tx, productData.Value);\r\n\r\n    await tx.CommitAsync();\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($"Transaction failed: {ex.Message}");\r\n    // Transaction automatically rolls back on exception\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"runintransactionasync-pattern",children:"RunInTransactionAsync Pattern"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\r\n\r\n// With return value\r\nvar newBalance = await transactions.RunInTransactionAsync(async tx =>\r\n{\r\n    var table = await client.Tables.GetTableAsync("accounts");\r\n    var view = table.GetRecordView<Account>();\r\n\r\n    var account = new Account { Id = 1 };\r\n    var accountData = await view.GetAsync(tx, account);\r\n\r\n    accountData.Value.Balance += 50;\r\n    await view.UpsertAsync(tx, accountData.Value);\r\n\r\n    return accountData.Value.Balance;\r\n});\r\n\r\nConsole.WriteLine($"New balance: {newBalance}");\r\n\r\n// Without return value\r\nawait transactions.RunInTransactionAsync(async tx =>\r\n{\r\n    var table = await client.Tables.GetTableAsync("logs");\r\n    var view = table.GetRecordView<LogEntry>();\r\n\r\n    var entry = new LogEntry\r\n    {\r\n        Id = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),\r\n        Message = "Transaction completed",\r\n        Timestamp = DateTime.UtcNow\r\n    };\r\n\r\n    await view.UpsertAsync(tx, entry);\r\n});\n'})}),"\n",(0,r.jsx)(e.p,{children:"The RunInTransactionAsync method automatically commits on success and rolls back on exception. It also handles disposal automatically."}),"\n",(0,r.jsx)(e.h3,{id:"mixing-key-value-and-sql-operations",children:"Mixing Key-Value and SQL Operations"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'await using var tx = await client.Transactions.BeginAsync();\r\n\r\n// Key-value operation\r\nvar accountsTable = await client.Tables.GetTableAsync("accounts");\r\nvar accountsView = accountsTable.GetRecordView<Account>();\r\n\r\nvar account = new Account { Id = 1 };\r\nvar accountData = await accountsView.GetAsync(tx, account);\r\naccountData.Value.Balance -= 100;\r\nawait accountsView.UpsertAsync(tx, accountData.Value);\r\n\r\n// SQL operation in same transaction\r\nvar sql = client.Sql;\r\nvar insertStmt = new SqlStatement(\r\n    "INSERT INTO transactions (account_id, amount, timestamp) VALUES (?, ?, ?)");\r\nawait sql.ExecuteAsync(tx, insertStmt, 1L, -100.0m, DateTime.UtcNow);\r\n\r\nawait tx.CommitAsync();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"cross-table-transaction",children:"Cross-Table Transaction"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'await using var tx = await client.Transactions.BeginAsync();\r\n\r\n// Update orders table\r\nvar ordersTable = await client.Tables.GetTableAsync("orders");\r\nvar ordersView = ordersTable.GetRecordView<Order>();\r\n\r\nvar order = new Order\r\n{\r\n    OrderId = 2000,\r\n    CustomerId = 10,\r\n    Amount = 199.99m,\r\n    Status = "confirmed"\r\n};\r\nawait ordersView.UpsertAsync(tx, order);\r\n\r\n// Update inventory table\r\nvar inventoryTable = await client.Tables.GetTableAsync("inventory");\r\nvar inventoryView = inventoryTable.GetRecordView<Product>();\r\n\r\nvar product = new Product { Id = 500 };\r\nvar productData = await inventoryView.GetAsync(tx, product);\r\nproductData.Value.Stock -= 1;\r\nawait inventoryView.UpsertAsync(tx, productData.Value);\r\n\r\nawait tx.CommitAsync();\n'})}),"\n",(0,r.jsx)(e.h3,{id:"read-only-transaction",children:"Read-Only Transaction"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var options = new TransactionOptions(ReadOnly: true);\r\nawait using var tx = await client.Transactions.BeginAsync(options);\r\n\r\nvar table = await client.Tables.GetTableAsync("products");\r\nvar view = table.GetRecordView<Product>();\r\n\r\n// Read operations only\r\nvar product1 = await view.GetAsync(tx, new Product { Id = 1 });\r\nvar product2 = await view.GetAsync(tx, new Product { Id = 2 });\r\n\r\n// No commit needed for read-only transactions\r\n// Transaction automatically closes on dispose\n'})}),"\n",(0,r.jsx)(e.p,{children:"Read-only transactions can provide performance benefits and prevent accidental modifications."}),"\n",(0,r.jsx)(e.h3,{id:"transaction-timeout",children:"Transaction Timeout"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var options = new TransactionOptions(ReadOnly: false, TimeoutMillis: 30000);\r\n\r\nawait using var tx = await client.Transactions.BeginAsync(options);\r\n\r\ntry\r\n{\r\n    // Perform operations\r\n    var table = await client.Tables.GetTableAsync("data");\r\n    var view = table.GetRecordView<DataRecord>();\r\n\r\n    // ... operations ...\r\n\r\n    await tx.CommitAsync();\r\n}\r\ncatch (IgniteException ex)\r\n{\r\n    Console.WriteLine($"Transaction timeout or conflict: {ex.Message}");\r\n    throw;\r\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(e.h3,{id:"itransactions-interface",children:"ITransactions Interface"}),"\n",(0,r.jsx)(e.p,{children:"Methods:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ValueTask<ITransaction> BeginAsync()"})," - Begin new transaction with default options"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ValueTask<ITransaction> BeginAsync(TransactionOptions options)"})," - Begin new transaction with specified options"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task<T> RunInTransactionAsync<T>(Func<ITransaction, Task<T>> func, TransactionOptions options = default)"})," - Execute function within transaction and return result"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task RunInTransactionAsync(Func<ITransaction, Task> func, TransactionOptions options = default)"})," - Execute function within transaction (no return value)"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The RunInTransactionAsync methods handle transaction lifecycle automatically. They commit on successful completion and roll back on exceptions. The transaction is disposed after the function completes."}),"\n",(0,r.jsx)(e.h3,{id:"itransaction-interface",children:"ITransaction Interface"}),"\n",(0,r.jsx)(e.p,{children:"Properties:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"bool IsReadOnly"})," - Whether transaction is read-only"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Methods:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task CommitAsync()"})," - Commit the transaction, making all changes permanent"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Task RollbackAsync()"})," - Roll back the transaction, discarding all changes"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Resource management:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Implements ",(0,r.jsx)(e.strong,{children:"IAsyncDisposable"})," and ",(0,r.jsx)(e.strong,{children:"IDisposable"})]}),"\n",(0,r.jsx)(e.li,{children:"Must be disposed after use"}),"\n",(0,r.jsx)(e.li,{children:"Automatic rollback occurs if disposed without explicit commit"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"transactionoptions-record-struct",children:"TransactionOptions Record Struct"}),"\n",(0,r.jsx)(e.p,{children:"A readonly record struct that configures transaction behavior. Construct using named parameters:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"new TransactionOptions(ReadOnly: true)\r\nnew TransactionOptions(ReadOnly: false, TimeoutMillis: 30000)\n"})}),"\n",(0,r.jsx)(e.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ReadOnly"})," (bool) - Mark transaction as read-only (default: false). Read-only transactions provide a snapshot view of data at a certain point in time. They are lock-free and perform better than normal transactions, but do not permit data modifications."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"TimeoutMillis"})," (long) - Transaction timeout in milliseconds (default: 0). A value of 0 means use the default timeout configured via ignite.transaction.timeout configuration property."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The timeout controls how long the transaction can remain active before automatic rollback."}),"\n",(0,r.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Always dispose transactions"})," using using statements or explicit disposal. Undisposed transactions hold cluster resources."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Commit explicitly"})," before disposal. Implicit rollback on disposal can hide logic errors."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Keep transactions short"})," to reduce lock contention and improve throughput. Long-running transactions impact cluster performance."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Handle exceptions properly"})," to ensure rollback occurs when operations fail. Use try-catch blocks around transaction logic."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use RunInTransactionAsync"})," for simple cases where automatic lifecycle management is sufficient. This reduces boilerplate code and ensures proper cleanup."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Pass transaction to all operations"})," that should be coordinated. Mixing null and transaction parameters within related operations breaks atomicity."]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},28453:(n,e,a)=>{a.d(e,{R:()=>s,x:()=>c});var t=a(96540);const r={},i=t.createContext(r);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);