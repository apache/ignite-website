"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3144],{28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var i=n(96540);const t={},a=i.createContext(t);function s(e){const r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(a.Provider,{value:r},e.children)}},78827:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"develop/integrate/spring-data","title":"Spring Data Integration","description":"Apache Ignite 3 provides a Spring Data JDBC dialect that enables repository-based data access. Combined with Spring Boot\'s JDBC starter, this allows standard Spring Data repositories to work with Ignite tables through familiar patterns like CrudRepository and derived query methods.","source":"@site/docs/develop/integrate/spring-data.md","sourceDirName":"develop/integrate","slug":"/develop/integrate/spring-data","permalink":"/docs/ignite3/3.1.0/develop/integrate/spring-data","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"spring-data","title":"Spring Data Integration"},"sidebar":"tutorialSidebar","previous":{"title":"Spring Boot Integration","permalink":"/docs/ignite3/3.1.0/develop/integrate/spring-boot"},"next":{"title":"SQL","permalink":"/docs/ignite3/3.1.0/sql/"}}');var t=n(74848),a=n(28453);const s={id:"spring-data",title:"Spring Data Integration"},o=void 0,d={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation",id:"installation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Datasource Properties",id:"datasource-properties",level:3},{value:"SQL Dialect Registration",id:"sql-dialect-registration",level:3},{value:"Application Setup",id:"application-setup",level:2},{value:"Defining Entities",id:"defining-entities",level:2},{value:"Repository Definition",id:"repository-definition",level:2},{value:"CRUD Operations",id:"crud-operations",level:2},{value:"Derived Query Methods",id:"derived-query-methods",level:2},{value:"Custom Queries",id:"custom-queries",level:2},{value:"Pagination",id:"pagination",level:2},{value:"Query by Example",id:"query-by-example",level:2},{value:"Handling Entity State",id:"handling-entity-state",level:2},{value:"Supported Features",id:"supported-features",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["Apache Ignite 3 provides a Spring Data JDBC dialect that enables repository-based data access. Combined with Spring Boot's JDBC starter, this allows standard Spring Data repositories to work with Ignite tables through familiar patterns like ",(0,t.jsx)(r.code,{children:"CrudRepository"})," and derived query methods."]}),"\n",(0,t.jsx)(r.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Java 17 or later"}),"\n",(0,t.jsx)(r.li,{children:"Spring Boot 3.x with Spring Data JDBC"}),"\n",(0,t.jsx)(r.li,{children:"Running Ignite 3 cluster"}),"\n",(0,t.jsx)(r.li,{children:"Tables created in Ignite before repository operations"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(r.p,{children:"Spring Data integration requires three dependencies:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"spring-boot-starter-data-jdbc"})," (from Spring) provides the Spring Data JDBC framework"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"spring-data-ignite"})," (from Apache Ignite) provides the SQL dialect for Ignite-compatible query generation"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"ignite-jdbc"})," (from Apache Ignite) provides the JDBC driver for database connectivity"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"The Ignite artifact versions must match your Apache Ignite cluster version."}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Maven:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-xml",children:"<properties>\r\n    <ignite.version>3.1.0</ignite.version>\r\n</properties>\r\n\r\n\x3c!-- Spring Data JDBC framework --\x3e\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-data-jdbc</artifactId>\r\n</dependency>\r\n\r\n\x3c!-- Ignite SQL dialect for Spring Data --\x3e\r\n<dependency>\r\n    <groupId>org.apache.ignite</groupId>\r\n    <artifactId>spring-data-ignite</artifactId>\r\n    <version>${ignite.version}</version>\r\n</dependency>\r\n\r\n\x3c!-- Ignite JDBC driver --\x3e\r\n<dependency>\r\n    <groupId>org.apache.ignite</groupId>\r\n    <artifactId>ignite-jdbc</artifactId>\r\n    <version>${ignite.version}</version>\r\n</dependency>\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Gradle:"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-groovy",children:"ext {\r\n    igniteVersion = '3.1.0'\r\n}\r\n\r\n// Spring Data JDBC framework\r\nimplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\r\n\r\n// Ignite SQL dialect for Spring Data\r\nimplementation \"org.apache.ignite:spring-data-ignite:${igniteVersion}\"\r\n\r\n// Ignite JDBC driver\r\nimplementation \"org.apache.ignite:ignite-jdbc:${igniteVersion}\"\n"})}),"\n",(0,t.jsx)(r.admonition,{title:"Version Matching",type:"note",children:(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"spring-data-ignite"})," and ",(0,t.jsx)(r.code,{children:"ignite-jdbc"})," artifacts are released as part of Apache Ignite, so their versions match the Ignite release version. For Ignite 3.1.0, use version ",(0,t.jsx)(r.code,{children:"3.1.0"})," for both artifacts."]})}),"\n",(0,t.jsx)(r.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(r.h3,{id:"datasource-properties",children:"Datasource Properties"}),"\n",(0,t.jsxs)(r.p,{children:["Configure the JDBC datasource in ",(0,t.jsx)(r.code,{children:"application.properties"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-properties",children:"spring.datasource.url=jdbc:ignite:thin://localhost:10800\r\nspring.datasource.driver-class-name=org.apache.ignite.jdbc.IgniteJdbcDriver\n"})}),"\n",(0,t.jsx)(r.p,{children:"For multiple nodes:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-properties",children:"spring.datasource.url=jdbc:ignite:thin://node1:10800,node2:10800,node3:10800\n"})}),"\n",(0,t.jsx)(r.h3,{id:"sql-dialect-registration",children:"SQL Dialect Registration"}),"\n",(0,t.jsxs)(r.p,{children:["Spring Data JDBC needs to generate database-specific SQL for operations like pagination, identity columns, and certain functions. The ",(0,t.jsx)(r.code,{children:"spring-data-ignite"})," artifact includes an ",(0,t.jsx)(r.code,{children:"IgniteDialectProvider"})," that teaches Spring Data how to generate Ignite-compatible SQL."]}),"\n",(0,t.jsxs)(r.p,{children:["The dialect provider is registered via Spring's SPI mechanism. Create the file ",(0,t.jsx)(r.code,{children:"src/main/resources/META-INF/spring.factories"})," with the following content:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-properties",children:"org.springframework.data.jdbc.repository.config.DialectResolver$JdbcDialectProvider=org.apache.ignite.data.IgniteDialectProvider\n"})}),"\n",(0,t.jsx)(r.p,{children:"Without this configuration, Spring Data falls back to generic ANSI SQL, which works for basic queries but may fail for database-specific operations."}),"\n",(0,t.jsx)(r.h2,{id:"application-setup",children:"Application Setup"}),"\n",(0,t.jsx)(r.p,{children:"Enable JDBC repositories in your Spring Boot application:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"@EnableJdbcRepositories\r\n@SpringBootApplication\r\npublic class MyApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(MyApplication.class, args);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"defining-entities",children:"Defining Entities"}),"\n",(0,t.jsx)(r.p,{children:"Entities map to Ignite tables. Use Spring Data annotations to define the mapping:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'import org.springframework.data.annotation.Id;\r\nimport org.springframework.data.relational.core.mapping.Column;\r\nimport org.springframework.data.relational.core.mapping.Table;\r\n\r\n@Table("PERSON")\r\npublic class Person {\r\n\r\n    @Id\r\n    private Long id;\r\n    private String name;\r\n    private String email;\r\n\r\n    @Column("COUNTRYCODE")\r\n    private String countryCode;  // Maps to COUNTRYCODE column\r\n\r\n    public Person() {}\r\n\r\n    public Person(Long id, String name, String email, String countryCode) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n        this.countryCode = countryCode;\r\n    }\r\n\r\n    // Getters and setters\r\n    public Long getId() { return id; }\r\n    public void setId(Long id) { this.id = id; }\r\n    public String getName() { return name; }\r\n    public void setName(String name) { this.name = name; }\r\n    public String getEmail() { return email; }\r\n    public void setEmail(String email) { this.email = email; }\r\n    public String getCountryCode() { return countryCode; }\r\n    public void setCountryCode(String countryCode) { this.countryCode = countryCode; }\r\n}\n'})}),"\n",(0,t.jsx)(r.p,{children:"Create the corresponding table in Ignite before using the repository:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-sql",children:"CREATE TABLE PERSON (\r\n    id BIGINT PRIMARY KEY,\r\n    name VARCHAR,\r\n    email VARCHAR,\r\n    COUNTRYCODE VARCHAR\r\n);\n"})}),"\n",(0,t.jsx)(r.p,{children:"Key annotations:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"@Table"})," maps the class to a specific table name"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"@Id"})," marks the primary key field"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"@Column"})," maps a field to a column when names differ (Java's ",(0,t.jsx)(r.code,{children:"countryCode"})," to SQL's ",(0,t.jsx)(r.code,{children:"COUNTRYCODE"}),"). Fields without ",(0,t.jsx)(r.code,{children:"@Column"})," map by convention based on field name."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"repository-definition",children:"Repository Definition"}),"\n",(0,t.jsxs)(r.p,{children:["Define a repository interface extending ",(0,t.jsx)(r.code,{children:"CrudRepository"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"import org.springframework.data.repository.CrudRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository\r\npublic interface PersonRepository extends CrudRepository<Person, Long> {\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"crud-operations",children:"CRUD Operations"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"CrudRepository"})," interface provides standard data access methods:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"@Service\r\npublic class PersonService {\r\n\r\n    private final PersonRepository repository;\r\n\r\n    public PersonService(PersonRepository repository) {\r\n        this.repository = repository;\r\n    }\r\n\r\n    public Person save(Person person) {\r\n        return repository.save(person);\r\n    }\r\n\r\n    public Optional<Person> findById(Long id) {\r\n        return repository.findById(id);\r\n    }\r\n\r\n    public Iterable<Person> findAll() {\r\n        return repository.findAll();\r\n    }\r\n\r\n    public void deleteById(Long id) {\r\n        repository.deleteById(id);\r\n    }\r\n\r\n    public long count() {\r\n        return repository.count();\r\n    }\r\n\r\n    public boolean existsById(Long id) {\r\n        return repository.existsById(id);\r\n    }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"derived-query-methods",children:"Derived Query Methods"}),"\n",(0,t.jsx)(r.p,{children:"Spring Data generates queries from method names:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"@Repository\r\npublic interface PersonRepository extends CrudRepository<Person, Long> {\r\n\r\n    // SELECT * FROM PERSON WHERE name = ?\r\n    List<Person> findByName(String name);\r\n\r\n    // SELECT * FROM PERSON WHERE name LIKE '%value%'\r\n    List<Person> findByNameContains(String namePart);\r\n\r\n    // SELECT * FROM PERSON WHERE email = ?\r\n    Optional<Person> findByEmail(String email);\r\n\r\n    // SELECT COUNT(*) FROM PERSON WHERE name = ?\r\n    int countByName(String name);\r\n\r\n    // SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END FROM PERSON WHERE name = ?\r\n    boolean existsByName(String name);\r\n\r\n    // SELECT * FROM PERSON WHERE name IN (?, ?, ...)\r\n    List<Person> findByNameIn(Collection<String> names);\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"custom-queries",children:"Custom Queries"}),"\n",(0,t.jsxs)(r.p,{children:["Use ",(0,t.jsx)(r.code,{children:"@Query"})," for explicit SQL:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'import org.springframework.data.jdbc.repository.query.Query;\r\nimport org.springframework.data.repository.query.Param;\r\n\r\n@Repository\r\npublic interface PersonRepository extends CrudRepository<Person, Long> {\r\n\r\n    @Query("SELECT * FROM PERSON WHERE name = :name AND email = :email")\r\n    Optional<Person> findByNameAndEmail(@Param("name") String name, @Param("email") String email);\r\n\r\n    @Query("SELECT * FROM PERSON WHERE name IN (:names)")\r\n    List<Person> findByNames(@Param("names") Set<String> names);\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"pagination",children:"Pagination"}),"\n",(0,t.jsx)(r.p,{children:"Spring Data supports paginated queries:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"import org.springframework.data.domain.Page;\r\nimport org.springframework.data.domain.Pageable;\r\nimport org.springframework.data.domain.Slice;\r\n\r\n@Repository\r\npublic interface PersonRepository extends CrudRepository<Person, Long> {\r\n\r\n    // Returns Page with total count\r\n    Page<Person> findByNameContains(String namePart, Pageable pageable);\r\n\r\n    // Returns Slice without total count (more efficient for large datasets)\r\n    Slice<Person> findSliceByNameContains(String namePart, Pageable pageable);\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Usage:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'@Service\r\npublic class PersonService {\r\n\r\n    private final PersonRepository repository;\r\n\r\n    public PersonService(PersonRepository repository) {\r\n        this.repository = repository;\r\n    }\r\n\r\n    public Page<Person> getPage(String namePart, int page, int size) {\r\n        PageRequest pageRequest = PageRequest.of(page, size, Sort.by("name"));\r\n        return repository.findByNameContains(namePart, pageRequest);\r\n    }\r\n\r\n    public void processAllPersons(String namePart) {\r\n        Pageable pageable = PageRequest.of(0, 100);\r\n        Slice<Person> slice;\r\n\r\n        do {\r\n            slice = repository.findSliceByNameContains(namePart, pageable);\r\n            slice.getContent().forEach(this::process);\r\n            pageable = slice.nextPageable();\r\n        } while (slice.hasNext());\r\n    }\r\n\r\n    private void process(Person person) {\r\n        // Process person\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"query-by-example",children:"Query by Example"}),"\n",(0,t.jsxs)(r.p,{children:["For dynamic queries based on entity instances, extend ",(0,t.jsx)(r.code,{children:"QueryByExampleExecutor"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"import org.springframework.data.repository.query.QueryByExampleExecutor;\r\n\r\n@Repository\r\npublic interface PersonRepository extends CrudRepository<Person, Long>, QueryByExampleExecutor<Person> {\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Usage:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'import org.springframework.data.domain.Example;\r\nimport org.springframework.data.domain.ExampleMatcher;\r\n\r\n@Service\r\npublic class PersonService {\r\n\r\n    private final PersonRepository repository;\r\n\r\n    public PersonService(PersonRepository repository) {\r\n        this.repository = repository;\r\n    }\r\n\r\n    public List<Person> findByExample(String name, String email) {\r\n        Person probe = new Person();\r\n        probe.setName(name);\r\n        probe.setEmail(email);\r\n\r\n        // Match non-null properties\r\n        Example<Person> example = Example.of(probe);\r\n        return (List<Person>) repository.findAll(example);\r\n    }\r\n\r\n    public List<Person> findByNameStartsWith(String prefix) {\r\n        Person probe = new Person();\r\n        probe.setName(prefix);\r\n\r\n        ExampleMatcher matcher = ExampleMatcher.matching()\r\n            .withMatcher("name", ExampleMatcher.GenericPropertyMatchers.startsWith())\r\n            .withIgnorePaths("id", "email");\r\n\r\n        Example<Person> example = Example.of(probe, matcher);\r\n        return (List<Person>) repository.findAll(example);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"handling-entity-state",children:"Handling Entity State"}),"\n",(0,t.jsxs)(r.p,{children:["Ignite tables do not auto-generate IDs. Implement ",(0,t.jsx)(r.code,{children:"Persistable"})," to control insert vs update behavior:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"import org.springframework.data.annotation.Id;\r\nimport org.springframework.data.annotation.Transient;\r\nimport org.springframework.data.domain.Persistable;\r\n\r\npublic class Person implements Persistable<Long> {\r\n\r\n    @Id\r\n    private Long id;\r\n    private String name;\r\n\r\n    @Transient\r\n    private boolean isNew = true;\r\n\r\n    @Override\r\n    public Long getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public boolean isNew() {\r\n        return isNew;\r\n    }\r\n\r\n    public void setNew(boolean newValue) {\r\n        this.isNew = newValue;\r\n    }\r\n\r\n    // After loading from database, mark as not new\r\n    public void markNotNew() {\r\n        this.isNew = false;\r\n    }\r\n\r\n    // Other getters and setters\r\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"When updating an existing entity:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'Person person = repository.findById(1L).orElseThrow();\r\nperson.setName("Updated Name");\r\nperson.setNew(false);  // Prevents INSERT, performs UPDATE\r\nrepository.save(person);\n'})}),"\n",(0,t.jsx)(r.h2,{id:"supported-features",children:"Supported Features"}),"\n",(0,t.jsx)(r.p,{children:"The Ignite dialect supports:"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Feature"}),(0,t.jsx)(r.th,{children:"Status"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"CrudRepository"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"PagingAndSortingRepository"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"QueryByExampleExecutor"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Derived query methods"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"@Query annotations"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Page and Slice"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Sort"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Limit"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Enum types"}),(0,t.jsx)(r.td,{children:"Supported"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"Array columns"}),(0,t.jsx)(r.td,{children:"Supported"})]})]})]}),"\n",(0,t.jsx)(r.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Ignite does not auto-generate primary keys. Provide ID values explicitly."}),"\n",(0,t.jsxs)(r.li,{children:["Locking clauses (",(0,t.jsx)(r.code,{children:"@Lock"}),") are not supported. The dialect returns empty lock clauses."]}),"\n",(0,t.jsx)(r.li,{children:"Single query loading for related entities is not supported. Related entities require separate queries."}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"./spring-boot",children:"Spring Boot Integration"})," - Auto-configured IgniteClient"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"../connect-to-ignite/jdbc",children:"JDBC Driver"})," - JDBC connection details"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.a,{href:"../../sql",children:"SQL Reference"})," - SQL syntax for table creation"]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);