"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3433],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}},88769:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api-reference/native-clients/dotnet/compute-api","title":"Compute API","description":"The Compute API executes distributed jobs across cluster nodes. Jobs run colocated with data for maximum performance, accessing the full Ignite API through an execution context.","source":"@site/docs/api-reference/native-clients/dotnet/compute-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/compute-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/compute-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Compute API","id":"compute-api","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Transactions API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/transactions-api"},"next":{"title":"Network API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/network-api"}}');var o=t(74848),s=t(28453);const i={title:"Compute API",id:"compute-api",sidebar_position:6},a="Compute API",c={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Job Targets",id:"job-targets",level:3},{value:"Broadcast Execution",id:"broadcast-execution",level:3},{value:"Execution Tracking",id:"execution-tracking",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Job Execution",id:"basic-job-execution",level:3},{value:"Job with Data Access",id:"job-with-data-access",level:3},{value:"Broadcast Execution",id:"broadcast-execution-1",level:3},{value:"Job with Custom Marshallers",id:"job-with-custom-marshallers",level:3},{value:"Monitoring Job Execution",id:"monitoring-job-execution",level:3},{value:"Changing Job Priority",id:"changing-job-priority",level:3},{value:"Colocated Execution",id:"colocated-execution",level:3},{value:"Exception Handling",id:"exception-handling",level:3},{value:"Cancellation Support",id:"cancellation-support",level:3},{value:"Reference",id:"reference",level:2},{value:"ICompute Interface",id:"icompute-interface",level:3},{value:"IComputeJob&lt;TArg, TResult&gt; Interface",id:"icomputejobtarg-tresult-interface",level:3},{value:"IJobExecutionContext Interface",id:"ijobexecutioncontext-interface",level:3},{value:"IJobExecution&lt;T&gt; Interface",id:"ijobexecutiont-interface",level:3},{value:"IJobTarget&lt;T&gt; Interface",id:"ijobtargett-interface",level:3},{value:"JobDescriptor&lt;TArg, TResult&gt; Class",id:"jobdescriptortarg-tresult-class",level:3},{value:"JobState Record",id:"jobstate-record",level:3},{value:"JobStatus Enum",id:"jobstatus-enum",level:3},{value:"Best Practices",id:"best-practices",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"compute-api",children:"Compute API"})}),"\n",(0,o.jsx)(n.p,{children:"The Compute API executes distributed jobs across cluster nodes. Jobs run colocated with data for maximum performance, accessing the full Ignite API through an execution context."}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(n.p,{children:"Compute jobs are C# classes deployed to the cluster that implement IComputeJob. Submit jobs for execution using the Compute API, which routes them to appropriate nodes based on the specified target."}),"\n",(0,o.jsx)(n.h3,{id:"job-targets",children:"Job Targets"}),"\n",(0,o.jsx)(n.p,{children:"Job targets control where jobs execute. Target by specific node, node name, or colocated partition to run jobs near data. The client routes job submissions to the appropriate cluster node based on the target."}),"\n",(0,o.jsx)(n.h3,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,o.jsx)(n.p,{children:"Broadcast jobs run on multiple nodes simultaneously. Use this pattern for operations that need to execute across the entire cluster or a subset of nodes."}),"\n",(0,o.jsx)(n.h3,{id:"execution-tracking",children:"Execution Tracking"}),"\n",(0,o.jsx)(n.p,{children:"Job submission returns an execution handle for monitoring progress and retrieving results. Query job state, change priority, or wait for completion through the execution interface."}),"\n",(0,o.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(n.h3,{id:"basic-job-execution",children:"Basic Job Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Define job class (must be deployed to cluster)\r\npublic class HelloJob : IComputeJob<string, string>\r\n{\r\n    public IMarshaller<string>? InputMarshaller => null;\r\n    public IMarshaller<string>? ResultMarshaller => null;\r\n\r\n    public async ValueTask<string> ExecuteAsync(\r\n        IJobExecutionContext context,\r\n        string arg,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        return $"Hello, {arg}!";\r\n    }\r\n}\r\n\r\n// Submit job\r\nvar compute = client.Compute;\r\nvar jobDescriptor = new JobDescriptor<string, string>(typeof(HelloJob));\r\n\r\nvar nodes = await client.GetClusterNodesAsync();\r\nvar target = JobTarget.Node(nodes[0]);\r\n\r\nvar execution = await compute.SubmitAsync(target, jobDescriptor, "World");\r\nvar result = await execution.GetResultAsync();\r\n\r\nConsole.WriteLine(result);  // "Hello, World!"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"job-with-data-access",children:"Job with Data Access"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class DataProcessingJob : IComputeJob<long, decimal>\r\n{\r\n    public IMarshaller<long>? InputMarshaller => null;\r\n    public IMarshaller<decimal>? ResultMarshaller => null;\r\n\r\n    public async ValueTask<decimal> ExecuteAsync(\r\n        IJobExecutionContext context,\r\n        long customerId,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Access Ignite APIs through context\r\n        var tables = context.Ignite.Tables;\r\n        var ordersTable = await tables.GetTableAsync("orders");\r\n        var view = ordersTable.GetRecordView<Order>();\r\n\r\n        // Execute SQL through context\r\n        var sql = context.Ignite.Sql;\r\n        var statement = new SqlStatement(\r\n            "SELECT SUM(amount) FROM orders WHERE customer_id = ?");\r\n        var resultSet = await sql.ExecuteAsync<SumResult>(\r\n            null, statement, customerId);\r\n\r\n        var sum = await resultSet.FirstOrDefaultAsync();\r\n        return sum?.Total ?? 0m;\r\n    }\r\n}\r\n\r\n// Submit job colocated with data\r\nvar compute = client.Compute;\r\nvar jobDescriptor = new JobDescriptor<long, decimal>(typeof(DataProcessingJob));\r\n\r\nvar target = JobTarget.Colocated("orders", 12345L);\r\nvar execution = await compute.SubmitAsync(target, jobDescriptor, 12345L);\r\nvar totalAmount = await execution.GetResultAsync();\r\n\r\nConsole.WriteLine($"Total orders: ${totalAmount}");\n'})}),"\n",(0,o.jsx)(n.h3,{id:"broadcast-execution-1",children:"Broadcast Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class DiagnosticsJob : IComputeJob<string, NodeInfo>\r\n{\r\n    public IMarshaller<string>? InputMarshaller => null;\r\n    public IMarshaller<NodeInfo>? ResultMarshaller => null;\r\n\r\n    public async ValueTask<NodeInfo> ExecuteAsync(\r\n        IJobExecutionContext context,\r\n        string arg,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Gather node information\r\n        return new NodeInfo\r\n        {\r\n            NodeName = Environment.MachineName,\r\n            Timestamp = DateTime.UtcNow,\r\n            MemoryUsed = GC.GetTotalMemory(false)\r\n        };\r\n    }\r\n}\r\n\r\n// Broadcast to all nodes\r\nvar compute = client.Compute;\r\nvar jobDescriptor = new JobDescriptor<string, NodeInfo>(typeof(DiagnosticsJob));\r\n\r\nvar nodes = await client.GetClusterNodesAsync();\r\nvar target = BroadcastTarget.Nodes(nodes);\r\n\r\nvar execution = await compute.SubmitBroadcastAsync(\r\n    target, jobDescriptor, "diagnostics");\r\n\r\n// Get results from all nodes\r\nforeach (var jobExecution in execution.JobExecutions)\r\n{\r\n    var nodeInfo = await jobExecution.GetResultAsync();\r\n    Console.WriteLine($"{nodeInfo.NodeName}: {nodeInfo.MemoryUsed} bytes");\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"job-with-custom-marshallers",children:"Job with Custom Marshallers"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class ComplexDataJob : IComputeJob<CustomInput, CustomOutput>\r\n{\r\n    // Provide custom serialization\r\n    public IMarshaller<CustomInput>? InputMarshaller => new CustomInputMarshaller();\r\n    public IMarshaller<CustomOutput>? ResultMarshaller => new CustomOutputMarshaller();\r\n\r\n    public async ValueTask<CustomOutput> ExecuteAsync(\r\n        IJobExecutionContext context,\r\n        CustomInput input,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        // Process complex input\r\n        return new CustomOutput\r\n        {\r\n            ProcessedData = input.RawData.Select(x => x * 2).ToList()\r\n        };\r\n    }\r\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"monitoring-job-execution",children:"Monitoring Job Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var compute = client.Compute;\r\nvar jobDescriptor = new JobDescriptor<string, string>(typeof(LongRunningJob));\r\n\r\nvar target = JobTarget.Node(nodes[0]);\r\nvar execution = await compute.SubmitAsync(target, jobDescriptor, "input");\r\n\r\n// Monitor job state\r\nwhile (true)\r\n{\r\n    var state = await execution.GetStateAsync();\r\n    if (state == null)\r\n    {\r\n        Console.WriteLine("Job information expired");\r\n        break;\r\n    }\r\n\r\n    Console.WriteLine($"Job state: {state.Status}");\r\n\r\n    if (state.Status == JobStatus.Completed ||\r\n        state.Status == JobStatus.Failed ||\r\n        state.Status == JobStatus.Canceled)\r\n    {\r\n        break;\r\n    }\r\n\r\n    await Task.Delay(1000);\r\n}\r\n\r\n// Get final result\r\ntry\r\n{\r\n    var result = await execution.GetResultAsync();\r\n    Console.WriteLine($"Result: {result}");\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Console.WriteLine($"Job failed: {ex.Message}");\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"changing-job-priority",children:"Changing Job Priority"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var execution = await compute.SubmitAsync(target, jobDescriptor, "input");\r\n\r\n// Increase priority\r\nvar changed = await execution.ChangePriorityAsync(10);\r\nif (changed == true)\r\n{\r\n    Console.WriteLine("Priority changed");\r\n}\r\nelse if (changed == false)\r\n{\r\n    Console.WriteLine("Job already executing or completed");\r\n}\r\nelse\r\n{\r\n    Console.WriteLine("Job not found (retention expired)");\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"colocated-execution",children:"Colocated Execution"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Execute job on node that owns the data\r\nvar compute = client.Compute;\r\nvar jobDescriptor = new JobDescriptor<long, ProcessingResult>(typeof(ColocatedProcessor));\r\n\r\n// Target partition that contains the key\r\nvar target = JobTarget.Colocated("customers", customerId);\r\nvar execution = await compute.SubmitAsync(target, jobDescriptor, customerId);\r\nvar result = await execution.GetResultAsync();\n'})}),"\n",(0,o.jsx)(n.p,{children:"Colocated execution minimizes network traffic by running jobs on the node that stores the data."}),"\n",(0,o.jsx)(n.h3,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'try\r\n{\r\n    var execution = await compute.SubmitAsync(target, jobDescriptor, "input");\r\n    var result = await execution.GetResultAsync();\r\n}\r\ncatch (IgniteException ex)\r\n{\r\n    Console.WriteLine($"Job execution failed: {ex.Message}");\r\n}\r\ncatch (TimeoutException ex)\r\n{\r\n    Console.WriteLine($"Job timed out: {ex.Message}");\r\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"cancellation-support",children:"Cancellation Support"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'using var cts = new CancellationTokenSource();\r\ncts.CancelAfter(TimeSpan.FromSeconds(30));\r\n\r\ntry\r\n{\r\n    var execution = await compute.SubmitAsync(\r\n        target, jobDescriptor, "input", cts.Token);\r\n    var result = await execution.GetResultAsync();\r\n}\r\ncatch (OperationCanceledException)\r\n{\r\n    Console.WriteLine("Job submission cancelled");\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsx)(n.h3,{id:"icompute-interface",children:"ICompute Interface"}),"\n",(0,o.jsx)(n.p,{children:"Job submission methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitAsync<TTarget, TArg, TResult>(IJobTarget<TTarget> target, JobDescriptor<TArg, TResult> jobDescriptor, TArg arg, CancellationToken cancellationToken)"})," - Submit job to target with cancellation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitAsync<TTarget, TArg, TResult>(IJobTarget<TTarget> target, JobDescriptor<TArg, TResult> jobDescriptor, TArg arg)"})," - Submit job to target"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Broadcast methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitBroadcastAsync<TTarget, TArg, TResult>(IBroadcastJobTarget<TTarget> target, JobDescriptor<TArg, TResult> jobDescriptor, TArg arg, CancellationToken cancellationToken)"})," - Broadcast job with cancellation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitBroadcastAsync<TTarget, TArg, TResult>(IBroadcastJobTarget<TTarget> target, JobDescriptor<TArg, TResult> jobDescriptor, TArg arg)"})," - Broadcast job"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Map-reduce methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitMapReduceAsync<TArg, TResult>(TaskDescriptor<TArg, TResult> taskDescriptor, TArg arg, CancellationToken cancellationToken)"})," - Submit map-reduce task with cancellation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"SubmitMapReduceAsync<TArg, TResult>(TaskDescriptor<TArg, TResult> taskDescriptor, TArg arg)"})," - Submit map-reduce task"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"icomputejobtarg-tresult-interface",children:"IComputeJob<TArg, TResult> Interface"}),"\n",(0,o.jsx)(n.p,{children:"Properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"InputMarshaller"})," - Optional custom marshaller for job arguments"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ResultMarshaller"})," - Optional custom marshaller for job results"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ExecuteAsync(IJobExecutionContext context, TArg arg, CancellationToken cancellationToken)"})," - Execute the job on the server"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Jobs must be deployed to cluster nodes before submission. The job implementation has full access to the Ignite API through the execution context."}),"\n",(0,o.jsx)(n.h3,{id:"ijobexecutioncontext-interface",children:"IJobExecutionContext Interface"}),"\n",(0,o.jsx)(n.p,{children:"Properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ignite"})," - Full Ignite API access for the server environment"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Use the context to access tables, execute SQL, start transactions, or perform other operations from within the job. All operations execute in the server context on the cluster node."}),"\n",(0,o.jsx)(n.h3,{id:"ijobexecutiont-interface",children:"IJobExecution<T> Interface"}),"\n",(0,o.jsx)(n.p,{children:"Properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Id"})," - Unique job identifier (Guid)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node"})," - Cluster node where job is executing"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Methods:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GetResultAsync()"})," - Wait for and retrieve job result"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"GetStateAsync()"})," - Get current job state (returns null if retention expired)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ChangePriorityAsync(int priority)"})," - Change job priority (returns true if changed, false if executing/completed, null if not found)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The execution handle tracks a submitted job. Use it to monitor progress, adjust priority, or wait for completion."}),"\n",(0,o.jsx)(n.h3,{id:"ijobtargett-interface",children:"IJobTarget<T> Interface"}),"\n",(0,o.jsx)(n.p,{children:"Properties:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Data"})," - Target data (node, partition, etc.)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Static factory methods (on JobTarget class):"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobTarget.Node(IClusterNode node)"})," - Target specific node"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobTarget.AnyNode(IEnumerable<IClusterNode> nodes)"})," - Target any node from collection"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobTarget.AnyNode(params IClusterNode[] nodes)"})," - Target any node from array"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobTarget.Colocated(string tableName, TKey key)"})," - Target partition containing key"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobTarget.Colocated(QualifiedName tableName, TKey key)"})," - Target partition containing key with qualified table name"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"jobdescriptortarg-tresult-class",children:"JobDescriptor<TArg, TResult> Class"}),"\n",(0,o.jsx)(n.p,{children:"Constructors:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobDescriptor(Type type)"})," - Create descriptor from job type implementing IComputeJob<TArg, TResult>"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"JobDescriptor(string jobClassName)"})," - Create descriptor with Java job class name for server-side execution"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The job type must implement IComputeJob<TArg, TResult>. Use the Type constructor for .NET jobs, or the string constructor for Java jobs on the server."}),"\n",(0,o.jsx)(n.h3,{id:"jobstate-record",children:"JobState Record"}),"\n",(0,o.jsx)(n.p,{children:"Job state information:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Id"})," - Job identifier (Guid)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Status"})," - Current job status (JobStatus enum)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CreateTime"})," - Job creation timestamp"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"StartTime"})," - Job start timestamp (null when not yet started)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"FinishTime"})," - Job completion timestamp (null when not yet finished)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"State information may expire based on cluster configuration. GetStateAsync returns null when state information is no longer available."}),"\n",(0,o.jsx)(n.h3,{id:"jobstatus-enum",children:"JobStatus Enum"}),"\n",(0,o.jsx)(n.p,{children:"Possible job status values:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Queued"})," - Job is submitted and waiting for execution start"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Executing"})," - Job is currently running"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Failed"})," - Job was unexpectedly terminated during execution"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Completed"})," - Job executed successfully and returned result"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Canceling"})," - Job received cancel command but is still running"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Canceled"})," - Job was successfully cancelled"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Deploy jobs before submission"}),". Jobs must exist on cluster nodes before the client can submit them."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use colocated execution"})," when jobs access specific data. This eliminates network transfers between compute and data nodes."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Keep jobs focused"}),". Each job should perform a specific task. Use multiple jobs for complex workflows."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Handle exceptions in jobs"}),". Unhandled exceptions fail the job and return errors to the client."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Consider job serialization"}),". Job arguments and results cross network boundaries. Use efficient serialization or custom marshallers for large data."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Monitor long-running jobs"}),". Use GetStateAsync to track progress and detect failures early."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);