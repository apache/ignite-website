"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9759],{13523:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"getting-started/migrate-from-3-0-to-3-1","title":"Migrating from Apache Ignite 3.0 to 3.1","description":"Overview","source":"@site/docs/getting-started/migrate-from-3-0-to-3-1.md","sourceDirName":"getting-started","slug":"/getting-started/migrate-from-3-0-to-3-1","permalink":"/docs/ignite3/3.1.0/getting-started/migrate-from-3-0-to-3-1","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Migrating from Apache Ignite 3.0 to 3.1","sidebar_label":"Migrate from 3.0 to 3.1"},"sidebar":"tutorialSidebar","previous":{"title":"Migrating from Ignite 2","permalink":"/docs/ignite3/3.1.0/getting-started/migrate-from-ignite-2"},"next":{"title":"Develop","permalink":"/docs/ignite3/3.1.0/develop/"}}');var i=t(74848),s=t(28453);const a={title:"Migrating from Apache Ignite 3.0 to 3.1",sidebar_label:"Migrate from 3.0 to 3.1"},l=void 0,o={},c=[{value:"Overview",id:"overview",level:2},{value:"Zone-Based Replication",id:"zone-based-replication",level:2},{value:"Table-Based vs Zone-Based Replication",id:"table-based-vs-zone-based-replication",level:3},{value:"Benefits of Zone-Based Replication",id:"benefits-of-zone-based-replication",level:3},{value:"Phase 1: Document Current Environment",id:"phase-1-document-current-environment",level:2},{value:"Step 1.1: Connect to 3.0 Cluster",id:"step-11-connect-to-30-cluster",level:3},{value:"Step 1.2: Document All Schemas",id:"step-12-document-all-schemas",level:3},{value:"Step 1.3: Document All Tables",id:"step-13-document-all-tables",level:3},{value:"Step 1.4: Document Table Schemas",id:"step-14-document-table-schemas",level:3},{value:"Step 1.5: Document Distribution Zones",id:"step-15-document-distribution-zones",level:3},{value:"Step 1.6: Calculate Data Volume",id:"step-16-calculate-data-volume",level:3},{value:"Step 1.7: Create Schema Recreation Script",id:"step-17-create-schema-recreation-script",level:3},{value:"Phase 2: Export Data from 3.0 Cluster",id:"phase-2-export-data-from-30-cluster",level:2},{value:"Step 2.1: Create Export Directory",id:"step-21-create-export-directory",level:3},{value:"Step 2.2: Choose Export Format",id:"step-22-choose-export-format",level:3},{value:"Step 2.3: Export Table Data",id:"step-23-export-table-data",level:3},{value:"CSV Export",id:"csv-export",level:4},{value:"Parquet Export (Recommended)",id:"parquet-export-recommended",level:4},{value:"Step 2.4: Automate Exports with Script",id:"step-24-automate-exports-with-script",level:3},{value:"Step 2.5: Verify Exports",id:"step-25-verify-exports",level:3},{value:"Step 2.6: Stop 3.0 Cluster",id:"step-26-stop-30-cluster",level:3},{value:"Phase 3: Set Up 3.1 Cluster",id:"phase-3-set-up-31-cluster",level:2},{value:"Step 3.1: Download Apache Ignite 3.1",id:"step-31-download-apache-ignite-31",level:3},{value:"Step 3.2: Configure Cluster Nodes",id:"step-32-configure-cluster-nodes",level:3},{value:"Configuration Changes in 3.1",id:"configuration-changes-in-31",level:4},{value:"Step 3.3: Start Cluster Nodes",id:"step-33-start-cluster-nodes",level:3},{value:"Step 3.4: Initialize the Cluster",id:"step-34-initialize-the-cluster",level:3},{value:"Step 3.5: Verify Cluster Topology",id:"step-35-verify-cluster-topology",level:3},{value:"Step 3.6: Recreate Schemas",id:"step-36-recreate-schemas",level:3},{value:"Step 3.7: Recreate Distribution Zones",id:"step-37-recreate-distribution-zones",level:3},{value:"Step 3.8: Recreate Tables",id:"step-38-recreate-tables",level:3},{value:"Phase 4: Import Data into 3.1 Cluster",id:"phase-4-import-data-into-31-cluster",level:2},{value:"Step 4.1: Import Individual Tables",id:"step-41-import-individual-tables",level:3},{value:"CSV Import",id:"csv-import",level:4},{value:"Parquet Import (Recommended)",id:"parquet-import-recommended",level:4},{value:"Step 4.2: Automate Imports with Script",id:"step-42-automate-imports-with-script",level:3},{value:"Step 4.3: Verify Data Integrity",id:"step-43-verify-data-integrity",level:3},{value:"Row Count Verification",id:"row-count-verification",level:4},{value:"Data Sampling",id:"data-sampling",level:4},{value:"Create Verification Script",id:"create-verification-script",level:4},{value:"Phase 5: Update Client Applications",id:"phase-5-update-client-applications",level:2},{value:"Step 5.1: Update Connection Configuration",id:"step-51-update-connection-configuration",level:3},{value:"Step 5.2: Review API Changes",id:"step-52-review-api-changes",level:3},{value:"Java API Changes",id:"java-api-changes",level:4},{value:"Step 5.3: Test Client Connectivity",id:"step-53-test-client-connectivity",level:3},{value:"Phase 6: Post-Migration Verification",id:"phase-6-post-migration-verification",level:2},{value:"Step 6.1: Verify Zone-Based Replication",id:"step-61-verify-zone-based-replication",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This guide provides step-by-step instructions for migrating Apache Ignite clusters from version 3.0 to version 3.1. Due to architectural changes in 3.1, including the introduction of zone-based replication, migration requires creating a new 3.1 cluster and migrating data using the export/import process."}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"This migration requires cluster downtime."})}),"\n",(0,i.jsx)(n.h2,{id:"zone-based-replication",children:"Zone-Based Replication"}),"\n",(0,i.jsx)(n.p,{children:"Apache Ignite 3.1 introduces zone-based replication, replacing the table-based replication model from version 3.0. Table-based replication is still supported, however it will be dropped in a later release."}),"\n",(0,i.jsx)(n.h3,{id:"table-based-vs-zone-based-replication",children:"Table-Based vs Zone-Based Replication"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"3.0 Table-Based"}),(0,i.jsx)(n.th,{children:"3.1 Zone-Based"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RAFT Groups"}),(0,i.jsx)(n.td,{children:"Each table creates separate RAFT groups"}),(0,i.jsx)(n.td,{children:"Tables in same zone share RAFT groups"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Example (100 tables)"}),(0,i.jsx)(n.td,{children:"100 separate RAFT group sets"}),(0,i.jsx)(n.td,{children:"1 shared RAFT group set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Memory Footprint"}),(0,i.jsx)(n.td,{children:"Higher with more tables"}),(0,i.jsx)(n.td,{children:"Significantly reduced"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Thread Overhead"}),(0,i.jsx)(n.td,{children:"Higher (more RAFT groups)"}),(0,i.jsx)(n.td,{children:"Lower (fewer RAFT groups)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-zone-based-replication",children:"Benefits of Zone-Based Replication"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced Memory Footprint:"})," Fewer RAFT groups means lower memory consumption for clusters with many tables"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lower Thread Overhead:"})," Decreased number of RAFT groups reduces thread management complexity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Improved Performance:"})," Better resource utilization for multi-table workloads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transparent Migration:"})," No changes to user-facing APIs or query behavior"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Zone-based replication is an internal cluster optimization. Your applications will continue to work without code changes."})}),"\n",(0,i.jsx)(n.h2,{id:"phase-1-document-current-environment",children:"Phase 1: Document Current Environment"}),"\n",(0,i.jsx)(n.h3,{id:"step-11-connect-to-30-cluster",children:"Step 1.1: Connect to 3.0 Cluster"}),"\n",(0,i.jsx)(n.p,{children:"Connect to your Apache Ignite 3.0 cluster using the CLI tool:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ignite3-cli-3.0.0/bin\r\n./ignite3\n"})}),"\n",(0,i.jsx)(n.p,{children:"Once connected, enter sql execution mode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"sql\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-12-document-all-schemas",children:"Step 1.2: Document All Schemas"}),"\n",(0,i.jsx)(n.p,{children:"List all schemas in your cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- List all schemas\r\nSELECT * FROM SYSTEM.SCHEMAS;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save the output to a file for reference during schema recreation."}),"\n",(0,i.jsx)(n.h3,{id:"step-13-document-all-tables",children:"Step 1.3: Document All Tables"}),"\n",(0,i.jsx)(n.p,{children:"List all tables across all schemas:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- List all tables\r\nSELECT SCHEMA_NAME, TABLE_NAME\r\nFROM SYSTEM.TABLES\r\nWHERE TABLE_TYPE = 'TABLE'\r\nORDER BY SCHEMA_NAME, TABLE_NAME;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save the output to a file for reference during table recreation."}),"\n",(0,i.jsx)(n.h3,{id:"step-14-document-table-schemas",children:"Step 1.4: Document Table Schemas"}),"\n",(0,i.jsx)(n.p,{children:"For each table, capture its complete schema definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Get detailed schema for each table\r\nSELECT\r\n  SCHEMA_NAME,\r\n  TABLE_NAME,\r\n  COLUMN_NAME,\r\n  TYPE,\r\n  NULLABLE,\r\n  COLUMN_DEFAULT\r\nFROM SYSTEM.TABLE_COLUMNS\r\nWHERE SCHEMA_NAME = 'YOUR_SCHEMA'\r\nORDER BY TABLE_NAME, ORDINAL_POSITION;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save the output to a file for reference during schema recreation."}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Document the exact CREATE TABLE statements for all tables. You'll need these to recreate the schema in 3.1."})}),"\n",(0,i.jsx)(n.h3,{id:"step-15-document-distribution-zones",children:"Step 1.5: Document Distribution Zones"}),"\n",(0,i.jsx)(n.p,{children:"Capture current distribution zone configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Document distribution zones\r\nSELECT * FROM SYSTEM.ZONES;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save the output to a file for reference during schema recreation."}),"\n",(0,i.jsx)(n.h3,{id:"step-16-calculate-data-volume",children:"Step 1.6: Calculate Data Volume"}),"\n",(0,i.jsx)(n.p,{children:"Estimate the size of data to be migrated:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Get row count for each table\r\nSELECT\r\n  TABLE_NAME,\r\n  COUNT(*) as ROW_COUNT\r\nFROM your_table\r\nGROUP BY TABLE_NAME;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save row counts for each table. You'll use these to verify data integrity after migration."}),"\n",(0,i.jsx)(n.h3,{id:"step-17-create-schema-recreation-script",children:"Step 1.7: Create Schema Recreation Script"}),"\n",(0,i.jsxs)(n.p,{children:["Create a SQL script file named ",(0,i.jsx)(n.code,{children:"schema-recreation.sql"})," containing all CREATE TABLE statements:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Example for a table:\r\nCREATE TABLE analytics.events (\r\n  id INT PRIMARY KEY,\r\n  event_time TIMESTAMP NOT NULL,\r\n  user_id VARCHAR(100),\r\n  event_type VARCHAR(50),\r\n  payload VARCHAR(4000)\r\n) WITH (\r\n  -- Document any table options here\r\n);\r\n\r\n-- Repeat for all tables\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save the output to a file for reference during schema recreation."}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Ensure your CREATE TABLE statements include all constraints, indexes, and table options. Missing configuration can lead to performance or data integrity issues."})}),"\n",(0,i.jsx)(n.h2,{id:"phase-2-export-data-from-30-cluster",children:"Phase 2: Export Data from 3.0 Cluster"}),"\n",(0,i.jsx)(n.h3,{id:"step-21-create-export-directory",children:"Step 2.1: Create Export Directory"}),"\n",(0,i.jsx)(n.p,{children:"Create a directory for export files on accessible storage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir -p /backup/ignite-3.0-export\r\nchmod 755 /backup/ignite-3.0-export\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"If using shared network storage, ensure all nodes have write access to this location."})}),"\n",(0,i.jsx)(n.h3,{id:"step-22-choose-export-format",children:"Step 2.2: Choose Export Format"}),"\n",(0,i.jsx)(n.p,{children:"Apache Ignite supports two export formats:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Format"}),(0,i.jsx)(n.th,{children:"Advantages"}),(0,i.jsx)(n.th,{children:"Best For"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"CSV"})}),(0,i.jsx)(n.td,{children:"Human-readable, easy to debug, compatible with many tools"}),(0,i.jsx)(n.td,{children:"Small to medium datasets, troubleshooting"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Parquet"})}),(0,i.jsx)(n.td,{children:"Compressed, faster I/O, efficient for large datasets"}),(0,i.jsx)(n.td,{children:"Large datasets, production migrations"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"step-23-export-table-data",children:"Step 2.3: Export Table Data"}),"\n",(0,i.jsxs)(n.p,{children:["Export each table using the ",(0,i.jsx)(n.code,{children:"COPY INTO"})," command."]}),"\n",(0,i.jsx)(n.h4,{id:"csv-export",children:"CSV Export"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Export with headers for easier import\r\nCOPY FROM (SELECT * FROM analytics.events)\r\nINTO '/backup/ignite-3.0-export/analytics_events.csv'\r\nFORMAT CSV\r\nWITH 'header'='true';\n"})}),"\n",(0,i.jsx)(n.p,{children:"For large tables, export in chunks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Export in chunks by partition\r\nCOPY FROM (SELECT * FROM analytics.events WHERE id BETWEEN 0 AND 1000000)\r\nINTO '/backup/ignite-3.0-export/analytics_events_part1.csv'\r\nFORMAT CSV\r\nWITH 'header'='true';\n"})}),"\n",(0,i.jsx)(n.h4,{id:"parquet-export-recommended",children:"Parquet Export (Recommended)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"COPY FROM analytics.events (id, event_time, user_id, event_type, payload)\r\nINTO '/backup/ignite-3.0-export/analytics_events.parquet'\r\nFORMAT PARQUET;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-24-automate-exports-with-script",children:"Step 2.4: Automate Exports with Script"}),"\n",(0,i.jsx)(n.p,{children:"Create a shell script to export all tables automatically:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\r\n# export-all-tables.sh\r\n\r\nBACKUP_DIR="/backup/ignite-3.0-export"\r\n\r\n# Array of tables to export (schema.table format)\r\nTABLES=(\r\n  "analytics.events"\r\n  "analytics.users"\r\n  "sales.orders"\r\n  "sales.products"\r\n)\r\n\r\nfor table in "${TABLES[@]}"; do\r\n  schema=$(echo $table | cut -d\'.\' -f1)\r\n  tbl=$(echo $table | cut -d\'.\' -f2)\r\n\r\n  echo "Exporting ${table}..."\r\n\r\n  ignite sql "COPY FROM (SELECT * FROM ${table}) \\\r\n    INTO \'${BACKUP_DIR}/${schema}_${tbl}.parquet\' \\\r\n    FORMAT PARQUET"\r\n\r\n  if [ $? -eq 0 ]; then\r\n    echo "${table} exported successfully"\r\n\r\n    # Get row count for verification\r\n    ignite sql "SELECT COUNT(*) as row_count FROM ${table}" > "${BACKUP_DIR}/${schema}_${tbl}.count"\r\n  else\r\n    echo "Failed to export ${table}"\r\n    exit 1\r\n  fi\r\ndone\r\n\r\necho "Export complete. Files in ${BACKUP_DIR}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Make the script executable and run it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"chmod +x export-all-tables.sh\r\n./export-all-tables.sh\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-25-verify-exports",children:"Step 2.5: Verify Exports"}),"\n",(0,i.jsx)(n.p,{children:"Check that all export files were created successfully:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# List all export files\r\nls -lh /backup/ignite-3.0-export/\r\n\r\n# Verify file sizes are reasonable (not 0 bytes)\r\nfind /backup/ignite-3.0-export/ -size 0\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Do not proceed to the next phase until all exports are verified. Missing or corrupted export files will result in data loss."})}),"\n",(0,i.jsx)(n.h3,{id:"step-26-stop-30-cluster",children:"Step 2.6: Stop 3.0 Cluster"}),"\n",(0,i.jsx)(n.p,{children:"Once all exports are verified, gracefully stop all cluster nodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Stop all nodes gracefully\r\nignite node stop --node node1\r\nignite node stop --node node2\r\n...\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"After stopping the 3.0 cluster, do not delete any data until the migration is completely verified in the 3.1 cluster."})}),"\n",(0,i.jsx)(n.h2,{id:"phase-3-set-up-31-cluster",children:"Phase 3: Set Up 3.1 Cluster"}),"\n",(0,i.jsx)(n.h3,{id:"step-31-download-apache-ignite-31",children:"Step 3.1: Download Apache Ignite 3.1"}),"\n",(0,i.jsxs)(n.p,{children:["Download the Apache Ignite 3.1 distribution from the ",(0,i.jsx)(n.a,{href:"https://ignite.apache.org/download.cgi",children:"official website"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"step-32-configure-cluster-nodes",children:"Step 3.2: Configure Cluster Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Update your configuration files from 3.0 to 3.1 format:"}),"\n",(0,i.jsx)(n.h4,{id:"configuration-changes-in-31",children:"Configuration Changes in 3.1"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Change Type"}),(0,i.jsx)(n.th,{children:"3.0 Format"}),(0,i.jsx)(n.th,{children:"3.1 Format"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Timeout Properties"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"timeout=5000"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"timeoutMillis=5000"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Zone Creation"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"CREATE ZONE myZone WITH STORAGE_PROFILES='default', REPLICAS=3;"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"CREATE ZONE myZone (REPLICAS 3) STORAGE PROFILES['default'];"})})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Review the Apache Ignite 3.1 documentation for a complete list of configuration changes."})}),"\n",(0,i.jsx)(n.h3,{id:"step-33-start-cluster-nodes",children:"Step 3.3: Start Cluster Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Start each node in your cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Start each node (repeat for all nodes)\r\n./bin/ignite3 node start --config ignite-config.conf\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["By default, nodes load the configuration from ",(0,i.jsx)(n.code,{children:"etc/ignite-config.conf"}),". You can specify a different configuration file with the ",(0,i.jsx)(n.code,{children:"--config"})," parameter."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-34-initialize-the-cluster",children:"Step 3.4: Initialize the Cluster"}),"\n",(0,i.jsx)(n.p,{children:"Once all nodes are started, initialize the cluster from any node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ignite cluster init --name=ignite-cluster\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-35-verify-cluster-topology",children:"Step 3.5: Verify Cluster Topology"}),"\n",(0,i.jsx)(n.p,{children:"Confirm all nodes are part of the cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ignite cluster topology\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expected output should show all nodes in ACTIVE state:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[name=node1, address=192.168.1.10:10800, state=ACTIVE]\r\n[name=node2, address=192.168.1.11:10800, state=ACTIVE]\r\n...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-36-recreate-schemas",children:"Step 3.6: Recreate Schemas"}),"\n",(0,i.jsx)(n.p,{children:"Connect to the cluster and recreate all schemas:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create schemas\r\nCREATE SCHEMA analytics;\r\nCREATE SCHEMA sales;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-37-recreate-distribution-zones",children:"Step 3.7: Recreate Distribution Zones"}),"\n",(0,i.jsx)(n.p,{children:"If you have custom distribution zones, recreate them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Create distribution zones (if customized)\r\nCREATE ZONE analytics_zone (REPLICAS 3) STORAGE PROFILES['default'];\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-38-recreate-tables",children:"Step 3.8: Recreate Tables"}),"\n",(0,i.jsx)(n.p,{children:"Execute your saved schema recreation script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE analytics.events (\r\n  id INT PRIMARY KEY,\r\n  event_time TIMESTAMP NOT NULL,\r\n  user_id VARCHAR(100),\r\n  event_type VARCHAR(50),\r\n  payload VARCHAR(4000)\r\n);\r\n\r\n-- Repeat for all tables\n"})}),"\n",(0,i.jsx)(n.p,{children:"Verify each table was created correctly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Verify table creation\r\nSELECT * FROM SYSTEM.TABLES WHERE TABLE_NAME = 'EVENTS';\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Ensure table schemas in 3.1 exactly match the schemas from 3.0. Mismatches will cause import failures."})}),"\n",(0,i.jsx)(n.h2,{id:"phase-4-import-data-into-31-cluster",children:"Phase 4: Import Data into 3.1 Cluster"}),"\n",(0,i.jsx)(n.h3,{id:"step-41-import-individual-tables",children:"Step 4.1: Import Individual Tables"}),"\n",(0,i.jsxs)(n.p,{children:["Import data for each table using the ",(0,i.jsx)(n.code,{children:"COPY FROM"})," command."]}),"\n",(0,i.jsx)(n.h4,{id:"csv-import",children:"CSV Import"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"COPY FROM '/backup/ignite-3.0-export/analytics_events.csv'\r\nINTO analytics.events (id, event_time, user_id, event_type, payload)\r\nFORMAT CSV\r\nWITH 'header'='true', 'batchSize'='2048';\n"})}),"\n",(0,i.jsx)(n.h4,{id:"parquet-import-recommended",children:"Parquet Import (Recommended)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"COPY FROM '/backup/ignite-3.0-export/analytics_events.parquet'\r\nINTO analytics.events (id, event_time, user_id, event_type, payload)\r\nFORMAT PARQUET\r\nWITH 'batchSize'='2048';\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-42-automate-imports-with-script",children:"Step 4.2: Automate Imports with Script"}),"\n",(0,i.jsx)(n.p,{children:"Create a shell script to import all tables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\r\n# import-all-tables.sh\r\n\r\nBACKUP_DIR="/backup/ignite-3.0-export"\r\n\r\n# Array of tables to import\r\nTABLES=(\r\n  "analytics.events:id,event_time,user_id,event_type,payload"\r\n  "analytics.users:user_id,username,email,created_at"\r\n  "sales.orders:order_id,customer_id,order_date,total"\r\n  "sales.products:product_id,name,price,stock"\r\n)\r\n\r\nfor entry in "${TABLES[@]}"; do\r\n  table=$(echo $entry | cut -d\':\' -f1)\r\n  columns=$(echo $entry | cut -d\':\' -f2)\r\n  schema=$(echo $table | cut -d\'.\' -f1)\r\n  tbl=$(echo $table | cut -d\'.\' -f2)\r\n\r\n  echo "Importing ${table}..."\r\n\r\n  ignite sql "COPY FROM \'${BACKUP_DIR}/${schema}_${tbl}.parquet\' \\\r\n    INTO ${table} (${columns}) \\\r\n    FORMAT PARQUET \\\r\n    WITH \'batchSize\'=\'2048\'"\r\n\r\n  if [ $? -eq 0 ]; then\r\n    echo "${table} imported successfully"\r\n\r\n    # Verify row count\r\n    actual_count=$(ignite sql "SELECT COUNT(*) FROM ${table}" | grep -oE \'[0-9]+\')\r\n    expected_count=$(cat "${BACKUP_DIR}/${schema}_${tbl}.count" | grep -oE \'[0-9]+\')\r\n\r\n    if [ "$actual_count" == "$expected_count" ]; then\r\n      echo "Row count verified: ${actual_count}"\r\n    else\r\n      echo "Row count mismatch: expected ${expected_count}, got ${actual_count}"\r\n      exit 1\r\n    fi\r\n  else\r\n    echo "Failed to import ${table}"\r\n    exit 1\r\n  fi\r\ndone\r\n\r\necho "Import complete."\n'})}),"\n",(0,i.jsx)(n.p,{children:"Make the script executable and run it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"chmod +x import-all-tables.sh\r\n./import-all-tables.sh\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-43-verify-data-integrity",children:"Step 4.3: Verify Data Integrity"}),"\n",(0,i.jsx)(n.p,{children:"After imports complete, perform thorough verification:"}),"\n",(0,i.jsx)(n.h4,{id:"row-count-verification",children:"Row Count Verification"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Compare row counts\r\nSELECT COUNT(*) FROM analytics.events;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Compare with the saved row counts from your 3.0 cluster."}),"\n",(0,i.jsx)(n.h4,{id:"data-sampling",children:"Data Sampling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- Spot check data\r\nSELECT * FROM analytics.events LIMIT 10;\r\n\r\n-- Verify no NULL values in NOT NULL columns\r\nSELECT COUNT(*) FROM analytics.events\r\nWHERE event_time IS NULL;\r\n\r\n-- Check date ranges are preserved\r\nSELECT MIN(event_time), MAX(event_time)\r\nFROM analytics.events;\n"})}),"\n",(0,i.jsx)(n.h4,{id:"create-verification-script",children:"Create Verification Script"}),"\n",(0,i.jsx)(n.p,{children:"Automate verification across all tables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\r\n# verify-migration.sh\r\n\r\necho "=== Migration Verification Report ==="\r\necho\r\n\r\nTABLES=(\r\n  "analytics.events"\r\n  "analytics.users"\r\n  "sales.orders"\r\n  "sales.products"\r\n)\r\n\r\nBACKUP_DIR="/backup/ignite-3.0-export"\r\n\r\nfor table in "${TABLES[@]}"; do\r\n  schema=$(echo $table | cut -d\'.\' -f1)\r\n  tbl=$(echo $table | cut -d\'.\' -f2)\r\n\r\n  echo "Table: ${table}"\r\n\r\n  # Get current count\r\n  current=$(ignite sql "SELECT COUNT(*) FROM ${table}" | grep -oE \'[0-9]+\')\r\n  echo "  Current row count: ${current}"\r\n\r\n  # Get expected count\r\n  expected=$(cat "${BACKUP_DIR}/${schema}_${tbl}.count" | grep -oE \'[0-9]+\')\r\n  echo "  Expected row count: ${expected}"\r\n\r\n  if [ "$current" == "$expected" ]; then\r\n    echo "  Status: PASS"\r\n  else\r\n    echo "  Status: FAIL"\r\n  fi\r\n  echo\r\ndone\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Do not proceed with application cutover until all verification checks pass successfully."})}),"\n",(0,i.jsx)(n.h2,{id:"phase-5-update-client-applications",children:"Phase 5: Update Client Applications"}),"\n",(0,i.jsx)(n.h3,{id:"step-51-update-connection-configuration",children:"Step 5.1: Update Connection Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Update application configuration to point to the 3.1 cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-properties",children:"# Old 3.0 connection\r\nignite.endpoints=old-node1:10800,old-node2:10800,old-node3:10800\r\n\r\n# New 3.1 connection\r\nignite.endpoints=new-node1:10800,new-node2:10800,new-node3:10800\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-52-review-api-changes",children:"Step 5.2: Review API Changes"}),"\n",(0,i.jsx)(n.p,{children:"Check for deprecated APIs in your client code:"}),"\n",(0,i.jsx)(n.h4,{id:"java-api-changes",children:"Java API Changes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Deprecated in 3.1\r\nignite.clusterNodes()\r\n\r\n// Replace with\r\nignite.cluster().nodes()\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Refer to the Apache Ignite 3.1 release notes for a complete list of API changes: ",(0,i.jsx)(n.a,{href:"https://ignite.apache.org/releases/3.1.0/release_notes.html",children:"https://ignite.apache.org/releases/3.1.0/release_notes.html"})]})}),"\n",(0,i.jsx)(n.h3,{id:"step-53-test-client-connectivity",children:"Step 5.3: Test Client Connectivity"}),"\n",(0,i.jsx)(n.p,{children:"Before switching production traffic, test connectivity:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Connection test\r\ntry (IgniteClient client = IgniteClient.builder()\r\n    .addresses("new-node1:10800", "new-node2:10800", "new-node3:10800")\r\n    .build()) {\r\n\r\n    // Verify connectivity\r\n    Collection<ClusterNode> nodes = client.cluster().nodes();\r\n    System.out.println("Connected to " + nodes.size() + " nodes");\r\n\r\n    // Test data access\r\n    Table table = client.tables().table("analytics.events");\r\n    RecordView<Tuple> view = table.recordView();\r\n\r\n    Tuple record = view.get(null, Tuple.create().set("id", 1));\r\n    System.out.println("Sample record retrieved: " + record);\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Once the connection is confirmed, gradually migrate traffic."}),"\n",(0,i.jsx)(n.h2,{id:"phase-6-post-migration-verification",children:"Phase 6: Post-Migration Verification"}),"\n",(0,i.jsx)(n.h3,{id:"step-61-verify-zone-based-replication",children:"Step 6.1: Verify Zone-Based Replication"}),"\n",(0,i.jsx)(n.p,{children:"Confirm zone-based replication is active by checking cluster startup logs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Check node logs for confirmation\r\ngrep "Zone based replication" /path/to/node/logs/*.log\n'})}),"\n",(0,i.jsx)(n.p,{children:"Expected output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Zone based replication: true\n"})}),"\n",(0,i.jsx)(n.p,{children:"Verify zones are properly configured:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM SYSTEM.ZONES;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);