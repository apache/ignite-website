"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[675],{28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var r=t(96540);const i={},s=r.createContext(i);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),r.createElement(s.Provider,{value:e},n.children)}},57337:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api-reference/native-clients/cpp/transactions-api","title":"Transactions API","description":"The Transactions API provides explicit transaction control for operations across tables and SQL statements. Transactions ensure atomic, consistent, isolated, and durable data modifications.","source":"@site/docs/api-reference/native-clients/cpp/transactions-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/transactions-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/transactions-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Transactions API","id":"transactions-api","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"SQL API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/sql-api"},"next":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api"}}');var i=t(74848),s=t(28453);const a={title:"Transactions API",id:"transactions-api",sidebar_position:4},o="Transactions API",c={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:3},{value:"Explicit vs Implicit Transactions",id:"explicit-vs-implicit-transactions",level:3},{value:"Transaction Isolation",id:"transaction-isolation",level:3},{value:"Transaction Options",id:"transaction-options",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Beginning Transactions",id:"beginning-transactions",level:3},{value:"Committing Transactions",id:"committing-transactions",level:3},{value:"Rolling Back Transactions",id:"rolling-back-transactions",level:3},{value:"Table Operations",id:"table-operations",level:2},{value:"Using Transactions with Record Views",id:"using-transactions-with-record-views",level:3},{value:"Using Transactions with Key-Value Views",id:"using-transactions-with-key-value-views",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"SQL Operations",id:"sql-operations",level:2},{value:"Executing SQL in Transactions",id:"executing-sql-in-transactions",level:3},{value:"Cross-Table Transactions",id:"cross-table-transactions",level:3},{value:"Transaction Options",id:"transaction-options-1",level:2},{value:"Configuring Timeout",id:"configuring-timeout",level:3},{value:"Read-Only Transactions",id:"read-only-transactions",level:3},{value:"Chaining Options",id:"chaining-options",level:3},{value:"Transaction Visibility",id:"transaction-visibility",level:2},{value:"Uncommitted Changes",id:"uncommitted-changes",level:3},{value:"Isolation from Other Transactions",id:"isolation-from-other-transactions",level:3},{value:"Asynchronous Transactions",id:"asynchronous-transactions",level:2},{value:"Async Begin",id:"async-begin",level:3},{value:"Async Begin with Options",id:"async-begin-with-options",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Handling Commit Failures",id:"handling-commit-failures",level:3},{value:"Handling Operation Failures",id:"handling-operation-failures",level:3},{value:"Timeout Handling",id:"timeout-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Keep Transactions Short",id:"keep-transactions-short",level:3},{value:"Use Read-Only for Queries",id:"use-read-only-for-queries",level:3},{value:"Handle Errors Properly",id:"handle-errors-properly",level:3},{value:"Use RAII for Automatic Cleanup",id:"use-raii-for-automatic-cleanup",level:3},{value:"Reference",id:"reference",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"transactions-api",children:"Transactions API"})}),"\n",(0,i.jsx)(e.p,{children:"The Transactions API provides explicit transaction control for operations across tables and SQL statements. Transactions ensure atomic, consistent, isolated, and durable data modifications."}),"\n",(0,i.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(e.h3,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,i.jsx)(e.p,{children:"Transactions begin through the transactions factory. They remain active until committed or rolled back. Operations within a transaction see uncommitted changes from that transaction. Other transactions see data as it existed before the transaction started."}),"\n",(0,i.jsx)(e.h3,{id:"explicit-vs-implicit-transactions",children:"Explicit vs Implicit Transactions"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Explicit transactions"})," require manual commit or rollback. Pass the transaction pointer to operations. This provides control over transaction boundaries."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Implicit transactions"})," commit automatically after each operation. Pass ",(0,i.jsx)(e.code,{children:"nullptr"})," to operations for implicit transactions."]}),"\n",(0,i.jsx)(e.h3,{id:"transaction-isolation",children:"Transaction Isolation"}),"\n",(0,i.jsx)(e.p,{children:"Transactions use snapshot isolation. Each transaction sees a consistent snapshot of data from transaction start time. Changes within a transaction are visible to that transaction but not to others until commit."}),"\n",(0,i.jsx)(e.h3,{id:"transaction-options",children:"Transaction Options"}),"\n",(0,i.jsx)(e.p,{children:"Configure transaction behavior through options:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"timeout"})," - Maximum transaction duration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"read_only"})," - Optimize for read-only workloads"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsx)(e.h3,{id:"beginning-transactions",children:"Beginning Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Start a transaction with default options:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"using namespace ignite;\r\n\r\nauto transactions = client.get_transactions();\r\nauto tx = transactions.begin();\n"})}),"\n",(0,i.jsx)(e.p,{children:"Start with options:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_timeout_millis(30000);  // 30 seconds\r\nopts.set_read_only(false);\r\n\r\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,i.jsx)(e.p,{children:"Use async begin:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transactions.begin_async([](ignite_result<transaction> result) {\r\n    if (!result.has_error()) {\r\n        auto tx = std::move(result).value();\r\n        // Use transaction\r\n    }\r\n});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"committing-transactions",children:"Committing Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Commit to persist changes:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\r\n\r\n// Perform operations\r\ntx.commit();\n"})}),"\n",(0,i.jsx)(e.p,{children:"Use async commit:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'tx.commit_async([](ignite_result<void> result) {\r\n    if (!result.has_error()) {\r\n        std::cout << "Transaction committed" << std::endl;\r\n    }\r\n});\n'})}),"\n",(0,i.jsx)(e.h3,{id:"rolling-back-transactions",children:"Rolling Back Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Rollback to discard changes:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\r\n\r\ntry {\r\n    // Perform operations\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"Use async rollback:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'tx.rollback_async([](ignite_result<void> result) {\r\n    if (!result.has_error()) {\r\n        std::cout << "Transaction rolled back" << std::endl;\r\n    }\r\n});\n'})}),"\n",(0,i.jsx)(e.h2,{id:"table-operations",children:"Table Operations"}),"\n",(0,i.jsx)(e.h3,{id:"using-transactions-with-record-views",children:"Using Transactions with Record Views"}),"\n",(0,i.jsx)(e.p,{children:"Pass transaction pointer to record view operations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\nauto table = client.get_tables().get_table("accounts").value();\r\nauto view = table.get_record_binary_view();\r\n\r\ntry {\r\n    ignite_tuple record{\r\n        {"id", 42},\r\n        {"name", "John Doe"},\r\n        {"balance", 1000.0}\r\n    };\r\n\r\n    view.upsert(&tx, record);\r\n\r\n    auto retrieved = view.get(&tx, ignite_tuple{{"id", 42}});\r\n\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"using-transactions-with-key-value-views",children:"Using Transactions with Key-Value Views"}),"\n",(0,i.jsx)(e.p,{children:"Pass transaction to key-value operations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\nauto table = client.get_tables().get_table("accounts").value();\r\nauto view = table.get_key_value_binary_view();\r\n\r\ntry {\r\n    ignite_tuple key{{"id", 42}};\r\n    ignite_tuple value{{"name", "John Doe"}, {"balance", 1000.0}};\r\n\r\n    view.put(&tx, key, value);\r\n    auto retrieved = view.get(&tx, key);\r\n\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,i.jsx)(e.p,{children:"Batch operations execute within a transaction:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\nstd::vector<ignite_tuple> records{\r\n    {{"id", 1}, {"name", "Alice"}, {"balance", 1000.0}},\r\n    {{"id", 2}, {"name", "Bob"}, {"balance", 2000.0}},\r\n    {{"id", 3}, {"name", "Charlie"}, {"balance", 3000.0}}\r\n};\r\n\r\ntry {\r\n    view.upsert_all(&tx, records);\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"sql-operations",children:"SQL Operations"}),"\n",(0,i.jsx)(e.h3,{id:"executing-sql-in-transactions",children:"Executing SQL in Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Pass transaction to SQL operations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\ntry {\r\n    auto sql = client.get_sql();\r\n\r\n    sql.execute(&tx, nullptr,\r\n        sql_statement("INSERT INTO accounts VALUES (?, ?, ?)"),\r\n        {42, std::string("John Doe"), 1000.0});\r\n\r\n    sql.execute(&tx, nullptr,\r\n        sql_statement("UPDATE accounts SET balance = ? WHERE id = ?"),\r\n        {1500.0, 42});\r\n\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"cross-table-transactions",children:"Cross-Table Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Execute operations across multiple tables:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\ntry {\r\n    auto sql = client.get_sql();\r\n\r\n    // Debit from one account\r\n    sql.execute(&tx, nullptr,\r\n        sql_statement("UPDATE accounts SET balance = balance - ? WHERE id = ?"),\r\n        {100.0, 1});\r\n\r\n    // Credit to another account\r\n    sql.execute(&tx, nullptr,\r\n        sql_statement("UPDATE accounts SET balance = balance + ? WHERE id = ?"),\r\n        {100.0, 2});\r\n\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"transaction-options-1",children:"Transaction Options"}),"\n",(0,i.jsx)(e.h3,{id:"configuring-timeout",children:"Configuring Timeout"}),"\n",(0,i.jsx)(e.p,{children:"Set maximum transaction duration:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_timeout_millis(60000);  // 60 seconds\r\n\r\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,i.jsx)(e.p,{children:"Timeout of 0 means no timeout:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"opts.set_timeout_millis(0);  // No timeout\n"})}),"\n",(0,i.jsx)(e.h3,{id:"read-only-transactions",children:"Read-Only Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Optimize for read operations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_read_only(true);\r\n\r\nauto tx = transactions.begin(opts);\r\n\r\n// Only read operations allowed\r\nauto result = view.get(&tx, key);\r\n\r\ntx.commit();  // Lightweight commit for read-only\n"})}),"\n",(0,i.jsx)(e.p,{children:"Read-only transactions provide better performance by avoiding write locks and conflict detection."}),"\n",(0,i.jsx)(e.h3,{id:"chaining-options",children:"Chaining Options"}),"\n",(0,i.jsx)(e.p,{children:"Use fluent API to chain option setters:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_timeout_millis(30000)\r\n    .set_read_only(false);\r\n\r\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"transaction-visibility",children:"Transaction Visibility"}),"\n",(0,i.jsx)(e.h3,{id:"uncommitted-changes",children:"Uncommitted Changes"}),"\n",(0,i.jsx)(e.p,{children:"Changes are visible within the transaction:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\r\n\r\nview.upsert(&tx, record);\r\n\r\n// This sees the upserted record\r\nauto result = view.get(&tx, key);\r\n\r\n// Other transactions do not see it yet\n"})}),"\n",(0,i.jsx)(e.h3,{id:"isolation-from-other-transactions",children:"Isolation from Other Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Each transaction sees a consistent snapshot:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Transaction 1\r\nauto tx1 = transactions.begin();\r\nview.upsert(&tx1, record1);\r\n\r\n// Transaction 2 (concurrent)\r\nauto tx2 = transactions.begin();\r\nauto result = view.get(&tx2, key);  // Does not see record1\r\n\r\ntx1.commit();\r\n\r\n// Transaction 2 still does not see record1 (snapshot isolation)\r\nauto result2 = view.get(&tx2, key);  // Still does not see record1\n"})}),"\n",(0,i.jsx)(e.h2,{id:"asynchronous-transactions",children:"Asynchronous Transactions"}),"\n",(0,i.jsx)(e.h3,{id:"async-begin",children:"Async Begin"}),"\n",(0,i.jsx)(e.p,{children:"Start transactions asynchronously:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transactions.begin_async([&](ignite_result<transaction> result) {\r\n    if (!result.has_error()) {\r\n        auto tx = std::move(result).value();\r\n\r\n        view.upsert_async(&tx, record, [&](ignite_result<void> upsert_result) {\r\n            if (!upsert_result.has_error()) {\r\n                tx.commit_async([](ignite_result<void> commit_result) {\r\n                    // Transaction committed\r\n                });\r\n            }\r\n        });\r\n    }\r\n});\n"})}),"\n",(0,i.jsx)(e.h3,{id:"async-begin-with-options",children:"Async Begin with Options"}),"\n",(0,i.jsx)(e.p,{children:"Pass options to async begin:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_timeout_millis(30000);\r\n\r\ntransactions.begin_async(opts, [](ignite_result<transaction> result) {\r\n    // Use transaction\r\n});\n"})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(e.h3,{id:"handling-commit-failures",children:"Handling Commit Failures"}),"\n",(0,i.jsx)(e.p,{children:"Commit failures indicate conflicts or constraints:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = transactions.begin();\r\n\r\ntry {\r\n    view.upsert(&tx, record);\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    std::cerr << "Commit failed: " << e.what_str() << std::endl;\r\n    // Transaction already rolled back on commit failure\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"handling-operation-failures",children:"Handling Operation Failures"}),"\n",(0,i.jsx)(e.p,{children:"Roll back on operation errors:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'auto tx = transactions.begin();\r\n\r\ntry {\r\n    view.upsert(&tx, record1);\r\n    view.upsert(&tx, record2);  // May throw\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    std::cerr << "Operation failed: " << e.what_str() << std::endl;\r\n    throw;\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"timeout-handling",children:"Timeout Handling"}),"\n",(0,i.jsx)(e.p,{children:"Transactions time out after configured duration:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_timeout_millis(1000);  // 1 second\r\n\r\nauto tx = transactions.begin(opts);\r\n\r\ntry {\r\n    // Long-running operation\r\n    std::this_thread::sleep_for(std::chrono::seconds(2));\r\n    tx.commit();  // Will fail due to timeout\r\n} catch (const ignite_error& e) {\r\n    // Handle timeout error\r\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"keep-transactions-short",children:"Keep Transactions Short"}),"\n",(0,i.jsx)(e.p,{children:"Minimize transaction duration to reduce conflicts:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Good: Short transaction\r\nauto tx = transactions.begin();\r\nview.upsert(&tx, record);\r\ntx.commit();\r\n\r\n// Avoid: Long-running transaction\r\nauto tx2 = transactions.begin();\r\nperform_expensive_calculation();  // Do outside transaction\r\nview.upsert(&tx2, result);\r\ntx2.commit();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"use-read-only-for-queries",children:"Use Read-Only for Queries"}),"\n",(0,i.jsx)(e.p,{children:"Enable read-only optimization:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\r\nopts.set_read_only(true);\r\n\r\nauto tx = transactions.begin(opts);\r\nauto results = view.get_all(&tx, keys);\r\ntx.commit();\n"})}),"\n",(0,i.jsx)(e.h3,{id:"handle-errors-properly",children:"Handle Errors Properly"}),"\n",(0,i.jsx)(e.p,{children:"Always rollback on errors:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\r\nbool committed = false;\r\n\r\ntry {\r\n    // Operations\r\n    tx.commit();\r\n    committed = true;\r\n} catch (const ignite_error& e) {\r\n    if (!committed) {\r\n        tx.rollback();\r\n    }\r\n    throw;\r\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"use-raii-for-automatic-cleanup",children:"Use RAII for Automatic Cleanup"}),"\n",(0,i.jsx)(e.p,{children:"Wrap transactions in RAII helpers:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"class transaction_guard {\r\n    transaction& tx_;\r\n    bool committed_ = false;\r\n\r\npublic:\r\n    explicit transaction_guard(transaction& tx) : tx_(tx) {}\r\n\r\n    ~transaction_guard() {\r\n        if (!committed_) {\r\n            try {\r\n                tx_.rollback();\r\n            } catch (...) {\r\n                // Log error\r\n            }\r\n        }\r\n    }\r\n\r\n    void commit() {\r\n        tx_.commit();\r\n        committed_ = true;\r\n    }\r\n};\r\n\r\n// Usage\r\nauto tx = transactions.begin();\r\ntransaction_guard guard(tx);\r\n\r\nview.upsert(&tx, record);\r\nguard.commit();  // Automatic rollback if not committed\n"})}),"\n",(0,i.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"../../../develop/work-with-data/transactions",children:"Transactions Concept"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"./client-api",children:"Client API"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"./tables-api",children:"Tables API"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"./sql-api",children:"SQL API"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);