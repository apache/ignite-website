"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2108],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>i});var r=s(96540);const o={},t=r.createContext(o);function d(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),r.createElement(t.Provider,{value:n},e.children)}},90738:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"api-reference/native-clients/java/network-api","title":"Network API","description":"The Network API provides access to cluster topology information. Applications use this API to discover nodes, inspect network addresses, and access node metadata. This information supports compute job targeting, monitoring, and cluster awareness.","source":"@site/docs/api-reference/native-clients/java/network-api.md","sourceDirName":"api-reference/native-clients/java","slug":"/api-reference/native-clients/java/network-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/network-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Network API","id":"network-api","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Criteria API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/criteria-api"},"next":{"title":"Security API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/security-api"}}');var o=s(74848),t=s(28453);const d={title:"Network API",id:"network-api",sidebar_position:10},i="Network API",l={},c=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Cluster Access",id:"cluster-access",level:2},{value:"Asynchronous Node Discovery",id:"asynchronous-node-discovery",level:2},{value:"Local Node Information",id:"local-node-information",level:2},{value:"Node Identification",id:"node-identification",level:2},{value:"Network Addresses",id:"network-addresses",level:2},{value:"Address Construction",id:"address-construction",level:2},{value:"Node Metadata",id:"node-metadata",level:2},{value:"Client Connections",id:"client-connections",level:2},{value:"Node Selection",id:"node-selection",level:2},{value:"Multiple Node Selection",id:"multiple-node-selection",level:2},{value:"Compute Job Targeting",id:"compute-job-targeting",level:2},{value:"Address Parsing",id:"address-parsing",level:2},{value:"Address Formatting",id:"address-formatting",level:2},{value:"Deprecated API",id:"deprecated-api",level:2},{value:"Node Comparison",id:"node-comparison",level:2},{value:"Reference",id:"reference",level:2},{value:"IgniteCluster Methods",id:"ignitecluster-methods",level:3},{value:"ClusterNode Methods",id:"clusternode-methods",level:3},{value:"NetworkAddress Methods",id:"networkaddress-methods",level:3},{value:"NetworkAddress Construction",id:"networkaddress-construction",level:3},{value:"IgniteClient Connection Methods",id:"igniteclient-connection-methods",level:3},{value:"Ignite Node Methods",id:"ignite-node-methods",level:3},{value:"Topology Use Cases",id:"topology-use-cases",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"network-api",children:"Network API"})}),"\n",(0,o.jsx)(n.p,{children:"The Network API provides access to cluster topology information. Applications use this API to discover nodes, inspect network addresses, and access node metadata. This information supports compute job targeting, monitoring, and cluster awareness."}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(n.p,{children:"ClusterNode represents individual nodes in the cluster. Each node has a unique identifier, consistent name, network address, and metadata. The IgniteCluster facade provides access to topology information including all cluster members and the local node."}),"\n",(0,o.jsx)(n.p,{children:"Network addresses identify node endpoints using host and port combinations. Applications parse addresses from strings or construct them programmatically."}),"\n",(0,o.jsx)(n.h2,{id:"cluster-access",children:"Cluster Access"}),"\n",(0,o.jsx)(n.p,{children:"Access cluster topology through the cluster facade:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'IgniteCluster cluster = ignite.cluster();\r\n\r\nCollection<ClusterNode> nodes = cluster.nodes();\r\nSystem.out.println("Cluster has " + nodes.size() + " nodes");\r\n\r\nfor (ClusterNode node : nodes) {\r\n    System.out.println("Node: " + node.name() + " at " + node.address());\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"asynchronous-node-discovery",children:"Asynchronous Node Discovery"}),"\n",(0,o.jsx)(n.p,{children:"Retrieve nodes asynchronously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'CompletableFuture<Collection<ClusterNode>> nodesFuture = cluster.nodesAsync();\r\n\r\nnodesFuture.thenAccept(nodes -> {\r\n    for (ClusterNode node : nodes) {\r\n        System.out.println("Found node: " + node.name());\r\n    }\r\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"Asynchronous access avoids blocking when topology information requires network calls."}),"\n",(0,o.jsx)(n.h2,{id:"local-node-information",children:"Local Node Information"}),"\n",(0,o.jsx)(n.p,{children:"Access the local node:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'ClusterNode local = ignite.cluster().localNode();\r\n\r\nSystem.out.println("Local node ID: " + local.id());\r\nSystem.out.println("Local node name: " + local.name());\r\nSystem.out.println("Local address: " + local.address());\n'})}),"\n",(0,o.jsx)(n.p,{children:"The local node represents the current Ignite instance within the cluster."}),"\n",(0,o.jsx)(n.h2,{id:"node-identification",children:"Node Identification"}),"\n",(0,o.jsx)(n.p,{children:"Access node identifiers:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'ClusterNode node = cluster.localNode();\r\n\r\nUUID nodeId = node.id();\r\nString nodeName = node.name();\r\n\r\nSystem.out.println("Node ID: " + nodeId);\r\nSystem.out.println("Node name: " + nodeName);\n'})}),"\n",(0,o.jsx)(n.p,{children:"The node ID uniquely identifies the node. The node name provides a human-readable consistent identifier."}),"\n",(0,o.jsx)(n.h2,{id:"network-addresses",children:"Network Addresses"}),"\n",(0,o.jsx)(n.p,{children:"Access node network endpoints:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'ClusterNode node = cluster.localNode();\r\nNetworkAddress address = node.address();\r\n\r\nString host = address.host();\r\nint port = address.port();\r\n\r\nSystem.out.println("Host: " + host);\r\nSystem.out.println("Port: " + port);\n'})}),"\n",(0,o.jsx)(n.p,{children:"NetworkAddress identifies the node endpoint for client connections."}),"\n",(0,o.jsx)(n.h2,{id:"address-construction",children:"Address Construction"}),"\n",(0,o.jsx)(n.p,{children:"Create network addresses programmatically:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'NetworkAddress address1 = new NetworkAddress("localhost", 10800);\r\n\r\nNetworkAddress address2 = NetworkAddress.from("192.168.1.100:10800");\r\n\r\nInetSocketAddress socketAddress = new InetSocketAddress("server.example.com", 10800);\r\nNetworkAddress address3 = NetworkAddress.from(socketAddress);\n'})}),"\n",(0,o.jsx)(n.p,{children:"The from method parses addresses from strings or socket addresses."}),"\n",(0,o.jsx)(n.h2,{id:"node-metadata",children:"Node Metadata"}),"\n",(0,o.jsx)(n.p,{children:"Access node metadata:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"ClusterNode node = cluster.localNode();\r\nNodeMetadata metadata = node.nodeMetadata();\r\n\r\n// Access metadata properties\r\n// (specific metadata content depends on configuration)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Node metadata contains additional node-specific information configured during cluster setup."}),"\n",(0,o.jsx)(n.h2,{id:"client-connections",children:"Client Connections"}),"\n",(0,o.jsx)(n.p,{children:"Thin clients can access active connections:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'List<ClusterNode> connections = client.connections();\r\n\r\nSystem.out.println("Connected to " + connections.size() + " servers");\r\n\r\nfor (ClusterNode node : connections) {\r\n    System.out.println("Connected to: " + node.name() +\r\n        " at " + node.address());\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The connections list shows servers with active client connections."}),"\n",(0,o.jsx)(n.h2,{id:"node-selection",children:"Node Selection"}),"\n",(0,o.jsx)(n.p,{children:"Select specific nodes for operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'Collection<ClusterNode> allNodes = ignite.clusterNodes();\r\n\r\n// Find node by name\r\nClusterNode targetNode = allNodes.stream()\r\n    .filter(node -> node.name().equals("node-1"))\r\n    .findFirst()\r\n    .orElse(null);\r\n\r\nif (targetNode != null) {\r\n    System.out.println("Found node at " + targetNode.address());\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"multiple-node-selection",children:"Multiple Node Selection"}),"\n",(0,o.jsx)(n.p,{children:"Filter nodes by criteria:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'Collection<ClusterNode> allNodes = ignite.clusterNodes();\r\n\r\n// Select nodes by port\r\nList<ClusterNode> portFiltered = allNodes.stream()\r\n    .filter(node -> node.address().port() == 10800)\r\n    .collect(Collectors.toList());\r\n\r\n// Select nodes by hostname pattern\r\nList<ClusterNode> hostFiltered = allNodes.stream()\r\n    .filter(node -> node.address().host().contains("prod"))\r\n    .collect(Collectors.toList());\n'})}),"\n",(0,o.jsx)(n.h2,{id:"compute-job-targeting",children:"Compute Job Targeting"}),"\n",(0,o.jsx)(n.p,{children:"Use node information for compute operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'Collection<ClusterNode> nodes = ignite.clusterNodes();\r\n\r\nJobDescriptor<String, Integer> descriptor =\r\n    JobDescriptor.<String, Integer>builder("com.example.DataProcessor").build();\r\n\r\n// Execute on all nodes\r\nfor (ClusterNode node : nodes) {\r\n    CompletableFuture<JobExecution<Integer>> executionFuture =\r\n        ignite.compute().submitAsync(\r\n            JobTarget.node(node),\r\n            descriptor,\r\n            "input"\r\n        );\r\n\r\n    executionFuture.thenCompose(JobExecution::resultAsync)\r\n        .thenAccept(result -> {\r\n            System.out.println("Job result from " + node.name() + ": " + result);\r\n        });\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"address-parsing",children:"Address Parsing"}),"\n",(0,o.jsx)(n.p,{children:"Parse addresses from configuration strings:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'String[] serverAddresses = {\r\n    "server1.example.com:10800",\r\n    "server2.example.com:10800",\r\n    "192.168.1.100:10800"\r\n};\r\n\r\nList<NetworkAddress> addresses = Arrays.stream(serverAddresses)\r\n    .map(NetworkAddress::from)\r\n    .collect(Collectors.toList());\r\n\r\nfor (NetworkAddress addr : addresses) {\r\n    System.out.println("Server: " + addr.host() + ":" + addr.port());\r\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"address-formatting",children:"Address Formatting"}),"\n",(0,o.jsx)(n.p,{children:"Format addresses for display:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'NetworkAddress address = node.address();\r\n\r\nString formatted = address.host() + ":" + address.port();\r\nSystem.out.println("Node endpoint: " + formatted);\r\n\r\n// Address toString provides formatted output\r\nString automatic = address.toString();\n'})}),"\n",(0,o.jsx)(n.h2,{id:"deprecated-api",children:"Deprecated API"}),"\n",(0,o.jsx)(n.p,{children:"The clusterNodes method on Ignite is deprecated:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"// Deprecated\r\nCollection<ClusterNode> nodes1 = ignite.clusterNodes();\r\n\r\n// Preferred\r\nCollection<ClusterNode> nodes2 = ignite.cluster().nodes();\n"})}),"\n",(0,o.jsx)(n.p,{children:"Use the cluster facade for topology access."}),"\n",(0,o.jsx)(n.h2,{id:"node-comparison",children:"Node Comparison"}),"\n",(0,o.jsx)(n.p,{children:"Compare nodes by identity:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'ClusterNode node1 = cluster.localNode();\r\nClusterNode node2 = nodes.iterator().next();\r\n\r\nboolean same = node1.id().equals(node2.id());\r\nif (same) {\r\n    System.out.println("Same node");\r\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Compare nodes using their UUID identifiers."}),"\n",(0,o.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Cluster facade: ",(0,o.jsx)(n.code,{children:"org.apache.ignite.network.IgniteCluster"})]}),"\n",(0,o.jsxs)(n.li,{children:["Node representation: ",(0,o.jsx)(n.code,{children:"org.apache.ignite.network.ClusterNode"})]}),"\n",(0,o.jsxs)(n.li,{children:["Network address: ",(0,o.jsx)(n.code,{children:"org.apache.ignite.network.NetworkAddress"})]}),"\n",(0,o.jsxs)(n.li,{children:["Node metadata: ",(0,o.jsx)(n.code,{children:"org.apache.ignite.network.NodeMetadata"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"ignitecluster-methods",children:"IgniteCluster Methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Collection<ClusterNode> nodes()"})," - Get all cluster nodes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"CompletableFuture<Collection<ClusterNode>> nodesAsync()"})," - Async get nodes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ClusterNode localNode()"})," - Get local node"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"clusternode-methods",children:"ClusterNode Methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"UUID id()"})," - Get node unique identifier"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"String name()"})," - Get node name (consistent ID)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NetworkAddress address()"})," - Get network address"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NodeMetadata nodeMetadata()"})," - Get node metadata"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"networkaddress-methods",children:"NetworkAddress Methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"String host()"})," - Get hostname"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"int port()"})," - Get port number"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"networkaddress-construction",children:"NetworkAddress Construction"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NetworkAddress(String host, int port)"})," - Create from components"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"static NetworkAddress from(String)"}),' - Parse from "host',":port",'" string']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"static NetworkAddress from(InetSocketAddress)"})," - Convert from socket address"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"igniteclient-connection-methods",children:"IgniteClient Connection Methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"List<ClusterNode> connections()"})," - Get active server connections"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"ignite-node-methods",children:"Ignite Node Methods"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Collection<ClusterNode> clusterNodes()"})," - Get all nodes (deprecated, use cluster().nodes())"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"topology-use-cases",children:"Topology Use Cases"}),"\n",(0,o.jsx)(n.p,{children:"Node information supports several common patterns:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Compute job targeting based on node location or capabilities"}),"\n",(0,o.jsx)(n.li,{children:"Monitoring and diagnostics of cluster health"}),"\n",(0,o.jsx)(n.li,{children:"Connection management for thin clients"}),"\n",(0,o.jsx)(n.li,{children:"Custom load balancing and data locality optimization"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}}}]);