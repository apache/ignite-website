"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1175],{28453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>o});var i=r(96540);const t={},s=i.createContext(t);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),i.createElement(s.Provider,{value:e},n.children)}},88127:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"understand/core-concepts/transactions-and-mvcc","title":"Transactions and MVCC","description":"Ignite 3 provides ACID transactions using Multi-Version Concurrency Control (MVCC) combined with Two-Phase Locking (2PL). All tables are transactional by default with serializable isolation.","source":"@site/docs/understand/core-concepts/transactions-and-mvcc.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/transactions-and-mvcc","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/transactions-and-mvcc","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"transactions-and-mvcc","title":"Transactions and MVCC","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Tables and Schemas","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/tables-and-schemas"},"next":{"title":"Distribution and Colocation","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/distribution-and-colocation"}}');var t=r(74848),s=r(28453);const a={id:"transactions-and-mvcc",title:"Transactions and MVCC",sidebar_position:3},o=void 0,l={},c=[{value:"Transaction Model Overview",id:"transaction-model-overview",level:2},{value:"Multi-Version Concurrency Control",id:"multi-version-concurrency-control",level:2},{value:"Version Chains",id:"version-chains",level:3},{value:"Write Intents",id:"write-intents",level:3},{value:"Visibility Rules",id:"visibility-rules",level:3},{value:"Hybrid Timestamps",id:"hybrid-timestamps",level:2},{value:"Transaction Isolation",id:"transaction-isolation",level:2},{value:"Read-Write Transactions",id:"read-write-transactions",level:3},{value:"Read-Only Transactions",id:"read-only-transactions",level:3},{value:"Deadlock Prevention",id:"deadlock-prevention",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:2},{value:"Read-Write Transaction Flow",id:"read-write-transaction-flow",level:3},{value:"Two-Phase Commit Protocol",id:"two-phase-commit-protocol",level:3},{value:"Transaction Coordinator",id:"transaction-coordinator",level:3},{value:"Version Garbage Collection",id:"version-garbage-collection",level:2},{value:"Transaction Options",id:"transaction-options",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"Ignite 3 provides ACID transactions using Multi-Version Concurrency Control (MVCC) combined with Two-Phase Locking (2PL). All tables are transactional by default with serializable isolation."}),"\n",(0,t.jsx)(e.h2,{id:"transaction-model-overview",children:"Transaction Model Overview"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart TB\r\n    subgraph "Transaction Types"\r\n        RW["Read-Write Transaction<br/>Acquires locks<br/>Creates write intents<br/>Serializable isolation"]\r\n        RO["Read-Only Transaction<br/>No locks<br/>Snapshot isolation<br/>Point-in-time reads"]\r\n    end\r\n\r\n    subgraph "Concurrency Control"\r\n        MVCC["MVCC<br/>Version chains<br/>Timestamp ordering"]\r\n        Locks["2PL<br/>Lock acquisition<br/>WAIT_DIE deadlock prevention"]\r\n    end\r\n\r\n    RW --\x3e Locks\r\n    RW --\x3e MVCC\r\n    RO --\x3e MVCC'}),"\n",(0,t.jsx)(e.p,{children:"Key characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"All transactions are serializable for read-write operations"}),"\n",(0,t.jsx)(e.li,{children:"Read-only transactions use snapshot isolation without locking"}),"\n",(0,t.jsx)(e.li,{children:"WAIT_DIE algorithm prevents deadlocks"}),"\n",(0,t.jsx)(e.li,{children:"Two-phase commit (2PC) coordinates distributed transactions"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"multi-version-concurrency-control",children:"Multi-Version Concurrency Control"}),"\n",(0,t.jsx)(e.p,{children:"MVCC maintains multiple versions of each row, allowing concurrent readers and writers without blocking."}),"\n",(0,t.jsx)(e.h3,{id:"version-chains",children:"Version Chains"}),"\n",(0,t.jsx)(e.p,{children:"Each row has a version chain storing all versions from newest to oldest:"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart LR\r\n    subgraph "Version Chain for Key 42"\r\n        V3["Version 3<br/>ts: 1000<br/>value: 300"]\r\n        V2["Version 2<br/>ts: 800<br/>value: 200"]\r\n        V1["Version 1<br/>ts: 500<br/>value: 100"]\r\n    end\r\n\r\n    Head([Head]) --\x3e V3\r\n    V3 --\x3e V2\r\n    V2 --\x3e V1\r\n    V1 --\x3e Null([null])'}),"\n",(0,t.jsx)(e.p,{children:"Each version contains:"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Field"}),(0,t.jsx)(e.th,{children:"Description"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Timestamp"}),(0,t.jsx)(e.td,{children:"Hybrid timestamp when committed (null if uncommitted)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Transaction ID"}),(0,t.jsx)(e.td,{children:"ID of owning transaction (for uncommitted versions)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Value"}),(0,t.jsx)(e.td,{children:"Binary row data (empty for tombstones/deletions)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Next link"}),(0,t.jsx)(e.td,{children:"Pointer to previous version"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"write-intents",children:"Write Intents"}),"\n",(0,t.jsx)(e.p,{children:"Uncommitted changes are stored as write intents at the head of the version chain:"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart LR\r\n    subgraph "Version Chain with Write Intent"\r\n        WI["Write Intent<br/>txId: tx-123<br/>value: 350"]\r\n        V3["Committed<br/>ts: 1000<br/>value: 300"]\r\n        V2["Committed<br/>ts: 800<br/>value: 200"]\r\n    end\r\n\r\n    Head([Head]) --\x3e WI\r\n    WI --\x3e|"uncommitted"| V3\r\n    V3 --\x3e V2'}),"\n",(0,t.jsx)(e.p,{children:"Write intents track:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Transaction ID of the writer"}),"\n",(0,t.jsx)(e.li,{children:"Commit partition ID for transaction state lookup"}),"\n",(0,t.jsx)(e.li,{children:"The uncommitted value"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"On commit, the write intent receives a timestamp and becomes a regular committed version. On abort, the write intent is removed."}),"\n",(0,t.jsx)(e.h3,{id:"visibility-rules",children:"Visibility Rules"}),"\n",(0,t.jsx)(e.p,{children:"When reading a row, transactions see different versions based on their type and timestamp:"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Scenario"}),(0,t.jsx)(e.th,{children:"Read-Write Transaction"}),(0,t.jsx)(e.th,{children:"Read-Only Transaction"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Only write intent exists"}),(0,t.jsx)(e.td,{children:"Sees write intent (if own tx)"}),(0,t.jsx)(e.td,{children:"Blocks or sees nothing"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Write intent + older commit"}),(0,t.jsx)(e.td,{children:"Sees write intent (if own tx) or waits"}),(0,t.jsx)(e.td,{children:"Sees older commit"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Committed version newer than read timestamp"}),(0,t.jsx)(e.td,{children:"Sees it"}),(0,t.jsx)(e.td,{children:"Sees older version"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"All commits older than read timestamp"}),(0,t.jsx)(e.td,{children:"Sees newest"}),(0,t.jsx)(e.td,{children:"Sees version at timestamp"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"Read-only transactions always read at their creation timestamp, providing a consistent snapshot."}),"\n",(0,t.jsx)(e.h2,{id:"hybrid-timestamps",children:"Hybrid Timestamps"}),"\n",(0,t.jsx)(e.p,{children:"Ignite uses hybrid logical clocks combining physical time with logical counters:"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart LR\r\n    subgraph "Hybrid Timestamp (64 bits)"\r\n        P["Physical Time<br/>48 bits<br/>milliseconds since epoch"]\r\n        L["Logical Counter<br/>16 bits<br/>event ordering"]\r\n    end\r\n\r\n    P --- L'}),"\n",(0,t.jsx)(e.p,{children:"Hybrid timestamps provide:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Causality"}),": Events on the same node are ordered correctly"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Approximate wall-clock"}),": Physical component enables time-based queries"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Coordination-free generation"}),": Nodes generate timestamps locally"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The epoch starts at January 1, 2021. The logical counter ensures ordering when multiple events occur within the same millisecond."}),"\n",(0,t.jsx)(e.h2,{id:"transaction-isolation",children:"Transaction Isolation"}),"\n",(0,t.jsx)(e.h3,{id:"read-write-transactions",children:"Read-Write Transactions"}),"\n",(0,t.jsx)(e.p,{children:"Read-write transactions use serializable isolation through Two-Phase Locking:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Growing phase"}),": Acquire locks before accessing data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Shrinking phase"}),": Release all locks at commit/abort"]}),"\n"]}),"\n",(0,t.jsx)(e.mermaid,{value:"sequenceDiagram\r\n    participant TX as Transaction\r\n    participant LM as Lock Manager\r\n    participant ST as Storage\r\n\r\n    TX->>LM: Acquire lock (key 42)\r\n    LM--\x3e>TX: Lock granted\r\n    TX->>ST: Read key 42\r\n    ST--\x3e>TX: Value\r\n    TX->>ST: Write key 42\r\n    TX->>TX: Commit\r\n    TX->>LM: Release all locks"}),"\n",(0,t.jsx)(e.p,{children:"Lock modes form a compatibility matrix:"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Lock"}),(0,t.jsx)(e.th,{children:"IS"}),(0,t.jsx)(e.th,{children:"IX"}),(0,t.jsx)(e.th,{children:"S"}),(0,t.jsx)(e.th,{children:"SIX"}),(0,t.jsx)(e.th,{children:"X"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"IS"})}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"IX"})}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"S"})}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"SIX"})}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"X"})}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"}),(0,t.jsx)(e.td,{children:"No"})]})]})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"IS"})," (Intention Shared): Intent to read descendants"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"IX"})," (Intention Exclusive): Intent to write descendants"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"S"})," (Shared): Read lock"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"SIX"})," (Shared Intention Exclusive): Read lock with intent to write descendants"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"X"})," (Exclusive): Write lock"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"read-only-transactions",children:"Read-Only Transactions"}),"\n",(0,t.jsx)(e.p,{children:"Read-only transactions bypass locking entirely:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Fixed read timestamp assigned at creation"}),"\n",(0,t.jsx)(e.li,{children:"Read from any replica (not just primary)"}),"\n",(0,t.jsx)(e.li,{children:"No partition enlistment or coordination"}),"\n",(0,t.jsx)(e.li,{children:"Cannot modify data"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"var tx = client.transactions().begin(\r\n    new TransactionOptions().readOnly(true)\r\n);\r\n\r\n// Reads see consistent snapshot at transaction start time\r\nAccount account = accounts.get(tx, 42);\r\n\r\ntx.commit(); // No-op for read-only\n"})}),"\n",(0,t.jsx)(e.h2,{id:"deadlock-prevention",children:"Deadlock Prevention"}),"\n",(0,t.jsx)(e.p,{children:"Ignite uses the WAIT_DIE algorithm to prevent deadlocks without detection cycles:"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart TB\r\n    subgraph "WAIT_DIE Decision"\r\n        Check{Requesting TX<br/>older than holder?}\r\n        Wait[Wait for lock]\r\n        Die[Abort and retry]\r\n    end\r\n\r\n    Check --\x3e|Yes| Wait\r\n    Check --\x3e|No| Die'}),"\n",(0,t.jsx)(e.p,{children:"When a transaction requests a lock held by another:"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Requester Age"}),(0,t.jsx)(e.th,{children:"Action"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Older than holder"}),(0,t.jsx)(e.td,{children:"Wait for lock release"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Younger than holder"}),(0,t.jsx)(e.td,{children:"Abort immediately, retry with same timestamp"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"This prevents circular waits because younger transactions always yield to older ones. Retrying with the same timestamp ensures the transaction eventually becomes the oldest and succeeds."}),"\n",(0,t.jsx)(e.h2,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,t.jsx)(e.h3,{id:"read-write-transaction-flow",children:"Read-Write Transaction Flow"}),"\n",(0,t.jsx)(e.mermaid,{value:"stateDiagram-v2\r\n    [*] --\x3e PENDING: begin()\r\n    PENDING --\x3e PENDING: read/write operations\r\n    PENDING --\x3e FINISHING: commit()/rollback()\r\n    FINISHING --\x3e COMMITTED: 2PC success\r\n    FINISHING --\x3e ABORTED: 2PC failure or rollback\r\n    PENDING --\x3e ABORTED: conflict/timeout\r\n    COMMITTED --\x3e [*]\r\n    ABORTED --\x3e [*]"}),"\n",(0,t.jsx)(e.p,{children:"State descriptions:"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"State"}),(0,t.jsx)(e.th,{children:"Description"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"PENDING"}),(0,t.jsx)(e.td,{children:"Active transaction, operations in progress"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"FINISHING"}),(0,t.jsx)(e.td,{children:"Coordinator initiated commit/rollback"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"COMMITTED"}),(0,t.jsx)(e.td,{children:"Successfully committed, changes visible"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"ABORTED"}),(0,t.jsx)(e.td,{children:"Rolled back, changes discarded"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"ABANDONED"}),(0,t.jsx)(e.td,{children:"Coordinator lost, awaiting recovery"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"two-phase-commit-protocol",children:"Two-Phase Commit Protocol"}),"\n",(0,t.jsx)(e.p,{children:"Distributed transactions use 2PC for atomic commitment:"}),"\n",(0,t.jsx)(e.mermaid,{value:"sequenceDiagram\r\n    participant C as Coordinator\r\n    participant P1 as Partition 1\r\n    participant P2 as Partition 2\r\n\r\n    Note over C: Phase 1: Prepare\r\n    C->>P1: Prepare (write intents)\r\n    C->>P2: Prepare (write intents)\r\n    P1--\x3e>C: Prepared\r\n    P2--\x3e>C: Prepared\r\n\r\n    Note over C: Phase 2: Commit\r\n    C->>P1: Commit (apply timestamp)\r\n    C->>P2: Commit (apply timestamp)\r\n    P1--\x3e>C: Committed\r\n    P2--\x3e>C: Committed\r\n\r\n    Note over C: Cleanup\r\n    C->>P1: Release locks\r\n    C->>P2: Release locks"}),"\n",(0,t.jsx)(e.p,{children:"If any partition fails to prepare, the coordinator aborts all participants."}),"\n",(0,t.jsx)(e.h3,{id:"transaction-coordinator",children:"Transaction Coordinator"}),"\n",(0,t.jsx)(e.p,{children:"The node that begins the transaction becomes its coordinator, responsible for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Tracking enlisted partitions"}),"\n",(0,t.jsx)(e.li,{children:"Assigning a commit partition for state storage"}),"\n",(0,t.jsx)(e.li,{children:"Orchestrating 2PC protocol"}),"\n",(0,t.jsx)(e.li,{children:"Handling failures and timeouts"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"If the coordinator fails:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Transaction enters ABANDONED state"}),"\n",(0,t.jsx)(e.li,{children:"Orphan detection triggers after timeout"}),"\n",(0,t.jsx)(e.li,{children:"Write intents are resolved based on commit partition state"}),"\n",(0,t.jsx)(e.li,{children:"Locks are released"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"version-garbage-collection",children:"Version Garbage Collection"}),"\n",(0,t.jsx)(e.p,{children:"Old versions accumulate in version chains. The garbage collector removes versions older than the low watermark:"}),"\n",(0,t.jsx)(e.mermaid,{value:'flowchart LR\r\n    subgraph "Before GC"\r\n        V4["ts: 1200"]\r\n        V3["ts: 1000"]\r\n        V2["ts: 800"]\r\n        V1["ts: 500"]\r\n    end\r\n\r\n    subgraph "After GC (watermark: 900)"\r\n        V4a["ts: 1200"]\r\n        V3a["ts: 1000"]\r\n    end\r\n\r\n    V4 --\x3e V3 --\x3e V2 --\x3e V1\r\n    V4a --\x3e V3a'}),"\n",(0,t.jsx)(e.p,{children:"Low watermark considerations:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Default: 600,000 ms (10 minutes)"}),"\n",(0,t.jsx)(e.li,{children:"Increasing allows longer-running read-only transactions"}),"\n",(0,t.jsx)(e.li,{children:"Higher values require more storage for old versions"}),"\n",(0,t.jsx)(e.li,{children:"Active transactions prevent GC of versions they might need"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"transaction-options",children:"Transaction Options"}),"\n",(0,t.jsx)(e.p,{children:"Configure transactions at creation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"// Read-write with timeout\r\nvar rwTx = client.transactions().begin(\r\n    new TransactionOptions()\r\n        .timeoutMillis(30000)  // 30 second timeout\r\n);\r\n\r\n// Read-only\r\nvar roTx = client.transactions().begin(\r\n    new TransactionOptions()\r\n        .readOnly(true)\r\n);\n"})}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Option"}),(0,t.jsx)(e.th,{children:"Default"}),(0,t.jsx)(e.th,{children:"Description"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:"readOnly"})}),(0,t.jsx)(e.td,{children:"false"}),(0,t.jsx)(e.td,{children:"Enable read-only mode"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:"timeoutMillis"})}),(0,t.jsx)(e.td,{children:"0 (none)"}),(0,t.jsx)(e.td,{children:"Auto-rollback after timeout"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Primary replica writes"}),": All read-write operations go through the partition's primary replica"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Lock granularity"}),": Locks are per-key, not per-row or per-table"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"No savepoints"}),": Partial rollback within a transaction is not supported"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Clock synchronization"}),": Nodes must have synchronized clocks (within ",(0,t.jsx)(e.code,{children:"schemaSync.maxClockSkewMillis"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Single commit partition"}),": Each transaction uses one partition for state, creating a coordination point"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Write intent resolution"}),": Encountering another transaction's write intent may require waiting or aborting"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/3.1.0/develop/work-with-data/transactions",children:"Performing Transactions"})," for API usage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/3.1.0/understand/core-concepts/data-partitioning",children:"Data Partitioning"})," for version storage details"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);