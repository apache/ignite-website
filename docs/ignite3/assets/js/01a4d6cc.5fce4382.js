"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[505],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},l=r.createContext(s);function i(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(l.Provider,{value:n},e.children)}},30917:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"api-reference/native-clients/cpp/sql-api","title":"SQL API","description":"The SQL API executes SQL statements and scripts against Apache Ignite clusters. It supports parameterized queries, pagination, transaction integration, and query cancellation.","source":"@site/docs/api-reference/native-clients/cpp/sql-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/sql-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/sql-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"SQL API","id":"sql-api","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Tables API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/tables-api"},"next":{"title":"Transactions API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/transactions-api"}}');var s=t(74848),l=t(28453);const i={title:"SQL API",id:"sql-api",sidebar_position:3},a="SQL API",c={},d=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Statement Execution",id:"statement-execution",level:3},{value:"Parameterized Queries",id:"parameterized-queries",level:3},{value:"Result Sets",id:"result-sets",level:3},{value:"Transaction Integration",id:"transaction-integration",level:3},{value:"Query Cancellation",id:"query-cancellation",level:3},{value:"Basic Execution",id:"basic-execution",level:2},{value:"Simple Query",id:"simple-query",level:3},{value:"Parameterized Query",id:"parameterized-query",level:3},{value:"DML Operations",id:"dml-operations",level:3},{value:"DDL Operations",id:"ddl-operations",level:3},{value:"SQL Statements",id:"sql-statements",level:2},{value:"Statement Configuration",id:"statement-configuration",level:3},{value:"Statement Properties",id:"statement-properties",level:3},{value:"Builder Pattern",id:"builder-pattern",level:3},{value:"Result Sets",id:"result-sets-1",level:2},{value:"Accessing Rows",id:"accessing-rows",level:3},{value:"Pagination",id:"pagination",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Checking Result Type",id:"checking-result-type",level:3},{value:"Closing Result Sets",id:"closing-result-sets",level:3},{value:"Script Execution",id:"script-execution",level:2},{value:"Multi-Statement Scripts",id:"multi-statement-scripts",level:3},{value:"Transaction Integration",id:"transaction-integration-1",level:2},{value:"Explicit Transactions",id:"explicit-transactions",level:3},{value:"Implicit Transactions",id:"implicit-transactions",level:3},{value:"Query Cancellation",id:"query-cancellation-1",level:2},{value:"Creating Cancellation Tokens",id:"creating-cancellation-tokens",level:3},{value:"Cancelling Queries",id:"cancelling-queries",level:3},{value:"Asynchronous Execution",id:"asynchronous-execution",level:2},{value:"Data Type Mapping",id:"data-type-mapping",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Reference",id:"reference",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sql-api",children:"SQL API"})}),"\n",(0,s.jsx)(n.p,{children:"The SQL API executes SQL statements and scripts against Apache Ignite clusters. It supports parameterized queries, pagination, transaction integration, and query cancellation."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"statement-execution",children:"Statement Execution"}),"\n",(0,s.jsx)(n.p,{children:"Single-statement queries return result sets. Multi-statement scripts execute multiple statements without returning results. Use statements for queries and DML operations. Use scripts for DDL operations and batch updates."}),"\n",(0,s.jsx)(n.h3,{id:"parameterized-queries",children:"Parameterized Queries"}),"\n",(0,s.jsxs)(n.p,{children:["Parameters prevent SQL injection and enable query plan reuse. Use question marks (",(0,s.jsx)(n.code,{children:"?"}),") as placeholders. Pass parameter values as a vector of ",(0,s.jsx)(n.code,{children:"primitive"})," values in execution order."]}),"\n",(0,s.jsx)(n.h3,{id:"result-sets",children:"Result Sets"}),"\n",(0,s.jsxs)(n.p,{children:["Query results return as ",(0,s.jsx)(n.code,{children:"result_set"})," objects containing rows and metadata. Result sets support pagination for large queries. Each page contains a batch of rows. Fetch additional pages explicitly."]}),"\n",(0,s.jsx)(n.h3,{id:"transaction-integration",children:"Transaction Integration"}),"\n",(0,s.jsxs)(n.p,{children:["Pass a transaction pointer to execute statements within explicit transactions. Pass ",(0,s.jsx)(n.code,{children:"nullptr"})," for implicit transactions that commit immediately."]}),"\n",(0,s.jsx)(n.h3,{id:"query-cancellation",children:"Query Cancellation"}),"\n",(0,s.jsxs)(n.p,{children:["Pass a ",(0,s.jsx)(n.code,{children:"cancellation_token"})," to cancel long-running queries. Create tokens before execution. Trigger cancellation from another thread when needed."]}),"\n",(0,s.jsx)(n.h2,{id:"basic-execution",children:"Basic Execution"}),"\n",(0,s.jsx)(n.h3,{id:"simple-query",children:"Simple Query"}),"\n",(0,s.jsx)(n.p,{children:"Execute a SELECT statement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using namespace ignite;\r\n\r\nauto sql = client.get_sql();\r\nauto result = sql.execute(nullptr, nullptr, sql_statement("SELECT * FROM accounts"), {});\r\n\r\nif (result.has_rowset()) {\r\n    for (const auto& row : result.current_page()) {\r\n        auto id = row.get<int64_t>("id");\r\n        auto name = row.get<std::string>("name");\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"parameterized-query",children:"Parameterized Query"}),"\n",(0,s.jsx)(n.p,{children:"Use parameters for safe value binding:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql_statement stmt("SELECT * FROM accounts WHERE balance > ? AND active = ?");\r\nstd::vector<primitive> params{1000.0, true};\r\n\r\nauto result = sql.execute(nullptr, nullptr, stmt, params);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dml-operations",children:"DML Operations"}),"\n",(0,s.jsx)(n.p,{children:"Execute INSERT, UPDATE, DELETE:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Insert\r\nsql_statement insert("INSERT INTO accounts (id, name, balance) VALUES (?, ?, ?)");\r\nstd::vector<primitive> values{42, std::string("John Doe"), 1000.0};\r\n\r\nauto result = sql.execute(nullptr, nullptr, insert, values);\r\nstd::cout << "Rows inserted: " << result.affected_rows() << std::endl;\r\n\r\n// Update\r\nsql_statement update("UPDATE accounts SET balance = ? WHERE id = ?");\r\nauto result2 = sql.execute(nullptr, nullptr, update, {1500.0, 42});\r\nstd::cout << "Rows updated: " << result2.affected_rows() << std::endl;\r\n\r\n// Delete\r\nsql_statement del("DELETE FROM accounts WHERE id = ?");\r\nauto result3 = sql.execute(nullptr, nullptr, del, {42});\r\nstd::cout << "Rows deleted: " << result3.affected_rows() << std::endl;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ddl-operations",children:"DDL Operations"}),"\n",(0,s.jsx)(n.p,{children:"Execute schema changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql_statement ddl("CREATE TABLE new_table (id INT PRIMARY KEY, data VARCHAR)");\r\nauto result = sql.execute(nullptr, nullptr, ddl, {});\r\n\r\n// Check if DDL was applied\r\nif (result.was_applied()) {\r\n    std::cout << "Table created" << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"sql-statements",children:"SQL Statements"}),"\n",(0,s.jsx)(n.h3,{id:"statement-configuration",children:"Statement Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Configure statement properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql_statement stmt;\r\nstmt.query("SELECT * FROM large_table");\r\nstmt.schema("my_schema");\r\nstmt.page_size(100);  // Rows per page\r\nstmt.timeout(std::chrono::seconds(30));\r\nstmt.timezone_id("America/New_York");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"statement-properties",children:"Statement Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"query()"})," - SQL text to execute (required)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"schema()"}),' - Default schema name (default: "PUBLIC")']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"page_size()"})," - Rows per result page (default: 1024)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"timeout()"})," - Query timeout in milliseconds (default: 0 for no timeout)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"timezone_id()"})," - Timezone for time functions"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"properties()"})," - Additional statement properties as key-value map"]}),"\n",(0,s.jsx)(n.h3,{id:"builder-pattern",children:"Builder Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Chain configuration calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql_statement stmt;\r\nstmt.query("SELECT * FROM accounts")\r\n    .schema("PUBLIC")\r\n    .page_size(500)\r\n    .timeout(std::chrono::seconds(10));\n'})}),"\n",(0,s.jsx)(n.h2,{id:"result-sets-1",children:"Result Sets"}),"\n",(0,s.jsx)(n.h3,{id:"accessing-rows",children:"Accessing Rows"}),"\n",(0,s.jsx)(n.p,{children:"Iterate current page:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto result = sql.execute(nullptr, nullptr, stmt, {});\r\n\r\nfor (const auto& row : result.current_page()) {\r\n    // Access columns by name\r\n    auto id = row.get<int64_t>("id");\r\n    auto name = row.get<std::string>("name");\r\n\r\n    // Or by index\r\n    auto id2 = row.get<int64_t>(0);\r\n    auto name2 = row.get<std::string>(1);\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pagination",children:"Pagination"}),"\n",(0,s.jsx)(n.p,{children:"Handle large result sets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto result = sql.execute(nullptr, nullptr, stmt, {});\r\n\r\n// Process first page\r\nfor (const auto& row : result.current_page()) {\r\n    // Process row\r\n}\r\n\r\n// Fetch and process remaining pages\r\nwhile (result.has_more_pages()) {\r\n    result.fetch_next_page();\r\n    for (const auto& row : result.current_page()) {\r\n        // Process row\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Use async pagination:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void process_page(result_set& result) {\r\n    for (const auto& row : result.current_page()) {\r\n        // Process row\r\n    }\r\n\r\n    if (result.has_more_pages()) {\r\n        result.fetch_next_page_async([&](ignite_result<void> res) {\r\n            if (!res.has_error()) {\r\n                process_page(result);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nauto result = sql.execute(nullptr, nullptr, stmt, {});\r\nprocess_page(result);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"metadata",children:"Metadata"}),"\n",(0,s.jsx)(n.p,{children:"Access result metadata:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto result = sql.execute(nullptr, nullptr, stmt, {});\r\nconst auto& metadata = result.metadata();\r\n\r\nfor (const auto& column : metadata.columns()) {\r\n    std::cout << "Column: " << column.name() << std::endl;\r\n    std::cout << "Type: " << static_cast<int>(column.type()) << std::endl;\r\n    std::cout << "Nullable: " << column.nullable() << std::endl;\r\n\r\n    if (column.precision() != -1) {\r\n        std::cout << "Precision: " << column.precision() << std::endl;\r\n    }\r\n    if (column.scale() != -1) {\r\n        std::cout << "Scale: " << column.scale() << std::endl;\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Find column index by name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'int32_t col_index = metadata.index_of("balance");\n'})}),"\n",(0,s.jsx)(n.h3,{id:"checking-result-type",children:"Checking Result Type"}),"\n",(0,s.jsx)(n.p,{children:"Determine if result contains rows or is a DML result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto result = sql.execute(nullptr, nullptr, stmt, {});\r\n\r\nif (result.has_rowset()) {\r\n    // Query returned rows\r\n    auto rows = result.current_page();\r\n} else {\r\n    // DML or DDL operation\r\n    std::cout << "Affected rows: " << result.affected_rows() << std::endl;\r\n}\r\n\r\n// Check if conditional DDL was applied\r\nif (result.was_applied()) {\r\n    std::cout << "Statement applied successfully" << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"closing-result-sets",children:"Closing Result Sets"}),"\n",(0,s.jsx)(n.p,{children:"Close result sets explicitly to free resources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto result = sql.execute(nullptr, nullptr, stmt, {});\r\n// Use result\r\nresult.close();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Use async close:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"result.close_async([](ignite_result<void> res) {\r\n    if (!res.has_error()) {\r\n        // Result closed\r\n    }\r\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"script-execution",children:"Script Execution"}),"\n",(0,s.jsx)(n.h3,{id:"multi-statement-scripts",children:"Multi-Statement Scripts"}),"\n",(0,s.jsx)(n.p,{children:"Execute multiple statements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"sql_statement script(R\"(\r\n    CREATE TABLE temp1 (id INT PRIMARY KEY, data VARCHAR);\r\n    CREATE TABLE temp2 (id INT PRIMARY KEY, data VARCHAR);\r\n    INSERT INTO temp1 VALUES (1, 'test');\r\n)\");\r\n\r\nsql.execute_script(nullptr, script, {});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Use async execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql.execute_script_async(nullptr, script, {}, [](ignite_result<void> result) {\r\n    if (!result.has_error()) {\r\n        std::cout << "Script executed successfully" << std::endl;\r\n    }\r\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"Scripts do not return result sets. Use individual statements for queries. Scripts do not support transactions."}),"\n",(0,s.jsx)(n.h2,{id:"transaction-integration-1",children:"Transaction Integration"}),"\n",(0,s.jsx)(n.h3,{id:"explicit-transactions",children:"Explicit Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Execute statements in a transaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\r\n\r\ntry {\r\n    sql_statement update1("UPDATE accounts SET balance = balance - ? WHERE id = ?");\r\n    sql.execute(&tx, nullptr, update1, {100.0, 1});\r\n\r\n    sql_statement update2("UPDATE accounts SET balance = balance + ? WHERE id = ?");\r\n    sql.execute(&tx, nullptr, update2, {100.0, 2});\r\n\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implicit-transactions",children:"Implicit Transactions"}),"\n",(0,s.jsxs)(n.p,{children:["Pass ",(0,s.jsx)(n.code,{children:"nullptr"})," for auto-commit:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Each statement commits immediately\r\nsql.execute(nullptr, nullptr, stmt, params);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"query-cancellation-1",children:"Query Cancellation"}),"\n",(0,s.jsx)(n.h3,{id:"creating-cancellation-tokens",children:"Creating Cancellation Tokens"}),"\n",(0,s.jsx)(n.p,{children:"Create a token before execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"cancel_handle handle;\r\ncancellation_token token(&handle);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cancelling-queries",children:"Cancelling Queries"}),"\n",(0,s.jsx)(n.p,{children:"Cancel from another thread:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Thread 1: Execute long query\r\nauto result = sql.execute(nullptr, &token,\r\n    sql_statement("SELECT * FROM huge_table"), {});\r\n\r\n// Thread 2: Cancel query\r\nhandle.cancel();\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use with async execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"cancel_handle handle;\r\ncancellation_token token(&handle);\r\n\r\nsql.execute_async(nullptr, &token, stmt, {},\r\n    [](ignite_result<result_set> result) {\r\n        if (result.has_error()) {\r\n            // May be cancellation error\r\n        } else {\r\n            // Process result\r\n        }\r\n    });\r\n\r\n// Cancel if needed\r\nhandle.cancel();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"asynchronous-execution",children:"Asynchronous Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute statements without blocking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"sql.execute_async(nullptr, nullptr, stmt, params,\r\n    [](ignite_result<result_set> result) {\r\n        if (!result.has_error()) {\r\n            auto rs = std::move(result).value();\r\n            for (const auto& row : rs.current_page()) {\r\n                // Process row\r\n            }\r\n        }\r\n    });\n"})}),"\n",(0,s.jsx)(n.p,{children:"Execute scripts asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql.execute_script_async(nullptr, script, {},\r\n    [](ignite_result<void> result) {\r\n        if (!result.has_error()) {\r\n            std::cout << "Script completed" << std::endl;\r\n        }\r\n    });\n'})}),"\n",(0,s.jsx)(n.h2,{id:"data-type-mapping",children:"Data Type Mapping"}),"\n",(0,s.jsx)(n.p,{children:"C++ types map to SQL types:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"C++ Type"}),(0,s.jsx)(n.th,{children:"SQL Type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bool"})}),(0,s.jsx)(n.td,{children:"BOOLEAN"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int8_t"})}),(0,s.jsx)(n.td,{children:"TINYINT"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int16_t"})}),(0,s.jsx)(n.td,{children:"SMALLINT"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int32_t"})}),(0,s.jsx)(n.td,{children:"INTEGER"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"int64_t"})}),(0,s.jsx)(n.td,{children:"BIGINT"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"float"})}),(0,s.jsx)(n.td,{children:"REAL"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"double"})}),(0,s.jsx)(n.td,{children:"DOUBLE"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"std::string"})}),(0,s.jsx)(n.td,{children:"VARCHAR"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"std::vector<std::byte>"})}),(0,s.jsx)(n.td,{children:"VARBINARY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"uuid"})}),(0,s.jsx)(n.td,{children:"UUID"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite_date"})}),(0,s.jsx)(n.td,{children:"DATE"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite_time"})}),(0,s.jsx)(n.td,{children:"TIME"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite_timestamp"})}),(0,s.jsx)(n.td,{children:"TIMESTAMP"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite_date_time"})}),(0,s.jsx)(n.td,{children:"DATETIME"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"big_decimal"})}),(0,s.jsx)(n.td,{children:"DECIMAL"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"big_integer"})}),(0,s.jsx)(n.td,{children:"DECIMAL"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Handle SQL errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'try {\r\n    auto result = sql.execute(nullptr, nullptr, stmt, params);\r\n} catch (const ignite_error& e) {\r\n    std::cerr << "SQL error: " << e.what_str() << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"With async operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'sql.execute_async(nullptr, nullptr, stmt, params,\r\n    [](ignite_result<result_set> result) {\r\n        if (result.has_error()) {\r\n            std::cerr << "Error: " << result.error().what_str() << std::endl;\r\n        } else {\r\n            // Process result\r\n        }\r\n    });\n'})}),"\n",(0,s.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../sql",children:"SQL Reference"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./tables-api",children:"Tables API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./transactions-api",children:"Transactions API"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);