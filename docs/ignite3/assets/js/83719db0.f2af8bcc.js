"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[213],{6430:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sql-tuning/using-explain","title":"How to Improve Queries With EXPLAIN Command","description":"{/*","source":"@site/versioned_docs/version-3.0.0/sql-tuning/using-explain.md","sourceDirName":"sql-tuning","slug":"/sql-tuning/using-explain","permalink":"/docs/ignite3/3.0.0/sql-tuning/using-explain","draft":false,"unlisted":false,"tags":[],"version":"3.0.0","frontMatter":{"title":"How to Improve Queries With EXPLAIN Command","sidebar_label":"Using EXPLAIN"},"sidebar":"tutorialSidebar","previous":{"title":"SQL Performance Tuning","permalink":"/docs/ignite3/3.0.0/sql-tuning/"},"next":{"title":"General Configuration Tips","permalink":"/docs/ignite3/3.0.0/general-tips"}}');var i=r(74848),a=r(28453);const t={title:"How to Improve Queries With EXPLAIN Command",sidebar_label:"Using EXPLAIN"},l=void 0,o={},d=[{value:"EXPLAIN Command Syntax",id:"explain-command-syntax",level:2},{value:"Understanding The Output",id:"understanding-the-output",level:2},{value:"Operator Naming",id:"operator-naming",level:3},{value:"Hierarchical Plan Structure",id:"hierarchical-plan-structure",level:3},{value:"Common Query Optimization Issues",id:"common-query-optimization-issues",level:2},{value:"Full Scan Instead of Index Scan",id:"full-scan-instead-of-index-scan",level:2},{value:"Suboptimal Indexes",id:"suboptimal-indexes",level:2},{value:"Unexpected Sort Operation",id:"unexpected-sort-operation",level:2},{value:"Performance Impact of Correlated Subqueries",id:"performance-impact-of-correlated-subqueries",level:2},{value:"Excessive Sorting",id:"excessive-sorting",level:2},{value:"Select Count Optimization",id:"select-count-optimization",level:2},{value:"Index Scan Without Exact Search Bounds",id:"index-scan-without-exact-search-bounds",level:2},{value:"Prohibit Index Usage",id:"prohibit-index-usage",level:3},{value:"Manual Type Casting",id:"manual-type-casting",level:3},{value:"Colocation Usage",id:"colocation-usage",level:2},{value:"Comprehensive EXPLAIN Examples",id:"comprehensive-explain-examples",level:2},{value:"Example: Complex Join Query",id:"example-complex-join-query",level:3},{value:"Example: Query Mapping",id:"example-query-mapping",level:3}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsxs)(n.p,{children:["The SQL ",(0,i.jsx)(n.code,{children:"EXPLAIN"})," command is a powerful tool used to analyze and understand the execution plan of a query without actually executing it."]}),"\n",(0,i.jsx)(n.p,{children:"When you use the EXPLAIN command, it returns the query execution plan, which includes details such as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The order in which tables are accessed."}),"\n",(0,i.jsx)(n.li,{children:"The type of join operations used (for example, nested loops, hash joins, or merge joins)."}),"\n",(0,i.jsx)(n.li,{children:"Any indexes that are used to speed up data retrieval."}),"\n",(0,i.jsx)(n.li,{children:"Estimated costs and row counts for different parts of the query."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This information is crucial for optimizing query performance, identifying bottlenecks, and making informed decisions about database schema design and indexing strategies."}),"\n",(0,i.jsx)(n.h2,{id:"explain-command-syntax",children:"EXPLAIN Command Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Apache Ignite supports two variations of the ",(0,i.jsx)(n.code,{children:"EXPLAIN"})," command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN [PLAN | MAPPING] FOR <query>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If neither ",(0,i.jsx)(n.code,{children:"PLAN"})," nor ",(0,i.jsx)(n.code,{children:"MAPPING"})," is specified, then ",(0,i.jsx)(n.code,{children:"PLAN"})," is implicit."]}),"\n",(0,i.jsx)(n.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"PLAN"})," - explains query in terms of relational operators tree. This representation is suitable for investigation of performance issues related to the optimizer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MAPPING"})," - explains query in terms of mapping of query fragment to a particular node of the cluster. This representation is suitable for investigation of performance issues related to the data colocation."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN SELECT * FROM lineitem;\r\nEXPLAIN PLAN FOR SELECT * FROM lineitem;\r\nEXPLAIN MAPPING FOR SELECT * FROM lineitem;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-output",children:"Understanding The Output"}),"\n",(0,i.jsx)(n.p,{children:"Each query plan is represented as a tree-like structure composed of relational operators."}),"\n",(0,i.jsx)(n.p,{children:"A node in the plan includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"name"}),", indicating the relational operator (e.g., ",(0,i.jsx)(n.code,{children:"TableScan"}),", ",(0,i.jsx)(n.code,{children:"IndexScan"}),", ",(0,i.jsx)(n.code,{children:"Sort"}),", ",(0,i.jsx)(n.code,{children:"Join"})," types)"]}),"\n",(0,i.jsxs)(n.li,{children:["A set of ",(0,i.jsx)(n.strong,{children:"attributes"}),", relevant to that specific operator"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"OperatorName\r\n    attribute1: value1\r\n    attribute2: value2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operator-naming",children:"Operator Naming"}),"\n",(0,i.jsx)(n.p,{children:"The operator name reflects the specific algorithm or strategy used. For example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TableScan"})," \u2013 Full scan of a base table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"IndexScan"})," \u2013 Access via index, possibly sorted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Sort"})," \u2013 Explicit sorting step."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"HashJoin"}),", ",(0,i.jsx)(n.code,{children:"MergeJoin"}),", ",(0,i.jsx)(n.code,{children:"NestedLoopJoin"})," \u2013 Types of join algorithms."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Limit"}),", ",(0,i.jsx)(n.code,{children:"Project"}),", ",(0,i.jsx)(n.code,{children:"Exchange"})," \u2013 Execution-related transformations and controls."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-plan-structure",children:"Hierarchical Plan Structure"}),"\n",(0,i.jsxs)(n.p,{children:["The plan is structured as a ",(0,i.jsx)(n.strong,{children:"tree"}),", where:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leaf nodes"})," represent data sources (e.g., ",(0,i.jsx)(n.code,{children:"TableScan"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Internal nodes"})," represent data transformations (e.g., ",(0,i.jsx)(n.code,{children:"Join"}),", ",(0,i.jsx)(n.code,{children:"Sort"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The root node"})," (topmost) is the final operator that produces the result"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-query-optimization-issues",children:"Common Query Optimization Issues"}),"\n",(0,i.jsx)(n.p,{children:"SQL EXPLAIN output analysis can help you optimize slow query execution. You can avoid common bottlenecks in SQL execution by following these guidelines:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Avoid scanning an entire table."}),"\n",(0,i.jsx)(n.li,{children:"Avoid scanning non-optimal indexes."}),"\n",(0,i.jsx)(n.li,{children:"Avoid suboptimal join ordering or join algorithm."}),"\n",(0,i.jsx)(n.li,{children:"Ensure optimal data colocation for your queries."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the following sections, we will see some common issues with queries and ways to identify and fix them."}),"\n",(0,i.jsx)(n.h2,{id:"full-scan-instead-of-index-scan",children:"Full Scan Instead of Index Scan"}),"\n",(0,i.jsx)(n.p,{children:"Suppose related sql execution flow looks like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR);\r\nCREATE INDEX t_col1_idx ON t(col1);\r\n\r\nSELECT id FROM t WHERE col1 = '1';\n"})}),"\n",(0,i.jsx)(n.p,{children:"And possible EXPLAIN output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   TableScan\r\n       table: PUBLIC.T\r\n       predicate: =(COL1, _UTF-8'1')\r\n       fieldNames: [ID]\r\n       est: (rows=1)\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"For simplicity, here and below, information that is not related to the example is omitted from the EXPLAIN output."})}),"\n",(0,i.jsxs)(n.p,{children:["We can see a full scan (",(0,i.jsx)(n.strong,{children:"TableScan"})," operator) with predicate.\r\nThe execution planner chooses which scan implementation (",(0,i.jsx)(n.strong,{children:"TableScan"})," or ",(0,i.jsx)(n.strong,{children:"IndexScan"}),") to use.\r\nIf you expect that index scan is preferable, you can use the ",(0,i.jsx)(n.code,{children:"FORCE_INDEX"})," hint to manually force ",(0,i.jsx)(n.code,{children:"IndexScan"})," approach:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX(t_col1_idx) */ id FROM t WHERE col1 = '1';\n"})}),"\n",(0,i.jsx)(n.p,{children:"Will show a different plan, like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_IDX\r\n       type: SORTED\r\n       predicate: =(COL1, _UTF-8'1')\r\n       searchBounds: [ExactBounds [bound=_UTF-8'1']]\r\n       ieldNames: [ID]\r\n       collation: []\r\n       est: (rows=1)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"suboptimal-indexes",children:"Suboptimal Indexes"}),"\n",(0,i.jsx)(n.p,{children:"Indexes with less prediction can be chosen, for example schema and query may look as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR, col2 VARCHAR);\r\nCREATE INDEX t_col1_col2_idx ON T(col1, col2);\r\nCREATE INDEX t_col1_idx ON t(col1);\r\n\r\nSELECT id FROM t WHERE col1 = '1' AND col2 = '2';\n"})}),"\n",(0,i.jsx)(n.p,{children:"and a possible plan would be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_IDX\r\n       ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see that the execution uses the ",(0,i.jsx)(n.strong,{children:"T_COL1_IDX"})," index, through both predicates ",(0,i.jsx)(n.strong,{children:"COL1 = '1' AND COL2 = '2'"})," are involved and the ",(0,i.jsx)(n.strong,{children:"T_COL1_COL2_IDX"})," is preferable. In this case, the optimal plan would be:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_COL2_IDX\r\n       ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use the ",(0,i.jsx)(n.code,{children:"FORCE_INDEX"})," hint to achieve this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX(t_col1_col2_idx) */ id FROM t WHERE col1 = '1' AND col2 = '2';\n"})}),"\n",(0,i.jsx)(n.h2,{id:"unexpected-sort-operation",children:"Unexpected Sort Operation"}),"\n",(0,i.jsx)(n.p,{children:"By default, sorted indexes store their entries in ascending order.\r\nYou can adjust the ordering of a sorted index by including the options ASC or DESC."}),"\n",(0,i.jsx)(n.p,{children:"Let's suppose the schema and related query look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1 (id INT PRIMARY KEY, col1 VARCHAR);\r\nCREATE TABLE t2 (id INT PRIMARY KEY, col1 VARCHAR);\r\nCREATE INDEX t1_col1_desc_idx ON t1(col1 DESC);\r\nCREATE INDEX t2_col1_idx ON t2(col1);\r\n\r\nSELECT t1.id as t1id, t2.id as t2id FROM t1 JOIN t2 USING (col1);\n"})}),"\n",(0,i.jsx)(n.p,{children:"And the possible execution plan looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   MergeJoin\r\n         ...\r\n       Sort\r\n           collation: [COL1 ASC]\r\n           ...\r\n       IndexScan\r\n           index: T2_COL1_IDX\r\n           ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, the planner adds the ",(0,i.jsx)(n.strong,{children:"Sort"})," operation before performing the ",(0,i.jsx)(n.strong,{children:"IndexScan"}),",\r\nas the index used is sorted in descending order, while ascending order is required."]}),"\n",(0,i.jsxs)(n.p,{children:["Extra ",(0,i.jsx)(n.strong,{children:"Sort"})," operations adds performance costs, and we can avoid it by creating an index with the appropriate sort ordering:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX t1_col1_idx ON t1(col1);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And plan will no longer display the ",(0,i.jsx)(n.strong,{children:"Sort"})," operation, improving query execution speed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   MergeJoin\r\n         ...\r\n       IndexScan\r\n           index: T1_COL1_IDX\r\n           ...\r\n       IndexScan\r\n           index: T2_COL1_IDX\r\n           ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-impact-of-correlated-subqueries",children:"Performance Impact of Correlated Subqueries"}),"\n",(0,i.jsx)(n.p,{children:"The SQL-99 standard allows for nested subqueries at nearly all places within a query, so Ignite 3 supports nested subqueries, both correlated and not.\r\nPerformance of certain complex correlated subqueries may be insufficient. Let's consider a correlated query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);\r\nCREATE TABLE dept(id INTEGER PRIMARY KEY, name VARCHAR);\r\n\r\nSELECT emp.name, (SELECT dept.name FROM dept WHERE emp.dept_id=dept.id)\r\nFROM emp\r\nWHERE emp.salary > 1000;\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can see nested correlated subquery here, lets check the plan:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   CorrelatedNestedLoopJoin\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.EMP\r\n           predicate: >(SALARY, 1000)\r\n           ...\r\n     ColocatedHashAggregate\r\n         ...\r\n         TableScan\r\n             table: PUBLIC.DEPT\r\n             predicate: =($cor1.DEPT_ID, ID)\r\n             ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The example above shows the slow ",(0,i.jsx)(n.strong,{children:"CorrelatedNestedLoopJoin"})," operation. Queries with this operation may cause a number of issues:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Such subqueries may become bottlenecks."}),"\n",(0,i.jsx)(n.li,{children:"Queries can cause high CPU load."}),"\n",(0,i.jsx)(n.li,{children:"Certain queries may perform slower than expected."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If performance issues are found in similar queries, it would be more\r\nefficient to rewrite the query without nested subqueries, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT emp.name, dept.name\r\nFROM emp, dept\r\nWHERE emp.salary > 1000 AND emp.dept_id=dept.id;\n"})}),"\n",(0,i.jsx)(n.p,{children:"And new plan becomes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"     HashJoin\r\n         predicate: =(DEPT_ID, ID)\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.EMP\r\n           predicate: >(SALARY, 1000)\r\n           ...\r\n         TableScan\r\n             table: PUBLIC.DEPT\r\n             ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Without the ",(0,i.jsx)(n.strong,{children:"CorrelatedNestedLoopJoin"})," operation, the query should perform much better than the previous one."]}),"\n",(0,i.jsx)(n.h2,{id:"excessive-sorting",children:"Excessive Sorting"}),"\n",(0,i.jsx)(n.p,{children:"Lets explain we have an index involved two columns one of them is participate in predicate and other in ordering, or in sql terms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);\r\nCREATE INDEX emp_salary_name_idx ON emp(salary, name);\r\n\r\nSELECT dept_id FROM emp WHERE salary = 1 ORDER BY name;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expectations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Index need to be used here."}),"\n",(0,i.jsxs)(n.li,{children:["No additional sort is needed because index is ordered by ",(0,i.jsx)(n.strong,{children:"name"})," column is satisfies initial query ordering."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"But the real execution plan shows a different result:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"     Sort\r\n         collation: [NAME ASC]\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.EMP\r\n           predicate: =(SALARY, 1)\r\n           ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see a redundant ",(0,i.jsx)(n.strong,{children:"Sort"})," operator. A bit query refactoring can help to avoid excessive sorting:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT dept_id FROM emp WHERE salary = 1 ORDER BY salary, name;\n"})}),"\n",(0,i.jsx)(n.p,{children:"And the plan becomes as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"     IndexScan\r\n         table: PUBLIC.EMP\r\n         index: EMP_SALARY_NAME_IDX\r\n         predicate: =(SALARY, 1)\r\n         ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"select-count-optimization",children:"Select Count Optimization"}),"\n",(0,i.jsx)(n.p,{children:"Some queries can be optimized to use more optimal plans which brings performance speed up. For example, plan for:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT COUNT(*) FROM emp;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Can look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:" SelectCount\r\n     table: PUBLIC.EMP\r\n     est: (rows=43)\r\n     ...\n"})}),"\n",(0,i.jsx)(n.p,{children:"But there are numerous cases where such optimization is not applicable. In such a cases, a plan can be different and the execution may require more time."}),"\n",(0,i.jsx)(n.p,{children:"The same query as above, but with explicit transaction may produce a different plan, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   ReduceSortAggregate\r\n       ...\r\n       MapSortAggregate\r\n           ...\r\n         TableScan\r\n             table: PUBLIC.EMP\r\n             est: (rows=43)\r\n             ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"index-scan-without-exact-search-bounds",children:"Index Scan Without Exact Search Bounds"}),"\n",(0,i.jsx)(n.p,{children:"Table scans are available in two implementations: direct table scan and scan through index.\r\nIndex scans contain predicate and search bounds.\r\nPredicate provides final rows comparison. If search bounds are absentm the query degenerates into table scan through index scan (requiring an additional store look up), with further predicate comparison, that incurs additional performance overhead costs."}),"\n",(0,i.jsx)(n.p,{children:"Let's suppose we have schema and query like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INTEGER PRIMARY KEY, col1 DECIMAL(5, 3));\r\nCREATE INDEX t_col1_idx ON t(col1);\r\n\r\nSELECT id FROM t WHERE col1 = 43;\n"})}),"\n",(0,i.jsx)(n.p,{children:"And possible plan would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_IDX\r\n       predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)\r\n       ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see here - only ",(0,i.jsx)(n.strong,{children:"predicate"})," (and no ",(0,i.jsx)(n.strong,{children:"searchBounds"}),") which means that ",(0,i.jsx)(n.strong,{children:"all"})," rows from index will go through predicate and bring additional performance penalty."]}),"\n",(0,i.jsx)(n.p,{children:"Two type of solutions are possible here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You can prohibit suboptimal index usage;"}),"\n",(0,i.jsx)(n.li,{children:"You can explicitly help the planner with type derivation."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"prohibit-index-usage",children:"Prohibit Index Usage"}),"\n",(0,i.jsxs)(n.p,{children:["For the first approach, use the ",(0,i.jsx)(n.strong,{children:"NO_INDEX"})," hint to prohibit index usage:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ NO_INDEX */ id FROM t WHERE col1 = 43;\r\n\r\n-- or with direct index mention:\r\n\r\nSELECT /*+ NO_INDEX(t_col1_idx) */ id FROM t WHERE col1 = 43;\n"})}),"\n",(0,i.jsx)(n.p,{children:"As a result, you will have a plan similar to this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   TableScan\r\n       table: PUBLIC.T\r\n       predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)\r\n       ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"manual-type-casting",children:"Manual Type Casting"}),"\n",(0,i.jsx)(n.p,{children:"You can append additional cast to the same query to explicitly cast data as a specific type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT id FROM t WHERE col1 = 43::DECIMAL(5, 3);\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_IDX\r\n       predicate: =(COL1, 43.000)\r\n       searchBounds: [ExactBounds [bound=43.000:DECIMAL(5, 3)]]\r\n       ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see here both ",(0,i.jsx)(n.strong,{children:"searchBounds"})," and ",(0,i.jsx)(n.strong,{children:"predicate"})," which means that only exact lookup through index will be involved."]}),"\n",(0,i.jsx)(n.p,{children:"The same case as above but for a bit complicated query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 INT);\r\nCREATE INDEX t_col1_asc_idx ON t (col1);\r\n\r\nSELECT * FROM t WHERE col1::varchar = SUBSTR(CURRENT_DATE::varchar, 4);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Possible plan:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_IDX\r\n       predicate: =(CAST(COL1):VARCHAR CHARACTER SET "UTF-8", SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4))\r\n       ...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["And we also can see that no ",(0,i.jsx)(n.strong,{children:"search bounds"})," are involved here."]}),"\n",(0,i.jsx)(n.p,{children:"Try to change it like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM t WHERE col1 = SUBSTR(CURRENT_DATE::varchar, 4)::int;\n"})}),"\n",(0,i.jsx)(n.p,{children:"And the possible plan will become:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'   IndexScan\r\n       table: PUBLIC.T\r\n       index: T_COL1_ASC_IDX\r\n       predicate: =(COL1, CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER NOT NULL)\r\n       searchBounds: [ExactBounds [bound=CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER]]\r\n       ...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We can see that ",(0,i.jsx)(n.strong,{children:"searchBounds"})," are present, thus more productive execution flow is expected here."]}),"\n",(0,i.jsx)(n.h2,{id:"colocation-usage",children:"Colocation Usage"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned above, right colocated columns choice plays a significant role in query execution performance.\r\nFor example, if initially tables are created without any thoughts about further usage columns colocation you can have the following scenario:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- by default, the table is implicitly colocated by PRIMARY KEY\r\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));\r\n\r\n-- implicitly colocated by PRIMARY KEY\r\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(name, id));\n"})}),"\n",(0,i.jsx)(n.p,{children:"And query as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"SELECT emp.name, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id AND emp.salary > 1000;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Bring plan like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"   HashJoin\r\n       predicate: =(DEPT_ID, ID)\r\n       ...\r\n     Exchange\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.EMP\r\n           ...\r\n     Exchange\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.DEPT\r\n           ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see two ",(0,i.jsx)(n.strong,{children:"Exchange"})," operators, which means that all rows are transferred into a single node and then are joined.\r\nThis execution flow brings a performance cost and slows down query execution."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's try to improve it by adding explicit colocation for the ",(0,i.jsx)(n.strong,{children:"dept"})," table by the ",(0,i.jsx)(n.strong,{children:"ID"})," column:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- implicitly colocated by PRIMARY KEY\r\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));\r\n-- explicitly colocated by ID\r\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(name, id)) COLOCATE BY (id);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now the dependent rows from ",(0,i.jsx)(n.strong,{children:"emp"})," table are transferred into the appropriate\r\nnode where ",(0,i.jsx)(n.strong,{children:"dept"})," holds the rows according to ",(0,i.jsx)(n.strong,{children:"DEPT.ID"})," distribution:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:'     HashJoin\r\n         predicate: =(DEPT_ID, ID)\r\n         ...\r\n       Exchange\r\n           distribution: table PUBLIC.DEPT in zone "Default" by [DEPT_ID]\r\n           ...\r\n         TableScan\r\n             table: PUBLIC.EMP\r\n             ...\r\n       TableScan\r\n           table: PUBLIC.DEPT\r\n           ...\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Only one ",(0,i.jsx)(n.strong,{children:"Exchange"})," operator for now, which, once again, mean only rows transferring\r\nfrom ",(0,i.jsx)(n.strong,{children:"emp"})," table to appropriate ",(0,i.jsx)(n.strong,{children:"dept"})," one."]}),"\n",(0,i.jsx)(n.p,{children:"And finally, both join predicate related columns are colocated:"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The following colocation example will only work if the ",(0,i.jsx)(n.strong,{children:"emp"})," and ",(0,i.jsx)(n.strong,{children:"dept"})," tables belong to the same distribution zone."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"-- explicitly colocated by DEPT_ID\r\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name)) COLOCATE BY(dept_id);\r\n-- explicitly colocated by ID\r\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(id, name)) COLOCATE BY(id);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, the ",(0,i.jsx)(n.strong,{children:"emp"})," and ",(0,i.jsx)(n.strong,{children:"dept"})," tables are both colocated."]}),"\n",(0,i.jsx)(n.p,{children:"And the final plan will look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"     HashJoin\r\n        predicate: =(DEPT_ID, ID)\r\n         ...\r\n       TableScan\r\n           table: PUBLIC.EMP\r\n           ...\r\n       TableScan\r\n           table: PUBLIC.DEPT\r\n           ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["No ",(0,i.jsx)(n.strong,{children:"Exchange"})," operators are involved in the explanation, which means that no excessive rows transfer has occurred."]}),"\n",(0,i.jsx)(n.h2,{id:"comprehensive-explain-examples",children:"Comprehensive EXPLAIN Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-complex-join-query",children:"Example: Complex Join Query"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN PLAN FOR\r\n SELECT\r\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\r\n   FROM Users U, Reviews R, Products P\r\n  WHERE U.UserID = R.UserID\r\n    AND R.ProductID = P.ProductID\r\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Project\r\n    fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\r\n    projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\r\n    est: (rows=16650)\r\n  HashJoin\r\n      predicate: =(USERID$0, USERID)\r\n      fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\r\n      type: inner\r\n      est: (rows=16650)\r\n    HashJoin\r\n        predicate: =(PRODUCTID, PRODUCTID$0)\r\n        fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\r\n        type: inner\r\n        est: (rows=16650)\r\n      Exchange\r\n          distribution: single\r\n          est: (rows=50000)\r\n        TableScan\r\n            table: PUBLIC.REVIEWS\r\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\r\n            est: (rows=50000)\r\n      Exchange\r\n          distribution: single\r\n          est: (rows=1665)\r\n        TableScan\r\n            table: PUBLIC.PRODUCTS\r\n            predicate: =(PRODUCTNAME, ||(_UTF-8'Product_', CAST(?0):VARCHAR CHARACTER SET \"UTF-8\"))\r\n            fieldNames: [PRODUCTID, PRODUCTNAME]\r\n            est: (rows=1665)\r\n    Exchange\r\n        distribution: single\r\n        est: (rows=10000)\r\n      TableScan\r\n          table: PUBLIC.USERS\r\n          fieldNames: [USERID, USERNAME]\r\n          est: (rows=10000)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This execution plan represents a query that joins three tables: ",(0,i.jsx)(n.code,{children:"USERS"}),", ",(0,i.jsx)(n.code,{children:"REVIEWS"}),", and ",(0,i.jsx)(n.code,{children:"PRODUCTS"}),", and selects four fields after filtering by product name."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Project"})," (root node): Outputs the final selected fields \u2014 ",(0,i.jsx)(n.code,{children:"USERNAME"}),", ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),", ",(0,i.jsx)(n.code,{children:"REVIEWTEXT"}),", and ",(0,i.jsx)(n.code,{children:"RATING"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"HashJoins"})," (two levels): Perform the inner joins.\r\n** The first (bottom-most) joins ",(0,i.jsx)(n.code,{children:"REVIEWS"})," with ",(0,i.jsx)(n.code,{children:"PRODUCTS"})," on ",(0,i.jsx)(n.code,{children:"PRODUCTID"}),".\r\n** The second joins the result with ",(0,i.jsx)(n.code,{children:"USERS"})," on ",(0,i.jsx)(n.code,{children:"USERID"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TableScans"}),": Each table is scanned:\r\n** ",(0,i.jsx)(n.code,{children:"REVIEWS"})," is fully scanned.\r\n** ",(0,i.jsx)(n.code,{children:"PRODUCTS"})," is scanned with a filter on ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),".\r\n** ",(0,i.jsx)(n.code,{children:"USERS"})," is fully scanned."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exchange"})," nodes: Indicate data redistribution between operators."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each node includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fieldNames"}),": Output columns at that stage."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"predicate"}),": Join or filter condition."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"est"}),": Estimated number of rows at that point in the plan."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-query-mapping",children:"Example: Query Mapping"}),"\n",(0,i.jsx)(n.p,{children:"A result of EXPLAIN MAPPING command includes additional metadata providing insight at how the query is mapped on cluster topology. So, for the command like below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN MAPPING FOR\r\n SELECT\r\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\r\n   FROM Users U, Reviews R, Products P\r\n  WHERE U.UserID = R.UserID\r\n    AND R.ProductID = P.ProductID\r\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Fragment#0 root\r\n  distribution: single\r\n  executionNodes: [node_1]\r\n  tree:\r\n    Project\r\n        fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\r\n        projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\r\n        est: (rows=1)\r\n      HashJoin\r\n          predicate: =(USERID$0, USERID)\r\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\r\n          type: inner\r\n          est: (rows=1)\r\n        HashJoin\r\n            predicate: =(PRODUCTID, PRODUCTID$0)\r\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\r\n            type: inner\r\n            est: (rows=1)\r\n          Receiver\r\n              fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\r\n              sourceFragmentId: 1\r\n              est: (rows=1)\r\n          Receiver\r\n              fieldNames: [PRODUCTID, PRODUCTNAME]\r\n              sourceFragmentId: 2\r\n              est: (rows=1)\r\n        Receiver\r\n            fieldNames: [USERID, USERNAME]\r\n            sourceFragmentId: 3\r\n            est: (rows=1)\r\n\r\nFragment#1\r\n  distribution: random\r\n  executionNodes: [node_1, node_2, node_3]\r\n  partitions: [REVIEWS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\r\n  tree:\r\n    Sender\r\n        distribution: single\r\n        targetFragmentId: 0\r\n        est: (rows=50000)\r\n      TableScan\r\n          table: PUBLIC.REVIEWS\r\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\r\n          est: (rows=50000)\r\n\r\nFragment#2\r\n  distribution: table PUBLIC.PRODUCTS in zone "Default"\r\n  executionNodes: [node_1, node_2, node_3]\r\n  partitions: [PRODUCTS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\r\n  tree:\r\n    Sender\r\n        distribution: single\r\n        targetFragmentId: 0\r\n        est: (rows=1665)\r\n      TableScan\r\n          table: PUBLIC.PRODUCTS\r\n          predicate: =(PRODUCTNAME, ||(_UTF-8\'Product_\', CAST(?0):VARCHAR CHARACTER SET "UTF-8"))\r\n          fieldNames: [PRODUCTID, PRODUCTNAME]\r\n          est: (rows=1665)\r\n\r\nFragment#3\r\n  distribution: table PUBLIC.USERS in zone "Default"\r\n  executionNodes: [node_1, node_2, node_3]\r\n  partitions: [USERS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\r\n  tree:\r\n    Sender\r\n        distribution: single\r\n        targetFragmentId: 0\r\n        est: (rows=10000)\r\n      TableScan\r\n          table: PUBLIC.USERS\r\n          fieldNames: [USERID, USERNAME]\r\n          est: (rows=10000)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fragment#0"})," means fragment with id=0"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"root"})," marks a fragment which is considered as root fragment, i.e. a fragment which represents user's cursor"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"distribution"})," attribute provides an insight into which mapping strategy was applied to this particular fragment"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"executionNodes"})," attribute provides a list of nodes this fragment will be executed on"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"partitions"})," attribute provides an insight into which partitions of which tables will be read from which nodes"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"tree"})," attribute specifies which part of the relational tree corresponds to this fragment"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The output above shows how the query is broken into multiple execution fragments and distributed across the cluster. It gives insight into both the logical execution plan and how it maps to the physical topology."}),"\n",(0,i.jsxs)(n.p,{children:["The query starts execution in ",(0,i.jsx)(n.em,{children:"Fragment#0"}),", which serves as the root of the plan \u2014 this is where the final result is produced. It runs on a single node (",(0,i.jsx)(n.code,{children:"node_1"}),") and contains the main logic of the query, including the projection and two nested hash joins. Instead of scanning tables directly, it receives data from other fragments through ",(0,i.jsx)(n.code,{children:"Receiver"})," operators. These incoming streams correspond to the ",(0,i.jsx)(n.code,{children:"REVIEWS"}),", ",(0,i.jsx)(n.code,{children:"PRODUCTS"}),", and ",(0,i.jsx)(n.code,{children:"USERS"})," tables."]}),"\n",(0,i.jsxs)(n.p,{children:["The actual table scans happen in ",(0,i.jsx)(n.em,{children:"Fragments 1 through 3"}),", each responsible for one of the involved tables. These fragments operate in parallel across the cluster. Each performs a scan on its respective table and then sends the results back to Fragment#0."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#1"})," handles the ",(0,i.jsx)(n.code,{children:"REVIEWS"})," table. It runs on all nodes and uses a random distribution strategy. Data is partitioned across nodes, and after scanning the table, results are sent upstream."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#2"})," is in charge of the ",(0,i.jsx)(n.code,{children:"PRODUCTS"})," table. It also spans all nodes but follows a zone-based distribution linked to the table's partitioning. There's a filter applied to ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),", which limits the amount of data sent to the root."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#3"})," covers the ",(0,i.jsx)(n.code,{children:"USERS"})," table. Like the others, it's distributed and reads from table partitions spread across the cluster."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each fragment includes metadata such as the nodes it's executed on, how data is partitioned, and how results are sent between fragments. This layout provides a clear view of not only how the query is logically processed, but also how the workload is split and coordinated in a distributed environment."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(96540);const i={},a=s.createContext(i);function t(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);