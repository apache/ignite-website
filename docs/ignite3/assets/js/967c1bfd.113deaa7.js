"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2355],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},98415:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api-reference/native-clients/cpp/compute-api","title":"Compute API","description":"The Compute API executes distributed compute jobs across cluster nodes. It supports single-node execution, multi-node execution, colocated execution, and broadcast patterns.","source":"@site/docs/api-reference/native-clients/cpp/compute-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/compute-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Compute API","id":"compute-api","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Transactions API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/transactions-api"},"next":{"title":"Network API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/network-api"}}');var s=t(74848),o=t(28453);const i={title:"Compute API",id:"compute-api",sidebar_position:5},a="Compute API",c={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Job Execution Model",id:"job-execution-model",level:3},{value:"Job Targeting",id:"job-targeting",level:3},{value:"Job Descriptors",id:"job-descriptors",level:3},{value:"Execution Handles",id:"execution-handles",level:3},{value:"Broadcast Execution",id:"broadcast-execution",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Getting Cluster Nodes",id:"getting-cluster-nodes",level:3},{value:"Submitting Jobs",id:"submitting-jobs",level:3},{value:"Async Submission",id:"async-submission",level:3},{value:"Job Targets",id:"job-targets",level:2},{value:"Single Node Target",id:"single-node-target",level:3},{value:"Any Node Target",id:"any-node-target",level:3},{value:"Colocated Target",id:"colocated-target",level:3},{value:"Job Descriptors",id:"job-descriptors-1",level:2},{value:"Building Descriptors",id:"building-descriptors",level:3},{value:"Descriptor Components",id:"descriptor-components",level:3},{value:"Job Execution",id:"job-execution",level:2},{value:"Monitoring Execution",id:"monitoring-execution",level:3},{value:"Retrieving Results",id:"retrieving-results",level:3},{value:"Execution Information",id:"execution-information",level:3},{value:"Job Control",id:"job-control",level:2},{value:"Cancelling Jobs",id:"cancelling-jobs",level:3},{value:"Changing Priority",id:"changing-priority",level:3},{value:"Broadcast Execution",id:"broadcast-execution-1",level:2},{value:"Broadcasting to Multiple Nodes",id:"broadcasting-to-multiple-nodes",level:3},{value:"Async Broadcast",id:"async-broadcast",level:3},{value:"Processing Broadcast Results",id:"processing-broadcast-results",level:3},{value:"Binary Arguments",id:"binary-arguments",level:2},{value:"Passing Primitive Arguments",id:"passing-primitive-arguments",level:3},{value:"Passing Complex Arguments",id:"passing-complex-arguments",level:3},{value:"No Argument Jobs",id:"no-argument-jobs",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Handling Job Errors",id:"handling-job-errors",level:3},{value:"Handling Submission Errors",id:"handling-submission-errors",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Map-Reduce Pattern",id:"map-reduce-pattern",level:3},{value:"Colocated Processing",id:"colocated-processing",level:3},{value:"Batch Job Submission",id:"batch-job-submission",level:3},{value:"Reference",id:"reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"compute-api",children:"Compute API"})}),"\n",(0,s.jsx)(n.p,{children:"The Compute API executes distributed compute jobs across cluster nodes. It supports single-node execution, multi-node execution, colocated execution, and broadcast patterns."}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"job-execution-model",children:"Job Execution Model"}),"\n",(0,s.jsx)(n.p,{children:"Jobs are Java classes deployed on cluster nodes. The C++ client submits job execution requests with binary arguments. The server executes the job and returns results as binary objects."}),"\n",(0,s.jsx)(n.h3,{id:"job-targeting",children:"Job Targeting"}),"\n",(0,s.jsx)(n.p,{children:"Jobs execute on specific nodes based on targeting strategies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Node"})," - Execute on one specific node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Any Node"})," - Execute on any node from a set"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Colocated"})," - Execute on the node containing table partition data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Broadcast"})," - Execute on all nodes in a set"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"job-descriptors",children:"Job Descriptors"}),"\n",(0,s.jsx)(n.p,{children:"Job descriptors specify the job class name, deployment units, and execution options. Deployment units identify code locations on the cluster. Execution options configure priority and other runtime parameters."}),"\n",(0,s.jsx)(n.h3,{id:"execution-handles",children:"Execution Handles"}),"\n",(0,s.jsx)(n.p,{children:"Submit operations return execution handles. Handles provide job monitoring, result retrieval, priority changes, and cancellation. Results become available after job completion."}),"\n",(0,s.jsx)(n.h3,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,s.jsx)(n.p,{children:"Broadcast submits a single job to multiple nodes. It returns a broadcast execution handle containing individual execution handles for each node."}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.h3,{id:"getting-cluster-nodes",children:"Getting Cluster Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Retrieve cluster topology:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'using namespace ignite;\r\n\r\nauto nodes = client.get_cluster_nodes();\r\n\r\nfor (const auto& node : nodes) {\r\n    std::cout << "Node: " << node.get_name() << std::endl;\r\n    std::cout << "ID: " << node.get_id() << std::endl;\r\n    std::cout << "Address: " << node.get_address().host\r\n              << ":" << node.get_address().port << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"submitting-jobs",children:"Submitting Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Submit a job to any node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto compute = client.get_compute();\r\nauto nodes = client.get_cluster_nodes();\r\n\r\nauto descriptor = job_descriptor::builder("com.example.MyJob").build();\r\nauto target = job_target::any_node(nodes);\r\n\r\nbinary_object arg;  // Job argument\r\nauto execution = compute.submit(target, descriptor, arg);\r\n\r\nauto result = execution.get_result();\r\nif (result.has_value()) {\r\n    // Process result\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"async-submission",children:"Async Submission"}),"\n",(0,s.jsx)(n.p,{children:"Submit without blocking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"compute.submit_async(target, descriptor, arg,\r\n    [](ignite_result<job_execution> result) {\r\n        if (!result.has_error()) {\r\n            auto execution = std::move(result).value();\r\n            // Use execution handle\r\n        }\r\n    });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"job-targets",children:"Job Targets"}),"\n",(0,s.jsx)(n.h3,{id:"single-node-target",children:"Single Node Target"}),"\n",(0,s.jsx)(n.p,{children:"Execute on a specific node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\nauto target_node = nodes[0];\r\n\r\nauto target = job_target::node(target_node);\r\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"any-node-target",children:"Any Node Target"}),"\n",(0,s.jsx)(n.p,{children:"Execute on any node from a set:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\nauto target = job_target::any_node(nodes);\r\n\r\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create from vector:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::vector<cluster_node> node_list = {node1, node2, node3};\r\nauto target = job_target::any_node(node_list);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create from set:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::set<cluster_node> node_set = {node1, node2, node3};\r\nauto target = job_target::any_node(node_set);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"colocated-target",children:"Colocated Target"}),"\n",(0,s.jsx)(n.p,{children:"Execute on the node containing table data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple key{{"id", 42}};\r\nauto target = job_target::colocated("accounts", key);\r\n\r\nauto execution = compute.submit(target, descriptor, arg);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use qualified table names:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'qualified_name table_name = qualified_name::parse("my_schema.accounts");\r\nauto target = job_target::colocated(table_name, key);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Colocated execution minimizes network overhead by running compute jobs where data resides."}),"\n",(0,s.jsx)(n.h2,{id:"job-descriptors-1",children:"Job Descriptors"}),"\n",(0,s.jsx)(n.h3,{id:"building-descriptors",children:"Building Descriptors"}),"\n",(0,s.jsx)(n.p,{children:"Create a basic descriptor:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto descriptor = job_descriptor::builder("com.example.MyJob").build();\n'})}),"\n",(0,s.jsx)(n.p,{children:"Add deployment units:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'std::vector<deployment_unit> units{\r\n    {"my-app", "1.0.0"},\r\n    {"my-lib", "2.1.0"}\r\n};\r\n\r\nauto descriptor = job_descriptor::builder("com.example.MyJob")\r\n    .deployment_units(units)\r\n    .build();\n'})}),"\n",(0,s.jsx)(n.p,{children:"Add execution options:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'job_execution_options opts;\r\nopts.priority(10);\r\n\r\nauto descriptor = job_descriptor::builder("com.example.MyJob")\r\n    .execution_options(opts)\r\n    .build();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"descriptor-components",children:"Descriptor Components"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Job Class Name"})," - Fully qualified Java class name implementing the compute job interface"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deployment Units"})," - List of units containing job code and dependencies"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution Options"})," - Priority and other runtime configuration"]}),"\n",(0,s.jsx)(n.h2,{id:"job-execution",children:"Job Execution"}),"\n",(0,s.jsx)(n.h3,{id:"monitoring-execution",children:"Monitoring Execution"}),"\n",(0,s.jsx)(n.p,{children:"Check job state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto execution = compute.submit(target, descriptor, arg);\r\n\r\nauto state = execution.get_state();\r\nif (state.has_value()) {\r\n    // Examine state\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Get state asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"execution.get_state_async([](ignite_result<std::optional<job_state>> result) {\r\n    if (!result.has_error()) {\r\n        auto state = std::move(result).value();\r\n        if (state.has_value()) {\r\n            // Examine state\r\n        }\r\n    }\r\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"State may be unavailable if the job has expired from the execution history."}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-results",children:"Retrieving Results"}),"\n",(0,s.jsx)(n.p,{children:"Get result (blocks until completion):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto result = execution.get_result();\r\n\r\nif (result.has_value()) {\r\n    auto data = result.value();\r\n    // Process binary object\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Get result asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"execution.get_result_async([](ignite_result<std::optional<binary_object>> result) {\r\n    if (!result.has_error()) {\r\n        auto obj = std::move(result).value();\r\n        if (obj.has_value()) {\r\n            // Process result\r\n        }\r\n    }\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"execution-information",children:"Execution Information"}),"\n",(0,s.jsx)(n.p,{children:"Access execution metadata:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto job_id = execution.get_id();\r\nauto node = execution.get_node();\r\n\r\nstd::cout << "Job ID: " << job_id << std::endl;\r\nstd::cout << "Executing on: " << node.get_name() << std::endl;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"job-control",children:"Job Control"}),"\n",(0,s.jsx)(n.h3,{id:"cancelling-jobs",children:"Cancelling Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Cancel a running job:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto execution = compute.submit(target, descriptor, arg);\r\n\r\nauto result = execution.cancel();\r\n\r\nswitch (result) {\r\n    case job_execution::operation_result::SUCCESS:\r\n        std::cout << "Job cancelled" << std::endl;\r\n        break;\r\n    case job_execution::operation_result::INVALID_STATE:\r\n        std::cout << "Job already completed" << std::endl;\r\n        break;\r\n    case job_execution::operation_result::NOT_FOUND:\r\n        std::cout << "Job not found" << std::endl;\r\n        break;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Cancel asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"execution.cancel_async([](ignite_result<job_execution::operation_result> result) {\r\n    if (!result.has_error()) {\r\n        auto status = result.value();\r\n        // Check status\r\n    }\r\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"changing-priority",children:"Changing Priority"}),"\n",(0,s.jsx)(n.p,{children:"Modify job execution priority:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto execution = compute.submit(target, descriptor, arg);\r\n\r\nauto result = execution.change_priority(5);\r\n\r\nif (result == job_execution::operation_result::SUCCESS) {\r\n    std::cout << "Priority changed" << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Change priority asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"execution.change_priority_async(5,\r\n    [](ignite_result<job_execution::operation_result> result) {\r\n        // Handle result\r\n    });\n"})}),"\n",(0,s.jsx)(n.p,{children:"Higher priority values execute before lower priority jobs in the queue."}),"\n",(0,s.jsx)(n.h2,{id:"broadcast-execution-1",children:"Broadcast Execution"}),"\n",(0,s.jsx)(n.h3,{id:"broadcasting-to-multiple-nodes",children:"Broadcasting to Multiple Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Execute on all nodes in a set:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\r\n\r\nauto target = broadcast_job_target::nodes(node_set);\r\nauto broadcast = compute.submit_broadcast(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Broadcast to a single node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto target = broadcast_job_target::node(specific_node);\r\nauto broadcast = compute.submit_broadcast(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"async-broadcast",children:"Async Broadcast"}),"\n",(0,s.jsx)(n.p,{children:"Submit broadcast without blocking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"compute.submit_broadcast_async(target, descriptor, arg,\r\n    [](ignite_result<broadcast_execution> result) {\r\n        if (!result.has_error()) {\r\n            auto broadcast = std::move(result).value();\r\n            // Use broadcast execution\r\n        }\r\n    });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"processing-broadcast-results",children:"Processing Broadcast Results"}),"\n",(0,s.jsx)(n.p,{children:"Access individual executions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'auto broadcast = compute.submit_broadcast(target, descriptor, arg);\r\nauto executions = broadcast.get_job_executions();\r\n\r\nfor (auto& exec_result : executions) {\r\n    if (exec_result.has_value()) {\r\n        auto execution = exec_result.value();\r\n        auto result = execution.get_result();\r\n\r\n        if (result.has_value()) {\r\n            std::cout << "Node " << execution.get_node().get_name()\r\n                      << " result: " << /* process result */ << std::endl;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Each execution in the broadcast operates independently. Retrieve results individually from each execution handle."}),"\n",(0,s.jsx)(n.h2,{id:"binary-arguments",children:"Binary Arguments"}),"\n",(0,s.jsx)(n.h3,{id:"passing-primitive-arguments",children:"Passing Primitive Arguments"}),"\n",(0,s.jsx)(n.p,{children:"Jobs accept binary_object arguments. Wrap primitive values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"binary_object arg(42);  // Integer argument\r\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"passing-complex-arguments",children:"Passing Complex Arguments"}),"\n",(0,s.jsx)(n.p,{children:"Create binary objects from serialized data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Serialize your data structure to bytes\r\nstd::vector<std::byte> data = serialize_my_data(my_object);\r\nbinary_object arg(data);\r\n\r\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"no-argument-jobs",children:"No Argument Jobs"}),"\n",(0,s.jsx)(n.p,{children:"Pass empty binary object for jobs without arguments:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"binary_object empty_arg;\r\nauto execution = compute.submit(target, descriptor, empty_arg);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"handling-job-errors",children:"Handling Job Errors"}),"\n",(0,s.jsx)(n.p,{children:"Job execution errors propagate to the client:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'try {\r\n    auto result = execution.get_result();\r\n    // Process result\r\n} catch (const ignite_error& e) {\r\n    std::cerr << "Job failed: " << e.what_str() << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"With async operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'execution.get_result_async([](ignite_result<std::optional<binary_object>> result) {\r\n    if (result.has_error()) {\r\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\r\n    } else {\r\n        // Process result\r\n    }\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"handling-submission-errors",children:"Handling Submission Errors"}),"\n",(0,s.jsx)(n.p,{children:"Handle submission failures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'try {\r\n    auto execution = compute.submit(target, descriptor, arg);\r\n} catch (const ignite_error& e) {\r\n    std::cerr << "Submission failed: " << e.what_str() << std::endl;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Common errors include missing deployment units, invalid job class names, and network failures."}),"\n",(0,s.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsx)(n.h3,{id:"map-reduce-pattern",children:"Map-Reduce Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Submit jobs to multiple nodes and aggregate results:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\nstd::vector<job_execution> executions;\r\n\r\n// Map: Submit jobs to all nodes\r\nfor (const auto& node : nodes) {\r\n    auto target = job_target::node(node);\r\n    executions.push_back(compute.submit(target, map_job, arg));\r\n}\r\n\r\n// Reduce: Collect and aggregate results\r\nstd::vector<binary_object> results;\r\nfor (auto& execution : executions) {\r\n    auto result = execution.get_result();\r\n    if (result.has_value()) {\r\n        results.push_back(result.value());\r\n    }\r\n}\r\n\r\nauto final_result = reduce(results);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"colocated-processing",children:"Colocated Processing"}),"\n",(0,s.jsx)(n.p,{children:"Process data where it resides:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Execute compute job on the node containing this key\r\nignite_tuple key{{"customer_id", 12345}};\r\nauto target = job_target::colocated("orders", key);\r\n\r\nauto descriptor = job_descriptor::builder("com.example.OrderProcessor").build();\r\nauto execution = compute.submit(target, descriptor, arg);\r\n\r\nauto result = execution.get_result();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"batch-job-submission",children:"Batch Job Submission"}),"\n",(0,s.jsx)(n.p,{children:"Submit multiple jobs in parallel:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"std::vector<job_execution> executions;\r\n\r\nfor (const auto& work_item : work_items) {\r\n    auto execution = compute.submit(target, descriptor, work_item);\r\n    executions.push_back(std::move(execution));\r\n}\r\n\r\n// Wait for all to complete\r\nfor (auto& execution : executions) {\r\n    execution.get_result();\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../../../develop/work-with-data/compute",children:"Compute Concept"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./network-api",children:"Network API"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);