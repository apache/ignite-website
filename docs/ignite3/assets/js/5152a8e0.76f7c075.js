"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2252],{4180:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"sql-reference/explain-operators-list","title":"List Of Operators","description":"{/*","source":"@site/versioned_docs/version-3.0.0/sql-reference/explain-operators-list.md","sourceDirName":"sql-reference","slug":"/sql-reference/explain-operators-list","permalink":"/docs/ignite3/3.0.0/sql-reference/explain-operators-list","draft":false,"unlisted":false,"tags":[],"version":"3.0.0","frontMatter":{"title":"List Of Operators","sidebar_label":"Explain Operators"},"sidebar":"tutorialSidebar","previous":{"title":"EXPLAIN","permalink":"/docs/ignite3/3.0.0/sql-reference/explain-statement"},"next":{"title":"SQL Performance Tuning","permalink":"/docs/ignite3/3.0.0/sql-tuning/"}}');var r=i(74848),o=i(28453);const t={title:"List Of Operators",sidebar_label:"Explain Operators"},d=void 0,l={},c=[{value:"ColocatedHashAggregate",id:"colocatedhashaggregate",level:2},{value:"ColocatedSortAggregate",id:"colocatedsortaggregate",level:2},{value:"MapHashAggregate",id:"maphashaggregate",level:2},{value:"ReduceHashAggregate",id:"reducehashaggregate",level:2},{value:"MapSortAggregate",id:"mapsortaggregate",level:2},{value:"ReduceSortAggregate",id:"reducesortaggregate",level:2},{value:"ColocatedIntersect",id:"colocatedintersect",level:2},{value:"ColocatedMinus",id:"colocatedminus",level:2},{value:"MapIntersect",id:"mapintersect",level:2},{value:"ReduceIntersect",id:"reduceintersect",level:2},{value:"MapMinus",id:"mapminus",level:2},{value:"ReduceMinus",id:"reduceminus",level:2},{value:"UnionAll",id:"unionall",level:2},{value:"Exchange",id:"exchange",level:2},{value:"TrimExchange",id:"trimexchange",level:2},{value:"Filter",id:"filter",level:2},{value:"HashJoin",id:"hashjoin",level:2},{value:"MergeJoin",id:"mergejoin",level:2},{value:"NestedLoopJoin",id:"nestedloopjoin",level:2},{value:"CorrelatedNestedLoopJoin",id:"correlatednestedloopjoin",level:2},{value:"IndexScan",id:"indexscan",level:2},{value:"TableScan",id:"tablescan",level:2},{value:"KeyValueGet",id:"keyvalueget",level:2},{value:"KeyValueModify",id:"keyvaluemodify",level:2},{value:"Limit",id:"limit",level:2},{value:"Project",id:"project",level:2},{value:"Receiver",id:"receiver",level:2},{value:"Sender",id:"sender",level:2},{value:"SelectCount",id:"selectcount",level:2},{value:"Sort",id:"sort",level:2},{value:"SystemViewScan",id:"systemviewscan",level:2},{value:"TableFunctionScan",id:"tablefunctionscan",level:2},{value:"TableModify",id:"tablemodify",level:2},{value:"Values",id:"values",level:2}];function a(e){const n={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:["\n",(0,r.jsxs)(n.p,{children:["This section enumerates all operators for the ",(0,r.jsx)(n.code,{children:"EXPLAIN"})," statement with their semantic and supported attributes."]}),"\n",(0,r.jsx)(n.h2,{id:"colocatedhashaggregate",children:"ColocatedHashAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nColocated aggregate assumes that the data is already distributed according to grouping keys, therefore aggregation can be completed locally in a single pass.\nThe hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"colocatedsortaggregate",children:"ColocatedSortAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nColocated aggregate assumes that the data is already distributed according to grouping keys, therefore aggregation can be completed locally in a single pass.\nThe sort aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collation"}),": List of columns and expected order of sorting this operator is rely on."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"maphashaggregate",children:"MapHashAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nMap aggregate is a first phase of 2-phase aggregation.\nDuring first phase, data is pre-aggregated, and result is sent to the where REDUCE is executed.\nThe hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reducehashaggregate",children:"ReduceHashAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nReduce aggregate is a second phase of 2-phase aggregation.\nDuring second phase, all pre-aggregated data is merged together, and final result is returned.\nThe hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"mapsortaggregate",children:"MapSortAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nMap aggregate is a first phase of 2-phase aggregation.\nDuring first phase, data is pre-aggregated, and result is sent to the where REDUCE is executed.\nThe sort aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collation"}),": List of columns and expected order of sorting this operator is rely on."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reducesortaggregate",children:"ReduceSortAggregate"}),"\n",(0,r.jsxs)(n.p,{children:["The aggregate operation groups input data on one or more sets of grouping keys, calculating each aggregation function for each combination of grouping key.\nReduce aggregate is a second phase of 2-phase aggregation.\nDuring second phase, all pre-aggregated data is merged together, and final result is returned.\nThe sort aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion.\nThe output rows are composed as follows: first come columns participating in grouping keys in the order they enumerated in ",(0,r.jsx)(n.code,{children:"group"})," attribute, then come results of accumulators in the order they enumerated in ",(0,r.jsx)(n.code,{children:"aggregation"})," attribute."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"group"}),": Set of grouping columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"aggregation"}),": List of accumulators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collation"}),": List of columns and expected order of sorting this operator is rely on."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"groupSets"}),": List of group key definitions for advanced grouping, like CUBE or ROLLUP.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"colocatedintersect",children:"ColocatedIntersect"}),"\n",(0,r.jsxs)(n.p,{children:["Returns all records from the primary input that are present in every secondary input.\nIf ",(0,r.jsx)(n.code,{children:"all"})," is ",(0,r.jsx)(n.code,{children:"true"}),", then for each specific record returned, the output contains min(m, n1, n2, \u2026, n) copies.\nOtherwise duplicates are eliminated."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contains duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"colocatedminus",children:"ColocatedMinus"}),"\n",(0,r.jsxs)(n.p,{children:["Returns all records from the primary input excluding any matching records from secondary inputs.\nIf ",(0,r.jsx)(n.code,{children:"all"})," is ",(0,r.jsx)(n.code,{children:"true"}),", then for each specific record returned, the output contains max(0, m - sum(n1, n2, \u2026, n)) copies.\nOtherwise duplicates are eliminated."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contain duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"mapintersect",children:"MapIntersect"}),"\n",(0,r.jsx)(n.p,{children:"Returns all records from the primary input that are present in every secondary input.\nMap intersect is a first phase of 2-phase computation.\nDuring first phase, data is pre-aggregated, and result is sent to the where REDUCE is executed."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contain duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reduceintersect",children:"ReduceIntersect"}),"\n",(0,r.jsxs)(n.p,{children:["Returns all records from the primary input that are present in every secondary input.\nReduce intersect is a second phase of 2-phase computation.\nDuring second phase, all pre-aggregated data is merged together, and final result is returned.\nIf ",(0,r.jsx)(n.code,{children:"all"})," is ",(0,r.jsx)(n.code,{children:"true"}),", then for each specific record returned, the output contains min(m, n1, n2, \u2026, n) copies.\nOtherwise duplicates are eliminated."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contain duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"mapminus",children:"MapMinus"}),"\n",(0,r.jsx)(n.p,{children:"Returns all records from the primary input excluding any matching records from secondary inputs.\nMap minus is a first phase of 2-phase computation.\nDuring first phase, data is pre-aggregated, and result is sent to the where REDUCE is executed."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contain duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reduceminus",children:"ReduceMinus"}),"\n",(0,r.jsxs)(n.p,{children:["Returns all records from the primary input excluding any matching records from secondary inputs.\nReduce minus is a second phase of 2-phase computation.\nDuring second phase, all pre-aggregated data is merged together, and final result is returned.\nIf ",(0,r.jsx)(n.code,{children:"all"})," is ",(0,r.jsx)(n.code,{children:"true"}),", then for each specific record returned, the output contains max(0, m - sum(n1, n2, \u2026, n)) copies.\nOtherwise duplicates are eliminated."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"all"}),": If ",(0,r.jsx)(n.code,{children:"true"}),", then output may contain duplicates."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"unionall",children:"UnionAll"}),"\n",(0,r.jsx)(n.p,{children:"Concatenates results from multiple inputs without removing duplicates."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"exchange",children:"Exchange"}),"\n",(0,r.jsx)(n.p,{children:"Redistribute rows according to specified distribution."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"distribution"}),": A distribution strategy that describes how the rows are distributed across nodes.\nPossible values are:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"single"}),": a single copy of data is available at single node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"broadcast"}),": every participating node has the its own copy of all the data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"random"}),": single copy of data is partitioned and spread randomly across all participating nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"hash"}),": single copy of data is partitioned and spread across nodes based on system-defined hash function of specified columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": single copy of data is partitioned and spread across nodes with regard of distribution of specified table."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"identity"}),": data is distributed with regard to value of specified column."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"trimexchange",children:"TrimExchange"}),"\n",(0,r.jsx)(n.p,{children:"Filters rows according to specified distribution.\nThis operator accept input that is broadcasted, i.e. every participating node has the its own copy of all the data, and applies a predicate such that output rows satisfy specified distribution."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"distribution"}),": A distribution strategy that describes how the rows are distributed across nodes.\nPossible values are:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"random"}),": single copy of data is partitioned and spread randomly across all participating nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"hash"}),": single copy of data is partitioned and spread across nodes based on system-defined hash function of specified columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": single copy of data is partitioned and spread across nodes with regard of distribution of specified table."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"filter",children:"Filter"}),"\n",(0,r.jsx)(n.p,{children:"Filters rows according to specified predicate conditions."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Filtering condition."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hashjoin",children:"HashJoin"}),"\n",(0,r.jsx)(n.p,{children:"The join operation will combine two separate inputs into a single output, based on a join expression.\nThe hash join operator will build a hash table out of right input based on a set of join keys.\nIt will then probe that hash table for the left input, finding matches."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),': A boolean condition that describes whether each row from the left set "match" the row from the right set.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of the join (like INNER, LEFT, SEMI, etc)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"mergejoin",children:"MergeJoin"}),"\n",(0,r.jsx)(n.p,{children:"The join operation will combine two separate inputs into a single output, based on a join expression.\nThe merge join does a join by taking advantage of two sets that are sorted on the join keys.\nThis allows the join operation to be done in a streaming fashion."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),': A boolean condition that describes whether each row from the left set "match" the row from the right set.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of the join (like INNER, LEFT, SEMI, etc)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"nestedloopjoin",children:"NestedLoopJoin"}),"\n",(0,r.jsx)(n.p,{children:"The join operation will combine two separate inputs into a single output, based on a join expression.\nThe nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),': A boolean condition that describes whether each row from the left set "match" the row from the right set.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of the join (like INNER, LEFT, SEMI, etc)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"correlatednestedloopjoin",children:"CorrelatedNestedLoopJoin"}),"\n",(0,r.jsx)(n.p,{children:"The join operation will combine two separate inputs into a single output, based on a join expression.\nThe correlated nested loop join operator does a join by setting correlated variables to a context based on a row from left input, and reevaluating the right input with updated context."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"correlates"}),": Set of correlated variables which are set by current relational operator."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),': A boolean condition that describes whether each row from the left set "match" the row from the right set.']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of the join (like INNER, LEFT, SEMI, etc)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"indexscan",children:"IndexScan"}),"\n",(0,r.jsxs)(n.p,{children:["Scans rows using a specified index.\nA ",(0,r.jsx)(n.code,{children:"searchBounds"})," is used to specify boundaries of index scan or look up.\nHence, if it is not specified, all rows will be read.\nA ",(0,r.jsx)(n.code,{children:"predicate"})," is applied before ",(0,r.jsx)(n.code,{children:"projection"}),".\nIf ",(0,r.jsx)(n.code,{children:"projection"})," is not specified, then ",(0,r.jsx)(n.code,{children:"fieldNames"})," enumerates columns returned from table."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"searchBounds"}),": List of bounds representing boundaries of the range scan or point look up Optional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Filtering condition.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tablescan",children:"TableScan"}),"\n",(0,r.jsxs)(n.p,{children:["Scans all rows from a table.\nA ",(0,r.jsx)(n.code,{children:"predicate"})," is applied before ",(0,r.jsx)(n.code,{children:"projection"}),".\nIf ",(0,r.jsx)(n.code,{children:"projection"})," is not specified, then ",(0,r.jsx)(n.code,{children:"fieldNames"})," enumerates columns returned from table."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Filtering condition.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"keyvalueget",children:"KeyValueGet"}),"\n",(0,r.jsx)(n.p,{children:"Optimized operator which leverages Key-Value API in get-by-key queries."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"key"}),": Key expression to do look up."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Filtering condition.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"keyvaluemodify",children:"KeyValueModify"}),"\n",(0,r.jsx)(n.p,{children:"Optimized operator which leverages Key-Value API in DML queries."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of data modification operation (e.g., INSERT, UPDATE, DELETE)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sourceExpression"}),": Source expressions used for row computations for INSERT operation.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"key"}),": Source expressions used for row computations for DELETE operation.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"limit",children:"Limit"}),"\n",(0,r.jsx)(n.p,{children:"Limits the number of returned rows, with optional offset."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fetch"}),": Maximum number of rows to return.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"offset"}),": Number of rows to skip.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"project",children:"Project"}),"\n",(0,r.jsx)(n.p,{children:"Projects specified expressions or columns from the input."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"receiver",children:"Receiver"}),"\n",(0,r.jsxs)(n.p,{children:["Receives data sent by a ",(0,r.jsx)(n.code,{children:"Sender"})," during distributed query execution."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sourceFragmentId"}),": An identifier of source fragment, indicating the origin of a data flow edge between fragments."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sender",children:"Sender"}),"\n",(0,r.jsxs)(n.p,{children:["Sends data to a ",(0,r.jsx)(n.code,{children:"Receiver"})," during distributed query execution."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"targetFragmentId"}),": An identifier of target fragment, indicating the origin of a data flow edge between fragments."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"distribution"}),": A distribution strategy that describes how the rows are distributed across nodes.\nPossible values are:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"single"}),": a single copy of data is available at single node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"broadcast"}),": every participating node has the its own copy of all the data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"random"}),": single copy of data is partitioned and spread randomly across all participating nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"hash"}),": single copy of data is partitioned and spread across nodes based on system-defined hash function of specified columns."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": single copy of data is partitioned and spread across nodes with regard of distribution of specified table."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"identity"}),": data is distributed with regard to value of specified column."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"selectcount",children:"SelectCount"}),"\n",(0,r.jsxs)(n.p,{children:["Optimized operator for various non-transactional ",(0,r.jsx)(n.code,{children:"SELECT COUNT(*)"})," variations of queries."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sort",children:"Sort"}),"\n",(0,r.jsxs)(n.p,{children:["Sorts rows based on specified collation.\nIf ",(0,r.jsx)(n.code,{children:"fetch"})," attribute is provided, then ",(0,r.jsx)(n.code,{children:"Sort"})," node implements Top-N semantic, implying that only ",(0,r.jsx)(n.code,{children:"fetch"})," + ",(0,r.jsx)(n.code,{children:"offset"})," rows will be stored in memory during sorting phase."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collation"}),": List of one or more fields to sort by."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fetch"}),": Maximum number of rows to return.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"offset"}),": Number of rows to skip.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"systemviewscan",children:"SystemViewScan"}),"\n",(0,r.jsxs)(n.p,{children:["Scans all rows from a system view.\nA ",(0,r.jsx)(n.code,{children:"predicate"})," is applied before ",(0,r.jsx)(n.code,{children:"projection"}),".\nIf ",(0,r.jsx)(n.code,{children:"projection"})," is not specified, then ",(0,r.jsx)(n.code,{children:"fieldNames"})," enumerates columns returned from system view."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": System view being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Filtering condition.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"projection"}),": List of expressions to evaluate.\nOptional."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tablefunctionscan",children:"TableFunctionScan"}),"\n",(0,r.jsx)(n.p,{children:"Scans over a function producing result set."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"invocation"}),": Name of the function producing source result set."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tablemodify",children:"TableModify"}),"\n",(0,r.jsx)(n.p,{children:"Applies DML operations on a table (INSERT, UPDATE, DELETE)."}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"table"}),": Table being accessed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"type"}),": Type of data modification operation (e.g., INSERT, UPDATE, DELETE)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"values",children:"Values"}),"\n",(0,r.jsxs)(n.p,{children:["Produces literal in-memory rows as input (e.g., ",(0,r.jsx)(n.code,{children:"VALUES (1), (2)"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tuples"}),": List of literal tuples to return."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of output rows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": List of names of columns in produced rows.\nOptional."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>d});var s=i(96540);const r={},o=s.createContext(r);function t(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);