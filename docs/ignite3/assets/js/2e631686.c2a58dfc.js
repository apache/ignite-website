"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4766],{11470:(e,r,t)=>{t.d(r,{A:()=>j});var a=t(96540),n=t(34164),s=t(17559),i=t(23104),l=t(56347),o=t(205),c=t(57485),u=t(31682),d=t(70679);function m(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:r,children:t}=e;return(0,a.useMemo)(()=>{const e=r??function(e){return m(e).map(({props:{value:e,label:r,attributes:t,default:a}})=>({value:e,label:r,attributes:t,default:a}))}(t);return function(e){const r=(0,u.XI)(e,(e,r)=>e.value===r.value);if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[r,t])}function h({value:e,tabValues:r}){return r.some(r=>r.value===e)}function g({queryString:e=!1,groupId:r}){const t=(0,l.W6)(),n=function({queryString:e=!1,groupId:r}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:e,groupId:r});return[(0,c.aZ)(n),(0,a.useCallback)(e=>{if(!n)return;const r=new URLSearchParams(t.location.search);r.set(n,e),t.replace({...t.location,search:r.toString()})},[n,t])]}function b(e){const{defaultValue:r,queryString:t=!1,groupId:n}=e,s=p(e),[i,l]=(0,a.useState)(()=>function({defaultValue:e,tabValues:r}){if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${r.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=r.find(e=>e.default)??r[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:r,tabValues:s})),[c,u]=g({queryString:t,groupId:n}),[m,b]=function({groupId:e}){const r=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,n]=(0,d.Dv)(r);return[t,(0,a.useCallback)(e=>{r&&n.set(e)},[r,n])]}({groupId:n}),v=(()=>{const e=c??m;return h({value:e,tabValues:s})?e:null})();(0,o.A)(()=>{v&&l(v)},[v]);return{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),b(e)},[u,b,s]),tabValues:s}}var v=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(74848);function T({className:e,block:r,selectedValue:t,selectValue:a,tabValues:s}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,i.a_)(),c=e=>{const r=e.currentTarget,n=l.indexOf(r),i=s[n].value;i!==t&&(o(r),a(i))},u=e=>{let r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;r=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;r=l[t]??l[l.length-1];break}}r?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":r},e),children:s.map(({value:e,label:r,attributes:a})=>(0,y.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:u,onClick:c,...a,className:(0,n.A)("tabs__item",x.tabItem,a?.className,{"tabs__item--active":t===e}),children:r??e},e))})}function I({lazy:e,children:r,selectedValue:t}){const s=(Array.isArray(r)?r:[r]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,n.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:s.map((e,r)=>(0,a.cloneElement)(e,{key:r,hidden:e.props.value!==t}))})}function f(e){const r=b(e);return(0,y.jsxs)("div",{className:(0,n.A)(s.G.tabs.container,"tabs-container",x.tabList),children:[(0,y.jsx)(T,{...r,...e}),(0,y.jsx)(I,{...r,...e})]})}function j(e){const r=(0,v.A)();return(0,y.jsx)(f,{...e,children:m(e.children)},String(r))}},19365:(e,r,t)=>{t.d(r,{A:()=>i});t(96540);var a=t(34164);const n={tabItem:"tabItem_Ymn6"};var s=t(74848);function i({children:e,hidden:r,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(n.tabItem,t),hidden:r,children:e})}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>l});var a=t(96540);const n={},s=a.createContext(n);function i(e){const r=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(s.Provider,{value:r},e.children)}},59464:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"developers-guide/data-streamer","title":"Streaming Data","description":"{/*","source":"@site/versioned_docs/version-3.0.0/developers-guide/data-streamer.md","sourceDirName":"developers-guide","slug":"/developers-guide/data-streamer","permalink":"/docs/ignite3/3.0.0/developers-guide/data-streamer","draft":false,"unlisted":false,"tags":[],"version":"3.0.0","frontMatter":{"title":"Streaming Data","sidebar_label":"Streaming Data"},"sidebar":"tutorialSidebar","previous":{"title":"Performing Transactions","permalink":"/docs/ignite3/3.0.0/developers-guide/transactions"},"next":{"title":"Code Deployment","permalink":"/docs/ignite3/3.0.0/developers-guide/code-deployment/"}}');var n=t(74848),s=t(28453),i=t(11470),l=t(19365);const o={title:"Streaming Data",sidebar_label:"Streaming Data"},c=void 0,u={},d=[{value:"Using Data Streamer API",id:"using-data-streamer-api",level:2},{value:"Configuring Data Streamer",id:"configuring-data-streamer",level:3},{value:"Streaming Data",id:"streaming-data",level:3},{value:"Streaming with Receiver",id:"streaming-with-receiver",level:3},{value:"Examples",id:"examples",level:3},{value:"Updating Multiple Tables",id:"updating-multiple-tables",level:4},{value:"Distributed Computations",id:"distributed-computations",level:4},{value:"Custom Marshallers in .NET",id:"custom-marshallers-in-net",level:4},{value:"Tracking Failed Entries",id:"tracking-failed-entries",level:2},{value:"Tuning Memory Usage",id:"tuning-memory-usage",level:3}];function m(e){const r={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:["\n","\n",(0,n.jsx)(r.p,{children:"Data streaming provides a fast, efficient method for loading, organizing, and distributing large volumes of data across your cluster.\r\nData streamer accepts a stream of data and distributes data entries across the cluster, where the processing takes place. Data streaming is available in all table views."}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.img,{alt:"Data streaming diagram",src:t(73381).A+"",width:"1278",height:"673"})}),"\n",(0,n.jsx)(r.p,{children:"Data streaming provides at-least-once delivery guarantee."}),"\n",(0,n.jsx)(r.h2,{id:"using-data-streamer-api",children:"Using Data Streamer API"}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.a,{href:"https://ignite.apache.org/releases/3.0.0/javadoc/org/apache/ignite/table/DataStreamerTarget.html",children:"Data Streamer API"})," lets you load large amounts of data into your cluster quickly and reliably using a publisher\u2013subscriber model, where you create a publisher that streams your data entries to a table view, and the system distributes these entries across the cluster. You can configure how the data is processed via a ",(0,n.jsx)(r.code,{children:"DataStreamerOptions"})," object that allows to set batch sizes, auto-flush intervals, retry limits."]}),"\n",(0,n.jsx)(r.h3,{id:"configuring-data-streamer",children:"Configuring Data Streamer"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"DataStreamerOptions"})," lets you fine-tune how data is streamed into your cluster by setting parameters for batching, retries, parallelism, and auto-flush timing:"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:"DataStreamerOptions options = DataStreamerOptions.builder()\r\n.pageSize(1000)\r\n.perPartitionParallelOperations(1)\r\n.autoFlushInterval(1000)\r\n.retryLimit(16)\r\n.build();\n"})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:"var options = new DataStreamerOptions\r\n{\r\n    PageSize = 1000,\r\n    RetryLimit = 8,\r\n    AutoFlushInterval = TimeSpan.FromSeconds(3)\r\n};\n"})})})]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"pageSize"}),": Specifies the number of entries to process in each page or chunk of data."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"perPartitionParallelOperations"}),": Determines the number of parallel operations allowed on each partition."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"autoFlushInterval"}),": Defines the time interval (in milliseconds) after which the system automatically flushes any incomplete buffers."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"retryLimit"}),": Specifies the maximum number of retry attempts for a failed data submission before giving up."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"streaming-data",children:"Streaming Data"}),"\n",(0,n.jsxs)(r.p,{children:["Before data is streamed to the cluster, each entry must be wrapped in an instance of the ",(0,n.jsx)(r.code,{children:"DataStreamerItem<T>"})," class. This wrapper allows you to perform ",(0,n.jsx)(r.code,{children:"PUT"})," and ",(0,n.jsx)(r.code,{children:"REMOVE"})," operations with data:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Use ",(0,n.jsx)(r.code,{children:"DataStreamerItem.of(entry)"})," to insert new entries into the table."]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["\n",(0,n.jsxs)(r.p,{children:["Use ",(0,n.jsx)(r.code,{children:"DataStreamerItem.removed(entry)"})," to delete existing ones."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Wrapped data then can be passed to a publisher and streamed to the table."}),"\n",(0,n.jsxs)(r.p,{children:["The example below demonstrates how to use ",(0,n.jsx)(r.a,{href:"/docs/ignite3/3.0.0/developers-guide/table-api#record-view",children:(0,n.jsx)(r.code,{children:"RecordView"})}),", create a publisher, configure the data streamer, insert account records into the existing ",(0,n.jsx)(r.code,{children:"accounts"})," table and then delete them:"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'public class RecordViewPojoDataStreamerExample {\r\n    private static final int ACCOUNTS_COUNT = 1000;\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        /**\r\n         * Assuming the \'accounts\' table already exists.\r\n         */\r\n        try (IgniteClient client = IgniteClient.builder()\r\n                .addresses("127.0.0.1:10800")\r\n                .build()) {\r\n            RecordView<Account> view = client.tables().table("accounts").recordView(Account.class);\r\n\r\n            streamAccountDataPut(view);\r\n            streamAccountDataRemove(view);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Streaming data using DataStreamerOperationType#PUT operation type.\r\n     */\r\n    private static void streamAccountDataPut(RecordView<Account> view) {\r\n        DataStreamerOptions options = DataStreamerOptions.builder()\r\n                .pageSize(1000)\r\n                .perPartitionParallelOperations(1)\r\n                .autoFlushInterval(1000)\r\n                .retryLimit(16)\r\n                .build();\r\n\r\n        CompletableFuture<Void> streamerFut;\r\n        try (var publisher = new SubmissionPublisher<DataStreamerItem<Account>>()) {\r\n            streamerFut = view.streamData(publisher, options);\r\n            ThreadLocalRandom rnd = ThreadLocalRandom.current();\r\n            for (int i = 0; i < ACCOUNTS_COUNT; i++) {\r\n                Account entry = new Account(i, "name" + i, rnd.nextLong(100_000), rnd.nextBoolean());\r\n                publisher.submit(DataStreamerItem.of(entry));\r\n            }\r\n        }\r\n        streamerFut.join();\r\n    }\r\n\r\n    /**\r\n     * Streaming data using DataStreamerOperationType#REMOVE operation type\r\n     */\r\n    private static void streamAccountDataRemove(RecordView<Account> view) {\r\n        DataStreamerOptions options = DataStreamerOptions.builder()\r\n                .pageSize(1000)\r\n                .perPartitionParallelOperations(1)\r\n                .autoFlushInterval(1000)\r\n                .retryLimit(16)\r\n                .build();\r\n\r\n        CompletableFuture<Void> streamerFut;\r\n        try (var publisher = new SubmissionPublisher<DataStreamerItem<Account>>()) {\r\n            streamerFut = view.streamData(publisher, options);\r\n            for (int i = 0; i < ACCOUNTS_COUNT; i++) {\r\n                Account entry = new Account(i);\r\n                publisher.submit(DataStreamerItem.removed(entry));\r\n            }\r\n        }\r\n        streamerFut.join();\r\n    }\r\n}\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'using Apache.Ignite;\r\nusing Apache.Ignite.Table;\r\n\r\nusing var client = await IgniteClient.StartAsync(new("localhost"));\r\nITable? table = await client.Tables.GetTableAsync("accounts");\r\nIRecordView<Account> view = table!.GetRecordView<Account>();\r\n\r\nvar options = new DataStreamerOptions\r\n{\r\n    PageSize = 10_000,\r\n    AutoFlushInterval = TimeSpan.FromSeconds(1),\r\n    RetryLimit = 32\r\n};\r\n\r\nawait view.StreamDataAsync(GetAccountsToAdd(5_000), options);\r\nawait view.StreamDataAsync(GetAccountsToRemove(1_000), options);\r\n\r\nasync IAsyncEnumerable<DataStreamerItem<Account>> GetAccountsToAdd(int count)\r\n{\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        yield return DataStreamerItem.Create(\r\n            new Account(i, $"Account {i}"));\r\n    }\r\n}\r\n\r\nasync IAsyncEnumerable<DataStreamerItem<Account>> GetAccountsToRemove(int count)\r\n{\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        yield return DataStreamerItem.Create(\r\n            new Account(i, string.Empty), DataStreamerOperationType.Remove);\r\n    }\r\n}\r\n\r\npublic record Account(int Id, string Name);\n'})})})]}),"\n",(0,n.jsx)(r.h3,{id:"streaming-with-receiver",children:"Streaming with Receiver"}),"\n",(0,n.jsx)(r.p,{children:"The Apache Ignite 3 streaming API supports advanced streaming scenarios by allowing you to create a custom receiver that defines server-side processing logic. Use a receiver when you need to process or transform data on the server, update multiple tables from a single data stream, or work with incoming data that does not match a table schema."}),"\n",(0,n.jsxs)(r.p,{children:["With a receiver, you can stream data in any format, as it is schema-agnostic.\r\nThe receiver also has access to the full Ignite 3 API through the ",(0,n.jsx)(r.a,{href:"https://ignite.apache.org/releases/3.0.0/javadoc/org/apache/ignite/table/DataStreamerReceiverContext.html",children:(0,n.jsx)(r.code,{children:"DataStreamerReceiverContext"})}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["The data streamer controls data flow by requesting items only when partition buffers have space. ",(0,n.jsx)(r.code,{children:"DataStreamerOptions.perPartitionParallelOperations"})," controls how many buffers can be allocated per partition. When buffers are full, the streamer stops requesting more data until some items are processed.\r\nAdditionally, if a ",(0,n.jsx)(r.code,{children:"resultSubscriber"})," is specified, it also applies backpressure on the streamer. If the subscriber is slow at consuming results, the streamer reduces its request rate from the publisher accordingly."]}),"\n",(0,n.jsxs)(r.p,{children:["To use a receiver, you need to implement the ",(0,n.jsx)(r.a,{href:"https://ignite.apache.org/releases/3.0.0/javadoc/org/apache/ignite/table/DataStreamerReceiver.html",children:(0,n.jsx)(r.code,{children:"DataStreamerReceiver"})})," interface. The receiver's ",(0,n.jsx)(r.code,{children:"receive"})," method processes each batch of items streamed to the server, so you can apply custom logic and return results for each item as needed:"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:"@Nullable CompletableFuture<List<R>> receive(\r\nList<T> page,\r\nDataStreamerReceiverContext ctx,\r\n@Nullable A arg);\r\n\n"})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:"ValueTask<IList<TResult>?> ReceiveAsync(\r\nIList<TItem> page,\r\nTArg arg,\r\nIDataStreamerReceiverContext context,\r\nCancellationToken cancellationToken);\n"})})})]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"page"}),": The current batch of data items to process."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"ctx"}),": The receiver context, which lets you interact with Ignite 3 API."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"arg"}),": An optional argument that can be used to pass custom parameters to your receiver logic."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(r.h4,{id:"updating-multiple-tables",children:"Updating Multiple Tables"}),"\n",(0,n.jsx)(r.p,{children:"The following example demonstrates how to implement a receiver that processes data containing customer and address information, and updates two separate tables on the server:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["First, create the custom receiver that will extract data from the provided source and write it into two separate tables: ",(0,n.jsx)(r.code,{children:"customers"})," and ",(0,n.jsx)(r.code,{children:"addresses"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'private static class TwoTableReceiver implements DataStreamerReceiver<Tuple, Void, Void> {\r\n@Override\r\npublic @Nullable CompletableFuture<List<Void>> receive(List<Tuple> page, DataStreamerReceiverContext ctx, @Nullable Void arg) {\r\n// List<Tuple> is the source data. Those tuples do not conform to any table and can have arbitrary data.\r\n\r\n            RecordView<Tuple> customersTable = ctx.ignite().tables().table("customers").recordView();\r\n            RecordView<Tuple> addressesTable = ctx.ignite().tables().table("addresses").recordView();\r\n\r\n            for (Tuple sourceItem : page) {\r\n                // For each source item, receiver extracts customer and address data and upserts it into respective tables.\r\n                Tuple customer = Tuple.create()\r\n                        .set("id", sourceItem.intValue("customerId"))\r\n                        .set("name", sourceItem.stringValue("customerName"))\r\n                        .set("addressId", sourceItem.intValue("addressId"));\r\n\r\n                Tuple address = Tuple.create()\r\n                        .set("id", sourceItem.intValue("addressId"))\r\n                        .set("street", sourceItem.stringValue("street"))\r\n                        .set("city", sourceItem.stringValue("city"));\r\n\r\n                customersTable.upsert(null, customer);\r\n                addressesTable.upsert(null, address);\r\n            }\r\n\r\n            return null;\r\n        }\r\n    }\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'class TwoTableReceiver : IDataStreamerReceiver<IIgniteTuple, object?, object>\r\n{\r\n    public async ValueTask<IList<object>?> ReceiveAsync(\r\n        IList<IIgniteTuple> page,\r\n        object? arg,\r\n        IDataStreamerReceiverContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        IRecordView<IIgniteTuple> customerTable = (await context.Ignite.Tables.GetTableAsync("customers"))!.RecordBinaryView;\r\n        IRecordView<IIgniteTuple> addressesTable = (await context.Ignite.Tables.GetTableAsync("addresses"))!.RecordBinaryView;\r\n\r\n        foreach (IIgniteTuple sourceItem in page)\r\n        {\r\n            // For each source item, the receiver extracts customer and address data and upserts it into respective tables.\r\n            var customer = new IgniteTuple\r\n            {\r\n                ["id"] = sourceItem["customerId"],\r\n                ["name"] = sourceItem["customerName"],\r\n                ["addressId"] = sourceItem["addressId"]\r\n            };\r\n\r\n            var address = new IgniteTuple\r\n            {\r\n                ["id"] = sourceItem["addressId"],\r\n                ["street"] = sourceItem["street"],\r\n                ["city"] = sourceItem["city"],\r\n            };\r\n\r\n            await customerTable.UpsertAsync(null, customer);\r\n            await addressesTable.UpsertAsync(null, address);\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\n'})})})]}),"\n",(0,n.jsxs)(r.ol,{start:"2",children:["\n",(0,n.jsxs)(r.li,{children:["Create a descriptor that refers to your receiver implementation. This descriptor will be passed later to a ",(0,n.jsx)(r.code,{children:"SubmissionPublisher"})," when streaming data."]}),"\n"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:"DataStreamerReceiverDescriptor<Tuple, Void, Void> desc = DataStreamerReceiverDescriptor\r\n.builder(TwoTableReceiver.class)\r\n.build();\n"})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:"ReceiverDescriptor<IIgniteTuple, object?, object> desc = ReceiverDescriptor.Of(new TwoTableReceiver());\n"})})})]}),"\n",(0,n.jsxs)(r.ol,{start:"3",children:["\n",(0,n.jsxs)(r.li,{children:["Next, obtain the target table to partition the data for streaming. In this example we partition by ",(0,n.jsx)(r.code,{children:"customerId"})," to ensure the receiver is colocated with the customer data, enabling local upserts. Then define how to extract keys and payloads from the source, and stream the data using a ",(0,n.jsx)(r.code,{children:"SubmissionPublisher"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'// Example source data\r\nList<Tuple> sourceData = IntStream.range(1, 10)\r\n.mapToObj(i -> Tuple.create()\r\n.set("customerId", i)\r\n.set("customerName", "Customer " + i)\r\n.set("addressId", i)\r\n.set("street", "Street " + i)\r\n.set("city", "City " + i))\r\n.collect(Collectors.toList());\r\n\r\nCompletableFuture<Void> streamerFut;\r\n\r\nRecordView<Tuple> customersTable = client.tables().table("customers").recordView();\r\n\r\n// Extract the target table key from each source item; since the source has "customerId" but the target table uses "id", the function maps customerId to id accordingly.\r\nFunction<Tuple, Tuple> keyFunc = sourceItem -> Tuple.create().set("id", sourceItem.intValue("customerId"));\r\n\r\n// Extract the data payload sent to the receiver. In this case, we use the entire source item as the payload.\r\nFunction<Tuple, Tuple> payloadFunc = Function.identity();\r\n\r\n// Stream data using a publisher.\r\ntry (var publisher = new SubmissionPublisher<Tuple>()) {\r\n    streamerFut = customersTable.streamData(\r\n            publisher,\r\n            desc,\r\n            keyFunc,\r\n            payloadFunc,\r\n            null, // Optional receiver arguments\r\n            null, // Result subscriber\r\n            null // Options\r\n    );\r\n\r\n    for (Tuple item : sourceData) {\r\n        publisher.submit(item);\r\n    }\r\n}\r\n\r\nstreamerFut.join();\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'IAsyncEnumerable<IIgniteTuple> sourceData = GetSourceData();\r\n\r\nIRecordView<IIgniteTuple> customersTable = (await client.Tables.GetTableAsync("customers"))!.RecordBinaryView;\r\n\r\nIAsyncEnumerable<object> streamerResults = customersTable.StreamDataAsync(\r\nsourceData,\r\ndesc,\r\nx => new IgniteTuple { ["id"] = x["customerId"] },\r\nx => x,\r\nnull,\r\nDataStreamerOptions.Default,\r\nCancellationToken.None);\r\n\r\nawait foreach (object result in streamerResults)\r\n{\r\n// ...\r\n}\r\n\r\nstatic async IAsyncEnumerable<IIgniteTuple> GetSourceData()\r\n{\r\nawait Task.Yield(); // Simulate async enumeration.\r\n\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        yield return new IgniteTuple\r\n        {\r\n            ["customerId"] = i,\r\n            ["customerName"] = $"Customer {i}",\r\n            ["addressId"] = i,\r\n            ["street"] = $"Street {i}",\r\n            ["city"] = $"City {i}"\r\n        };\r\n    }\r\n}\n'})})})]}),"\n",(0,n.jsx)(r.h4,{id:"distributed-computations",children:"Distributed Computations"}),"\n",(0,n.jsxs)(r.p,{children:["You can also use a streamer with a receiver to perform distributed computations, such as per-item calculations and ",(0,n.jsx)(r.a,{href:"/docs/ignite3/3.0.0/developers-guide/compute/#mapreduce-tasks",children:"map-reduce"})," tasks on the returned results."]}),"\n",(0,n.jsx)(r.p,{children:"This example demonstrates a simulated fraud detection process, which typically involves intensive processing of each transaction using ML models."}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"First, create a custom receiver that will handle fraud detection computations on the results:"}),"\n"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'private static class FraudDetectorReceiver implements DataStreamerReceiver<Tuple, Void, Tuple> {\r\n@Override\r\npublic @Nullable CompletableFuture<List<Tuple>> receive(List<Tuple> page, DataStreamerReceiverContext ctx, @Nullable Void arg) {\r\nList<Tuple> results = new ArrayList<>(page.size());\r\n\r\n            for (Tuple tx : page) {\r\n                results.add(detectFraud(tx));\r\n            }\r\n\r\n            return CompletableFuture.completedFuture(results);\r\n        }\r\n\r\n        private static Tuple detectFraud(Tuple txInfo) {\r\n            // Simulate fraud detection processing.\r\n            double fraudRisk = Math.random();\r\n\r\n            // Add result to the tuple and return.\r\n            return txInfo.set("fraudRisk", fraudRisk);\r\n        }\r\n    }\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'class FraudDetectorReceiver : IDataStreamerReceiver<IIgniteTuple, object?, IIgniteTuple>\r\n{\r\n    public async ValueTask<IList<IIgniteTuple>?> ReceiveAsync(\r\n        IList<IIgniteTuple> page,\r\n        object? arg,\r\n        IDataStreamerReceiverContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var result = new List<IIgniteTuple>(page.Count);\r\n\r\n        foreach (var tx in page)\r\n        {\r\n            IIgniteTuple resTuple = await DetectFraud(tx);\r\n            result.Add(resTuple);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private static async Task<IIgniteTuple> DetectFraud(IIgniteTuple transaction)\r\n    {\r\n        // Simulate fraud detection logic - add a random risk score to the tuple.\r\n        await Task.Delay(10);\r\n        transaction["fraudRisk"] = Random.Shared.NextDouble();\r\n        return transaction;\r\n    }\r\n}\n'})})})]}),"\n",(0,n.jsxs)(r.ol,{start:"2",children:["\n",(0,n.jsxs)(r.li,{children:["Next, stream a list of sample transactions across the cluster using a dummy table that partitions data by transaction ID and ",(0,n.jsx)(r.code,{children:"FraudDetectorReceiver"})," for fraud detection. Subscribe to the results to log each processed transaction, handle errors, and confirm when streaming completes:"]}),"\n"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'public void runReceiverStreamProcessing() {\r\n\r\n    // Source data is a list of financial transactions.\r\n    // We distribute this processing across the cluster, then gather and return results.\r\n    List<Tuple> sourceData = IntStream.range(1, 10)\r\n                        .mapToObj(i -> Tuple.create()\r\n                        .set("txId", i)\r\n                        .set("txData", "{some-json-data}"))\r\n                        .collect(Collectors.toList());\r\n\r\n        DataStreamerReceiverDescriptor<Tuple, Void, Tuple> desc = DataStreamerReceiverDescriptor\r\n                .builder(FraudDetectorReceiver.class)\r\n                .build();\r\n\r\n        CompletableFuture<Void> streamerFut;\r\n\r\n        // Streaming requires a target table to partition data.\r\n        // Use a dummy table for this scenario, because we are not going to store any data.\r\n        TableDefinition txDummyTableDef = TableDefinition.builder("tx_dummy")\r\n                .columns(column("id", ColumnType.INTEGER))\r\n                .primaryKey("id")\r\n                .build();\r\n\r\n        Table dummyTable = client.catalog().createTable(txDummyTableDef);\r\n\r\n        // Source data has "txId" field, but target dummy table has "id" column, so keyFunc maps "txId" to "id".\r\n        Function<Tuple, Tuple> keyFunc = sourceItem -> Tuple.create().set("id", sourceItem.value("txId"));\r\n\r\n        // Payload function is used to extract the payload (data that goes to the receiver) from the source item.\r\n        // In our case, we want to use the whole source item as the payload.\r\n        Function<Tuple, Tuple> payloadFunc = Function.identity();\r\n\r\n        Flow.Subscriber<Tuple> resultSubscriber = new Flow.Subscriber<>() {\r\n            @Override\r\n            public void onSubscribe(Flow.Subscription subscription) {\r\n                subscription.request(Long.MAX_VALUE);\r\n            }\r\n\r\n            @Override\r\n            public void onNext(Tuple item) {\r\n                System.out.println("Transaction processed: " + item);\r\n            }\r\n\r\n            @Override\r\n            public void onError(Throwable throwable) {\r\n                System.err.println("Error during streaming: " + throwable.getMessage());\r\n            }\r\n\r\n            @Override\r\n            public void onComplete() {\r\n                System.out.println("Streaming completed.");\r\n            }\r\n        };\r\n\r\n        try (var publisher = new SubmissionPublisher<Tuple>()) {\r\n            streamerFut = dummyTable.recordView().streamData(\r\n                    publisher,\r\n                    desc,\r\n                    keyFunc,\r\n                    payloadFunc,\r\n                    null, // Arg\r\n                    resultSubscriber,\r\n                    null // Options\r\n            );\r\n\r\n            for (Tuple item : sourceData) {\r\n                publisher.submit(item);\r\n            }\r\n        }\r\n\r\n        streamerFut.join();\r\n    }\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'// Source data is a list of financial transactions.\r\n// We want to distribute this processing across the cluster, then gather and return results\r\nIAsyncEnumerable<IIgniteTuple> data = GetSourceData();\r\n\r\nReceiverDescriptor<IIgniteTuple, object?, IIgniteTuple> fraudDetectorReceiverDesc = ReceiverDescriptor.Of(new FraudDetectorReceiver());\r\n\r\n// Streaming requires a target table to partition data.\r\n// Use a dummy table for this scenario, because we are not going to store any data.\r\nawait client.Sql.ExecuteScriptAsync("CREATE TABLE IF NOT EXISTS TX_DUMMY (ID LONG)");\r\n\r\nITable dummyTable = await client.Tables.GetTableAsync("TX_DUMMY");\r\n\r\n// Source data has "txId" field, but target dummy table has "id" column, so keyFunc maps "txId" to "id".\r\nFunc<IIgniteTuple, IIgniteTuple> keyFunc = tuple => new IgniteTuple { ["id"] = tuple["txId"] };\r\n\r\n// Payload function is used to extract the payload (data that goes to the receiver) from the source item.\r\n// In our case, we want to use the whole source item as the payload.\r\nFunc<IIgniteTuple, IIgniteTuple> payloadFunc = tuple => tuple;\r\n\r\nIAsyncEnumerable<IIgniteTuple> results = dummyTable.RecordBinaryView.StreamDataAsync(\r\ndata,\r\nfraudDetectorReceiverDesc,\r\nkeyFunc,\r\npayloadFunc,\r\nreceiverArg: null);\r\n\r\nawait foreach (IIgniteTuple processedTx in results)\r\n{\r\nConsole.WriteLine("Transaction processed: " + processedTx);\r\n}\r\n\r\nasync IAsyncEnumerable<IIgniteTuple> GetSourceData()\r\n{\r\nawait Task.Yield(); // Simulate async data source.\r\n\r\n    for (int i = 0; i < 1000; i++)\r\n    {\r\n        yield return new IgniteTuple\r\n        {\r\n            ["txId"] = i,\r\n            ["txData"] = "{some-json-data}"\r\n        };\r\n    }\r\n}\n'})})})]}),"\n",(0,n.jsx)(r.h4,{id:"custom-marshallers-in-net",children:"Custom Marshallers in .NET"}),"\n",(0,n.jsxs)(r.p,{children:["In .NET, you can define custom marshallers by implementing the ",(0,n.jsx)(r.a,{href:"https://ignite.apache.org/releases/3.0.0/dotnetdoc/api/Apache.Ignite.Marshalling.IMarshaller-1.html",children:(0,n.jsx)(r.code,{children:"IMarshaller"})})," interface."]}),"\n",(0,n.jsxs)(r.p,{children:["For example, the code below demonstrates how to use ",(0,n.jsx)(r.code,{children:"JsonMarshaller"})," to serialize data, arguments, and results."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'ITable? table = await client.Tables.GetTableAsync("my-table");\r\n\r\nReceiverDescriptor<MyData, MyArg, MyResult> receiverDesc = ReceiverDescriptor.Of(new MyReceiver());\r\n\r\nIAsyncEnumerable<MyData> data = Enumerable\r\n    .Range(1, 100)\r\n    .Select(x => new MyData(x, $"Name {x}"))\r\n    .ToAsyncEnumerable();\r\n\r\nIAsyncEnumerable<MyResult> results = table!.RecordBinaryView.StreamDataAsync(\r\n    data: data,\r\n    receiver: receiverDesc,\r\n    keySelector: dataItem => new IgniteTuple { ["id"] = dataItem.Id },\r\n    payloadSelector: dataItem => dataItem,\r\n    receiverArg: new MyArg("Some info"));\r\n\r\nawait foreach (MyResult result in results)\r\n{\r\n    Console.WriteLine(result);\r\n}\r\n\r\npublic record MyData(int Id, string Name);\r\n\r\npublic record MyArg(string Info);\r\n\r\npublic record MyResult(MyData Data, MyArg Arg);\r\n\r\npublic class MyReceiver : IDataStreamerReceiver<MyData, MyArg, MyResult>\r\n{\r\n    public IMarshaller<MyData> PayloadMarshaller =>\r\n        new JsonMarshaller<MyData>();\r\n\r\n    public IMarshaller<MyArg> ArgumentMarshaller =>\r\n        new JsonMarshaller<MyArg>();\r\n\r\n    public IMarshaller<MyResult> ResultMarshaller =>\r\n        new JsonMarshaller<MyResult>();\r\n\r\n    public ValueTask<IList<MyResult>?> ReceiveAsync(IList<MyData> page, MyArg arg, IDataStreamerReceiverContext context, CancellationToken cancellationToken)\r\n    {\r\n        IList<MyResult> results = page\r\n            .Select(data => new MyResult(data, arg))\r\n            .ToList();\r\n\r\n        return ValueTask.FromResult(results)!;\r\n    }\r\n}\n'})}),"\n",(0,n.jsx)(r.h2,{id:"tracking-failed-entries",children:"Tracking Failed Entries"}),"\n",(0,n.jsxs)(r.p,{children:["If the data streamer fails to process any entries, it collects the failed items in a ",(0,n.jsx)(r.code,{children:"DataStreamerException"}),". You can catch this exception and access the failed entries using the ",(0,n.jsx)(r.code,{children:"failedItems()"})," method, as shown in the example below."]}),"\n",(0,n.jsx)(r.p,{children:"You can catch both asynchronous errors during background streaming and immediate submission errors:"}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'RecordView<Account> view = client.tables().table("accounts").recordView(Account.class);\r\n\r\nCompletableFuture<Void> streamerFut;\r\n\r\ntry (var publisher = new SubmissionPublisher<DataStreamerItem<Account>>()) {\r\nstreamerFut = view.streamData(publisher, options)\r\n.exceptionally(e -> {\r\nSystem.out.println("Failed items during background streaming: " +\r\n((DataStreamerException)e.getCause()).failedItems());\r\nreturn null;\r\n});\r\n\r\n    /** Trying to insert an account record. */\r\n    Account entry = new Account(1, "Account name", rnd.nextLong(100_000), rnd.nextBoolean());\r\n    publisher.submit(DataStreamerItem.of(entry));\r\n} catch (DataStreamerException e) {\r\n      /** Handle entries that failed during submission. */\r\n      System.out.println("Failed items during submission: " + e.failedItems());\r\n}\r\n\r\nstreamerFut.join();\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:'ITable? table = await Client.Tables.GetTableAsync("my-table");\r\nIRecordView<IIgniteTuple> view = table!.RecordBinaryView;\r\nIList<IIgniteTuple> data = [new IgniteTuple { ["key"] = 1L, ["val"] = "v" }];\r\n\r\ntry\r\n{\r\nawait view.StreamDataAsync(data.ToAsyncEnumerable());\r\n}\r\ncatch (DataStreamerException e)\r\n{\r\nConsole.WriteLine("Failed items: " + string.Join(",", e.FailedItems));\r\n}\n'})})})]}),"\n",(0,n.jsx)(r.h3,{id:"tuning-memory-usage",children:"Tuning Memory Usage"}),"\n",(0,n.jsx)(r.p,{children:"The data streamer may require a significant amount of memory to handle the requests in an orderly manner. Depending on your environment, you may want to increase or reduce the amount of memory reserved by the data streamer."}),"\n",(0,n.jsxs)(r.p,{children:["For every node in the cluster, the streamer reserves an amount of memory equal to ",(0,n.jsx)(r.code,{children:"pageSize"})," (1000 entries by default) multiplied by ",(0,n.jsx)(r.code,{children:"perPartitionParallelOperations"})," (1 by default) setting. For example, a 10-partition table with default parameters and average entry size of 1KB will reserve 10MB for operations."]}),"\n",(0,n.jsxs)(r.p,{children:["You can change these options while creating a ",(0,n.jsx)(r.code,{children:"DataStreamerOptions"})," object:"]}),"\n",(0,n.jsxs)(i.A,{groupId:"programming-languages",children:[(0,n.jsx)(l.A,{value:"java",label:"Java",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-java",children:'RecordView<Tuple> view = client.tables().table("accounts").recordView();\r\nvar publisher = new SubmissionPublisher<Tuple>();\r\n\r\nvar options = DataStreamerOptions.builder()\r\n        .pageSize(10_000)\r\n        .perPartitionParallelOperations(10)\r\n        .build();\r\n\r\nstreamerFut = view.streamData(publisher, options);\n'})})}),(0,n.jsx)(l.A,{value:"dotnet",label:".NET",children:(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-csharp",children:"// .NET streamer does not have a perPartitionParallelOperations option yet.\r\nvar options = new DataStreamerOptions\r\n{\r\nPageSize = 10_000\r\n};\n"})})})]}),"\n",(0,n.jsx)(r.p,{children:"Additionally, the data streamer periodically flushes incomplete buffers to ensure that messages are not delayed indefinitely. This is especially useful when a buffer fills slowly or never completely fills due to uneven data distribution."}),"\n",(0,n.jsxs)(r.p,{children:["This behavior is controlled by the ",(0,n.jsx)(r.code,{children:"autoFlushInterval"})," property, which is set to 5000 ms by default. You can also configure the ",(0,n.jsx)(r.code,{children:"retryLimit"})," parameter to define the maximum number of retry attempts for failed submissions, with a default value of 16."]})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}},73381:(e,r,t)=>{t.d(r,{A:()=>a});const a=t.p+"assets/images/data_streaming-6b2d018b11aa91d7b373e308efcd713f.png"}}]);