"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7505],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var l=t(96540);const a={},i=l.createContext(a);function s(e){const n=l.useContext(i);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),l.createElement(i.Provider,{value:n},e.children)}},57080:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"api-reference/native-clients/cpp/tables-api","title":"Tables API","description":"The Tables API provides CRUD operations on table data. It supports both binary tuple operations and typed C++ object operations through record views and key-value views.","source":"@site/docs/api-reference/native-clients/cpp/tables-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/tables-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/tables-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Tables API","id":"tables-api","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Client API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/client-api"},"next":{"title":"SQL API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/sql-api"}}');var a=t(74848),i=t(28453);const s={title:"Tables API",id:"tables-api",sidebar_position:2},r="Tables API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Table Access",id:"table-access",level:3},{value:"View Types",id:"view-types",level:3},{value:"Binary vs Typed Operations",id:"binary-vs-typed-operations",level:3},{value:"Transaction Support",id:"transaction-support",level:3},{value:"Getting Tables",id:"getting-tables",level:2},{value:"Retrieve a Single Table",id:"retrieve-a-single-table",level:3},{value:"List All Tables",id:"list-all-tables",level:3},{value:"Record Views",id:"record-views",level:2},{value:"Binary Record View",id:"binary-record-view",level:3},{value:"Typed Record View",id:"typed-record-view",level:3},{value:"Record View Operations",id:"record-view-operations",level:3},{value:"Key-Value Views",id:"key-value-views",level:2},{value:"Binary Key-Value View",id:"binary-key-value-view",level:3},{value:"Typed Key-Value View",id:"typed-key-value-view",level:3},{value:"Key-Value View Operations",id:"key-value-view-operations",level:3},{value:"Ignite Tuple",id:"ignite-tuple",level:2},{value:"Creating Tuples",id:"creating-tuples",level:3},{value:"Accessing Values",id:"accessing-values",level:3},{value:"Column Metadata",id:"column-metadata",level:3},{value:"Column Names",id:"column-names",level:3},{value:"Asynchronous Operations",id:"asynchronous-operations",level:2},{value:"Transaction Integration",id:"transaction-integration",level:2},{value:"Reference",id:"reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"tables-api",children:"Tables API"})}),"\n",(0,a.jsx)(n.p,{children:"The Tables API provides CRUD operations on table data. It supports both binary tuple operations and typed C++ object operations through record views and key-value views."}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"table-access",children:"Table Access"}),"\n",(0,a.jsxs)(n.p,{children:["Tables are accessed through the ",(0,a.jsx)(n.code,{children:"tables"})," interface obtained from the client. Each table provides multiple view types for different access patterns."]}),"\n",(0,a.jsx)(n.h3,{id:"view-types",children:"View Types"}),"\n",(0,a.jsx)(n.p,{children:"Apache Ignite provides two view categories:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Record Views"})," operate on complete row data. A single tuple or object contains all columns including the primary key. Use record views when working with complete records."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key-Value Views"})," separate primary key columns from value columns. Operations use distinct key and value tuples or objects. Use key-value views when the domain model separates keys from data."]}),"\n",(0,a.jsx)(n.h3,{id:"binary-vs-typed-operations",children:"Binary vs Typed Operations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Binary Views"})," use ",(0,a.jsx)(n.code,{children:"ignite_tuple"})," for dynamic column access without schema knowledge. Column values are accessed by name or index at runtime."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Typed Views"})," use C++ structs or classes with compile-time type safety. Type conversion happens through ",(0,a.jsx)(n.code,{children:"convert_to_tuple"})," and ",(0,a.jsx)(n.code,{children:"convert_from_tuple"})," template specializations."]}),"\n",(0,a.jsx)(n.h3,{id:"transaction-support",children:"Transaction Support"}),"\n",(0,a.jsxs)(n.p,{children:["All view operations accept an optional ",(0,a.jsx)(n.code,{children:"transaction*"})," parameter. Pass ",(0,a.jsx)(n.code,{children:"nullptr"})," for implicit transactions. Pass a transaction object for explicit transaction control."]}),"\n",(0,a.jsx)(n.h2,{id:"getting-tables",children:"Getting Tables"}),"\n",(0,a.jsx)(n.h3,{id:"retrieve-a-single-table",children:"Retrieve a Single Table"}),"\n",(0,a.jsx)(n.p,{children:"Get a table by name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'using namespace ignite;\n\nauto tables = client.get_tables();\nauto table = tables.get_table("my_table");\n\nif (table.has_value()) {\n    // Use table\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Get a table with qualified name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("my_schema.my_table");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Use async retrieval:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'tables.get_table_async("my_table", [](ignite_result<std::optional<table>> result) {\n    if (!result.has_error()) {\n        auto table = std::move(result).value();\n        if (table.has_value()) {\n            // Use table\n        }\n    }\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"list-all-tables",children:"List All Tables"}),"\n",(0,a.jsx)(n.p,{children:"Retrieve all tables:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto all_tables = tables.get_tables();\nfor (const auto& table : all_tables) {\n    std::cout << table.get_name() << std::endl;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Use async retrieval:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"tables.get_tables_async([](ignite_result<std::vector<table>> result) {\n    if (!result.has_error()) {\n        auto all_tables = std::move(result).value();\n        // Process tables\n    }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"record-views",children:"Record Views"}),"\n",(0,a.jsx)(n.h3,{id:"binary-record-view",children:"Binary Record View"}),"\n",(0,a.jsx)(n.p,{children:"Work with tuples directly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("accounts").value();\nauto view = table.get_record_binary_view();\n\n// Insert a record\nignite_tuple record{\n    {"id", 42},\n    {"name", "John Doe"},\n    {"balance", 1000.0}\n};\n\nview.upsert(nullptr, record);\n\n// Retrieve a record\nignite_tuple key{{"id", 42}};\nauto result = view.get(nullptr, key);\n\nif (result.has_value()) {\n    auto balance = result->get<double>("balance");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"typed-record-view",children:"Typed Record View"}),"\n",(0,a.jsx)(n.p,{children:"Work with C++ types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'struct account {\n    int64_t id;\n    std::string name;\n    double balance;\n};\n\n// Define type conversion (typically in a header)\nnamespace ignite {\n    template<>\n    struct convert_to_tuple<account> {\n        static ignite_tuple to_tuple(const account& obj) {\n            return ignite_tuple{\n                {"id", obj.id},\n                {"name", obj.name},\n                {"balance", obj.balance}\n            };\n        }\n    };\n\n    template<>\n    struct convert_from_tuple<account> {\n        static account from_tuple(const ignite_tuple& tuple) {\n            return account{\n                tuple.get<int64_t>("id"),\n                tuple.get<std::string>("name"),\n                tuple.get<double>("balance")\n            };\n        }\n    };\n}\n\n// Use typed view\nauto table = tables.get_table("accounts").value();\nauto view = table.get_record_view<account>();\n\naccount new_account{42, "John Doe", 1000.0};\nview.upsert(nullptr, new_account);\n\naccount key{42};\nauto result = view.get(nullptr, key);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"record-view-operations",children:"Record View Operations"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Basic Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Insert (fails if exists)\nbool inserted = view.insert(nullptr, record);\n\n// Upsert (insert or replace)\nview.upsert(nullptr, record);\n\n// Replace (fails if not exists)\nbool replaced = view.replace(nullptr, record);\n\n// Replace with old value check\nbool replaced = view.replace(nullptr, old_record, new_record);\n\n// Get and replace atomically\nauto old_record = view.get_and_replace(nullptr, new_record);\n\n// Get and upsert atomically\nauto old_record = view.get_and_upsert(nullptr, record);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Delete Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Remove by key\nbool removed = view.remove(nullptr, key);\n\n// Remove exact match\nbool removed = view.remove_exact(nullptr, full_record);\n\n// Remove and return old value\nauto old_record = view.get_and_remove(nullptr, key);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Batch Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"std::vector<ignite_tuple> records = {record1, record2, record3};\n\n// Get multiple records\nauto results = view.get_all(nullptr, keys);\n\n// Insert multiple (returns skipped records)\nauto skipped = view.insert_all(nullptr, records);\n\n// Upsert multiple\nview.upsert_all(nullptr, records);\n\n// Remove multiple (returns non-existent keys)\nauto non_existent = view.remove_all(nullptr, keys);\n\n// Remove exact multiple\nauto not_matched = view.remove_all_exact(nullptr, records);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"key-value-views",children:"Key-Value Views"}),"\n",(0,a.jsx)(n.h3,{id:"binary-key-value-view",children:"Binary Key-Value View"}),"\n",(0,a.jsx)(n.p,{children:"Separate keys from values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("accounts").value();\nauto view = table.get_key_value_binary_view();\n\n// Put a key-value pair\nignite_tuple key{{"id", 42}};\nignite_tuple value{\n    {"name", "John Doe"},\n    {"balance", 1000.0}\n};\n\nview.put(nullptr, key, value);\n\n// Get value by key\nauto result = view.get(nullptr, key);\n\n// Check key existence\nbool exists = view.contains(nullptr, key);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"typed-key-value-view",children:"Typed Key-Value View"}),"\n",(0,a.jsx)(n.p,{children:"Use separate C++ types for keys and values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'struct account_key {\n    int64_t id;\n};\n\nstruct account_data {\n    std::string name;\n    double balance;\n};\n\n// Define conversions for both types\n// (Similar to record view example)\n\nauto table = tables.get_table("accounts").value();\nauto view = table.get_key_value_view<account_key, account_data>();\n\naccount_key key{42};\naccount_data data{"John Doe", 1000.0};\n\nview.put(nullptr, key, data);\nauto result = view.get(nullptr, key);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"key-value-view-operations",children:"Key-Value View Operations"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Basic Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Put (insert or replace)\nview.put(nullptr, key, value);\n\n// Put if absent\nbool inserted = view.put_if_absent(nullptr, key, value);\n\n// Get and put atomically\nauto old_value = view.get_and_put(nullptr, key, value);\n\n// Replace\nbool replaced = view.replace(nullptr, key, value);\n\n// Replace with old value check\nbool replaced = view.replace(nullptr, key, old_value, new_value);\n\n// Get and replace atomically\nauto old_value = view.get_and_replace(nullptr, key, value);\n\n// Check existence\nbool exists = view.contains(nullptr, key);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Delete Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"// Remove by key\nbool removed = view.remove(nullptr, key);\n\n// Remove with value check\nbool removed = view.remove(nullptr, key, expected_value);\n\n// Remove and return value\nauto old_value = view.get_and_remove(nullptr, key);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Batch Operations:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"std::vector<std::pair<K, V>> pairs = {{key1, val1}, {key2, val2}};\n\n// Get multiple values\nauto values = view.get_all(nullptr, keys);\n\n// Put multiple pairs\nview.put_all(nullptr, pairs);\n\n// Remove multiple keys\nauto non_existent = view.remove_all(nullptr, keys);\n\n// Remove multiple pairs with value checks\nauto not_matched = view.remove_all(nullptr, pairs);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ignite-tuple",children:"Ignite Tuple"}),"\n",(0,a.jsx)(n.h3,{id:"creating-tuples",children:"Creating Tuples"}),"\n",(0,a.jsx)(n.p,{children:"Use initializer lists:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple tuple{\n    {"id", 42},\n    {"name", "John"},\n    {"active", true}\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"Construct with capacity hint:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple tuple(10); // Reserve space for 10 columns\ntuple.set("id", 42);\ntuple.set("name", "John");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"accessing-values",children:"Accessing Values"}),"\n",(0,a.jsx)(n.p,{children:"Access by name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'auto id = tuple.get<int64_t>("id");\nauto name = tuple.get<std::string>("name");\n\n// Or use primitive wrapper\nauto value = tuple.get("id"); // Returns primitive\n'})}),"\n",(0,a.jsx)(n.p,{children:"Access by index:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto id = tuple.get<int64_t>(0);\nauto name = tuple.get<std::string>(1);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"column-metadata",children:"Column Metadata"}),"\n",(0,a.jsx)(n.p,{children:"Query column information:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'int32_t count = tuple.column_count();\nstd::string name = tuple.column_name(0);\nint32_t index = tuple.column_ordinal("id");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"column-names",children:"Column Names"}),"\n",(0,a.jsx)(n.p,{children:"Column names are case-insensitive and normalized to uppercase unless quoted:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'tuple.set("ID", 42);\ntuple.set("id", 42);  // Same as above\ntuple.set("Id", 42);  // Same as above\n\n// Use quotes for case-sensitive names\ntuple.set("\\"Id\\"", 42);  // Different from above\n'})}),"\n",(0,a.jsx)(n.h2,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,a.jsxs)(n.p,{children:["All operations have async variants with ",(0,a.jsx)(n.code,{children:"_async"})," suffix:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"view.get_async(nullptr, key, [](ignite_result<std::optional<ignite_tuple>> result) {\n    if (!result.has_error()) {\n        auto tuple = std::move(result).value();\n        if (tuple.has_value()) {\n            // Use tuple\n        }\n    }\n});\n\nview.upsert_async(nullptr, record, [](ignite_result<void> result) {\n    if (!result.has_error()) {\n        // Operation succeeded\n    }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"transaction-integration",children:"Transaction Integration"}),"\n",(0,a.jsx)(n.p,{children:"Use explicit transactions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"auto tx = client.get_transactions().begin();\n\ntry {\n    view.upsert(&tx, record1);\n    view.upsert(&tx, record2);\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./sql-api",children:"SQL API"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"./transactions-api",children:"Transactions API"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);