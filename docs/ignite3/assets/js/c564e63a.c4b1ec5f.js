"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6667],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>i});var s=t(96540);const a={},r=s.createContext(a);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},60816:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"api-reference/native-clients/dotnet/sql-api","title":"SQL API","description":"The SQL API executes SQL queries and scripts against Ignite tables. It supports parameterized queries, typed result mapping, metadata access, and both result set and data reader patterns for consuming query results.","source":"@site/docs/api-reference/native-clients/dotnet/sql-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/sql-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/sql-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"SQL API","id":"sql-api","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Data Streamer API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/data-streamer-api"},"next":{"title":"ADO.NET API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/ado-net-api"}}');var a=t(74848),r=t(28453);const l={title:"SQL API",id:"sql-api",sidebar_position:4},i="SQL API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Result Handling",id:"result-handling",level:3},{value:"Transaction Integration",id:"transaction-integration",level:3},{value:"Lazy Loading",id:"lazy-loading",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Query Execution",id:"basic-query-execution",level:3},{value:"Typed Query Results",id:"typed-query-results",level:3},{value:"Parameterized Queries",id:"parameterized-queries",level:3},{value:"DML Operations",id:"dml-operations",level:3},{value:"DDL Operations",id:"ddl-operations",level:3},{value:"Using Data Reader",id:"using-data-reader",level:3},{value:"Batch Execution",id:"batch-execution",level:3},{value:"Script Execution",id:"script-execution",level:3},{value:"Query with Metadata",id:"query-with-metadata",level:3},{value:"Transactional Queries",id:"transactional-queries",level:3},{value:"Cancellation Support",id:"cancellation-support",level:3},{value:"Collecting Results",id:"collecting-results",level:3},{value:"Reference",id:"reference",level:2},{value:"ISql Interface",id:"isql-interface",level:3},{value:"IResultSet&lt;T&gt; Interface",id:"iresultsett-interface",level:3},{value:"IResultSetMetadata Interface",id:"iresultsetmetadata-interface",level:3},{value:"IColumnMetadata Interface",id:"icolumnmetadata-interface",level:3},{value:"IgniteDbDataReader Class",id:"ignitedbdatareader-class",level:3},{value:"SqlStatement Record",id:"sqlstatement-record",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"sql-api",children:"SQL API"})}),"\n",(0,a.jsx)(n.p,{children:"The SQL API executes SQL queries and scripts against Ignite tables. It supports parameterized queries, typed result mapping, metadata access, and both result set and data reader patterns for consuming query results."}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsx)(n.p,{children:"SQL queries in Ignite 3 execute against distributed tables using a Calcite-based SQL engine. Queries can span multiple tables and leverage distributed execution across cluster nodes."}),"\n",(0,a.jsx)(n.h3,{id:"result-handling",children:"Result Handling"}),"\n",(0,a.jsx)(n.p,{children:"Query results are available through two interfaces. IResultSet provides async enumeration with full metadata access and is suitable for LINQ operations. IgniteDbDataReader provides forward-only access compatible with ADO.NET patterns."}),"\n",(0,a.jsx)(n.h3,{id:"transaction-integration",children:"Transaction Integration"}),"\n",(0,a.jsx)(n.p,{children:"All SQL operations accept an optional transaction parameter. Pass null for auto-commit mode or pass an ITransaction to execute queries within a transaction scope. This ensures consistency across SQL and key-value operations."}),"\n",(0,a.jsx)(n.h3,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,a.jsx)(n.p,{children:"Result sets use lazy loading. Rows are fetched from the cluster only as you enumerate them. This reduces memory usage for large result sets but means result sets can only be enumerated once."}),"\n",(0,a.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,a.jsx)(n.h3,{id:"basic-query-execution",children:"Basic Query Execution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var sql = client.Sql;\n\n// Execute query returning untyped tuples\nvar statement = new SqlStatement("SELECT * FROM customers WHERE region = ?");\nvar resultSet = await sql.ExecuteAsync(null, statement, "West");\n\nawait foreach (var row in resultSet)\n{\n    Console.WriteLine($"Customer: {row["name"]}, Email: {row["email"]}");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"typed-query-results",children:"Typed Query Results"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'public class CustomerDto\n{\n    public long Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\nvar statement = new SqlStatement("SELECT id, name, email FROM customers WHERE region = ?");\nvar resultSet = await sql.ExecuteAsync<CustomerDto>(null, statement, "West");\n\nawait foreach (var customer in resultSet)\n{\n    Console.WriteLine($"{customer.Name}: {customer.Email}");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"parameterized-queries",children:"Parameterized Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Positional parameters\nvar stmt = new SqlStatement(\n    "SELECT * FROM orders WHERE customer_id = ? AND order_date > ?");\nvar results = await sql.ExecuteAsync(\n    null, stmt, customerId, DateTime.UtcNow.AddDays(-30));\n\nawait foreach (var order in results)\n{\n    Console.WriteLine($"Order {order["order_id"]}: ${order["amount"]}");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"dml-operations",children:"DML Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Insert\nvar insertStmt = new SqlStatement(\n    "INSERT INTO customers (id, name, email) VALUES (?, ?, ?)");\nvar insertResult = await sql.ExecuteAsync(\n    null, insertStmt, 100L, "Alice", "alice@example.com");\n\nConsole.WriteLine($"Inserted {insertResult.AffectedRows} rows");\n\n// Update\nvar updateStmt = new SqlStatement(\n    "UPDATE customers SET email = ? WHERE id = ?");\nvar updateResult = await sql.ExecuteAsync(\n    null, updateStmt, "alice@newdomain.com", 100L);\n\nConsole.WriteLine($"Updated {updateResult.AffectedRows} rows");\n\n// Delete\nvar deleteStmt = new SqlStatement("DELETE FROM customers WHERE id = ?");\nvar deleteResult = await sql.ExecuteAsync(null, deleteStmt, 100L);\n\nConsole.WriteLine($"Deleted {deleteResult.AffectedRows} rows");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"ddl-operations",children:"DDL Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'// Create table\nvar createStmt = new SqlStatement(@"\n    CREATE TABLE IF NOT EXISTS products (\n        id BIGINT PRIMARY KEY,\n        name VARCHAR,\n        price DECIMAL(10, 2)\n    )");\n\nvar result = await sql.ExecuteAsync(null, createStmt);\nConsole.WriteLine($"Table created: {result.WasApplied}");\n\n// Drop table\nvar dropStmt = new SqlStatement("DROP TABLE IF EXISTS products");\nawait sql.ExecuteAsync(null, dropStmt);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-data-reader",children:"Using Data Reader"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var statement = new SqlStatement("SELECT * FROM orders WHERE amount > ?");\nusing var reader = await sql.ExecuteReaderAsync(null, statement, 100.0);\n\nwhile (await reader.ReadAsync())\n{\n    var orderId = reader.GetInt64(0);\n    var amount = reader.GetDecimal(3);\n    Console.WriteLine($"Order {orderId}: ${amount}");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"batch-execution",children:"Batch Execution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var statement = new SqlStatement(\n    "INSERT INTO customers (id, name, email) VALUES (?, ?, ?)");\n\nvar argSets = new[]\n{\n    new object[] { 1L, "Alice", "alice@example.com" },\n    new object[] { 2L, "Bob", "bob@example.com" },\n    new object[] { 3L, "Carol", "carol@example.com" }\n};\n\nvar affectedRows = await sql.ExecuteBatchAsync(null, statement, argSets);\n\nfor (int i = 0; i < affectedRows.Length; i++)\n{\n    Console.WriteLine($"Statement {i}: {affectedRows[i]} rows affected");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"script-execution",children:"Script Execution"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:"var script = new SqlStatement(@\"\n    CREATE TABLE temp_data (id BIGINT PRIMARY KEY, value VARCHAR);\n    INSERT INTO temp_data VALUES (1, 'test');\n    INSERT INTO temp_data VALUES (2, 'data');\n\");\n\nawait sql.ExecuteScriptAsync(script);\nConsole.WriteLine(\"Script executed successfully\");\n"})}),"\n",(0,a.jsx)(n.h3,{id:"query-with-metadata",children:"Query with Metadata"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var statement = new SqlStatement("SELECT id, name, email, created_at FROM customers");\nvar resultSet = await sql.ExecuteAsync(null, statement);\n\nif (resultSet.Metadata != null)\n{\n    Console.WriteLine("Columns:");\n    foreach (var column in resultSet.Metadata.Columns)\n    {\n        Console.WriteLine($"  {column.Name}: {column.Type} " +\n            $"(nullable: {column.Nullable}, precision: {column.Precision})");\n    }\n}\n\nawait foreach (var row in resultSet)\n{\n    // Process rows\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"transactional-queries",children:"Transactional Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var tx = await client.Transactions.BeginAsync();\ntry\n{\n    // Query within transaction\n    var selectStmt = new SqlStatement(\n        "SELECT balance FROM accounts WHERE id = ?");\n    var result = await sql.ExecuteAsync<Account>(tx, selectStmt, accountId);\n\n    var accounts = await result.ToListAsync();\n    var account = accounts[0];\n\n    // Update within same transaction\n    var updateStmt = new SqlStatement(\n        "UPDATE accounts SET balance = ? WHERE id = ?");\n    await sql.ExecuteAsync(tx, updateStmt, account.Balance - 100, accountId);\n\n    await tx.CommitAsync();\n}\ncatch\n{\n    await tx.RollbackAsync();\n    throw;\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cancellation-support",children:"Cancellation Support"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'using var cts = new CancellationTokenSource();\ncts.CancelAfter(TimeSpan.FromSeconds(30));\n\ntry\n{\n    var statement = new SqlStatement("SELECT * FROM large_table");\n    var resultSet = await sql.ExecuteAsync(null, statement, cts.Token);\n\n    await foreach (var row in resultSet.WithCancellation(cts.Token))\n    {\n        // Process rows\n    }\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine("Query cancelled");\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"collecting-results",children:"Collecting Results"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'var statement = new SqlStatement("SELECT id, name FROM customers");\nvar resultSet = await sql.ExecuteAsync<CustomerDto>(null, statement);\n\n// Collect to list\nvar customers = await resultSet.ToListAsync();\n\n// Collect to dictionary\nvar customerMap = await resultSet.ToDictionaryAsync(\n    c => c.Id,\n    c => c.Name);\n\n// Custom collection\nvar customResult = await resultSet.CollectAsync(\n    constructor: size => new List<CustomerDto>(size),\n    accumulator: (list, customer) => list.Add(customer));\n'})}),"\n",(0,a.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,a.jsx)(n.h3,{id:"isql-interface",children:"ISql Interface"}),"\n",(0,a.jsx)(n.p,{children:"Query execution methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteAsync(ITransaction?, SqlStatement, params object?[]?)"})," - Execute query returning IResultSet<IIgniteTuple>"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteAsync(ITransaction?, SqlStatement, CancellationToken, params object?[]?)"})," - With cancellation token"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteAsync<T>(ITransaction?, SqlStatement, params object?[]?)"})," - Execute query returning IResultSet<T>"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteAsync<T>(ITransaction?, SqlStatement, CancellationToken, params object?[]?)"})," - With cancellation token"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Data reader methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteReaderAsync(ITransaction?, SqlStatement, params object?[]?)"})," - Return forward-only data reader"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteReaderAsync(ITransaction?, SqlStatement, CancellationToken, params object?[]?)"})," - With cancellation token"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Batch and script methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteScriptAsync(SqlStatement, params object?[]?)"})," - Execute multi-statement script"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteScriptAsync(SqlStatement, CancellationToken, params object?[]?)"})," - With cancellation token"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ExecuteBatchAsync(ITransaction?, SqlStatement, IEnumerable<IEnumerable<object?>>, CancellationToken)"})," - Execute statement with multiple argument sets (DML only)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"iresultsett-interface",children:"IResultSet<T> Interface"}),"\n",(0,a.jsx)(n.p,{children:"Properties:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Metadata"})," - Result set metadata (null for DML/DDL statements)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"HasRowSet"})," - True if result contains rows (SELECT queries)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"AffectedRows"})," - Number of rows affected by DML operation (0 for DDL, -1 if not applicable)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WasApplied"})," - True if conditional DDL statement (CREATE IF NOT EXISTS) was applied"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Enumeration:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.strong,{children:"IAsyncEnumerable<T>"})," for async iteration"]}),"\n",(0,a.jsx)(n.li,{children:"Can only be enumerated once"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Collection methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ToListAsync()"})," - Collect all rows into a list"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ToDictionaryAsync<TK, TV>(Func<T, TK> keySelector, Func<T, TV> valSelector, IEqualityComparer<TK>?)"})," - Collect into dictionary"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"CollectAsync<TResult>(Func<int, TResult> constructor, Action<TResult, T> accumulator)"})," - Custom collection logic"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Resource management:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.strong,{children:"IAsyncDisposable"})," and ",(0,a.jsx)(n.strong,{children:"IDisposable"})]}),"\n",(0,a.jsx)(n.li,{children:"Automatically disposed after enumeration completes"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"iresultsetmetadata-interface",children:"IResultSetMetadata Interface"}),"\n",(0,a.jsx)(n.p,{children:"Properties:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Columns"})," - Read-only list of column metadata in result order"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"IndexOf(string columnName)"})," - Get column index by name (returns -1 if not found)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"icolumnmetadata-interface",children:"IColumnMetadata Interface"}),"\n",(0,a.jsx)(n.p,{children:"Properties:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Name"})," - Column name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Type"})," - Column data type (ColumnType enum)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Precision"})," - Column precision (-1 if not applicable)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Scale"})," - Column scale for numeric types"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nullable"})," - Whether column allows null values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Origin"})," - Original column information for aliased columns"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The precision meaning varies by type. For numeric types it represents decimal digits, for string types it represents maximum length."}),"\n",(0,a.jsx)(n.h3,{id:"ignitedbdatareader-class",children:"IgniteDbDataReader Class"}),"\n",(0,a.jsx)(n.p,{children:"Forward-only data reader implementing ADO.NET patterns:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Extends ",(0,a.jsx)(n.strong,{children:"DbDataReader"})," for ADO.NET compatibility"]}),"\n",(0,a.jsxs)(n.li,{children:["Supports ",(0,a.jsx)(n.strong,{children:"ReadAsync()"})," for row-by-row access"]}),"\n",(0,a.jsxs)(n.li,{children:["Provides typed ",(0,a.jsx)(n.strong,{children:"Get"}),"* methods (GetInt64, GetString, GetDecimal, etc.)"]}),"\n",(0,a.jsxs)(n.li,{children:["Supports ",(0,a.jsx)(n.strong,{children:"IsDBNull()"})," for null checking"]}),"\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.strong,{children:"IAsyncDisposable"})," for resource cleanup"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Use this when you need forward-only access or compatibility with ADO.NET-based tools."}),"\n",(0,a.jsx)(n.h3,{id:"sqlstatement-record",children:"SqlStatement Record"}),"\n",(0,a.jsx)(n.p,{children:"Represents a SQL statement with parameters:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"SqlStatement(string query)"})," - Create statement with query text"]}),"\n",(0,a.jsx)(n.li,{children:"Supports positional parameters using ? placeholders"}),"\n",(0,a.jsx)(n.li,{children:"Parameters passed separately to execute methods"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Query text should use ? for parameter placeholders. Parameters are bound in order."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);