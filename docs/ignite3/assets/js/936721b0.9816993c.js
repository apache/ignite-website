"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[179],{28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var s=r(96540);const i={},a=s.createContext(i);function t(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:n},e.children)}},77222:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"understand/core-concepts/tables-and-schemas","title":"Tables and Schemas","description":"Tables are the primary data structure in Ignite 3. Unlike Ignite 2\'s cache-based model with Binary Objects, Ignite 3 stores data in tables with SQL-compatible schemas. This unifies the SQL and Key-Value APIs under a single data model.","source":"@site/docs/understand/core-concepts/tables-and-schemas.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/tables-and-schemas","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/tables-and-schemas","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"tables-and-schemas","title":"Tables and Schemas","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"What is Apache Ignite 3?","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/what-is-ignite"},"next":{"title":"Transactions and MVCC","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/transactions-and-mvcc"}}');var i=r(74848),a=r(28453);const t={id:"tables-and-schemas",title:"Tables and Schemas",sidebar_position:2},l=void 0,c={},d=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Schema Structure",id:"schema-structure",level:2},{value:"Column Types",id:"column-types",level:2},{value:"Fixed-Length Types",id:"fixed-length-types",level:3},{value:"Variable-Length Types",id:"variable-length-types",level:3},{value:"Primary Keys",id:"primary-keys",level:2},{value:"Schema Versioning",id:"schema-versioning",level:2},{value:"Table Views",id:"table-views",level:2},{value:"RecordView",id:"recordview",level:3},{value:"KeyValueView",id:"keyvalueview",level:3},{value:"Tuple Views",id:"tuple-views",level:3},{value:"Binary Row Format",id:"binary-row-format",level:2},{value:"Catalog Management",id:"catalog-management",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Tables are the primary data structure in Ignite 3. Unlike Ignite 2's cache-based model with Binary Objects, Ignite 3 stores data in tables with SQL-compatible schemas. This unifies the SQL and Key-Value APIs under a single data model."}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"The table system consists of three layers:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Public API Layer"\r\n        Table[Table Interface]\r\n        RV[RecordView]\r\n        KV[KeyValueView]\r\n        TV[TupleView]\r\n    end\r\n\r\n    subgraph "Schema Layer"\r\n        SD[SchemaDescriptor]\r\n        Col[Column Definitions]\r\n        Marsh[Marshallers]\r\n    end\r\n\r\n    subgraph "Catalog Layer"\r\n        Cat[Catalog]\r\n        CTD[CatalogTableDescriptor]\r\n        CSV[CatalogSchemaVersions]\r\n    end\r\n\r\n    subgraph "Storage Layer"\r\n        IT[InternalTable]\r\n        Part[Partitions]\r\n        BR[BinaryRow]\r\n    end\r\n\r\n    Table --\x3e RV & KV & TV\r\n    RV & KV & TV --\x3e Marsh\r\n    Marsh --\x3e SD\r\n    SD --\x3e Col\r\n    CTD --\x3e CSV\r\n    Cat --\x3e CTD\r\n    IT --\x3e Part\r\n    Part --\x3e BR\r\n    SD -.-> CTD'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Catalog Layer"}),": Maintains versioned metadata for schemas, tables, indexes, and distribution zones"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schema Layer"}),": Defines column types, handles binary serialization, and manages schema evolution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Storage Layer"}),": Manages partitioned data storage using binary row format"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"schema-structure",children:"Schema Structure"}),"\n",(0,i.jsxs)(n.p,{children:["Each table has a ",(0,i.jsx)(n.code,{children:"SchemaDescriptor"})," that defines its structure. The descriptor maintains multiple column orderings:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Ordering"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Row position"}),(0,i.jsx)(n.td,{children:"Full row serialization order"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Key position"}),(0,i.jsx)(n.td,{children:"Primary key columns only"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Value position"}),(0,i.jsx)(n.td,{children:"Non-key columns only"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Colocation position"}),(0,i.jsx)(n.td,{children:"Columns used for partition assignment"})]})]})]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "SchemaDescriptor"\r\n        direction TB\r\n        V[Version: 1]\r\n\r\n        subgraph "Column Orderings"\r\n            RP["Row: [id, name, balance, region]"]\r\n            KP["Key: [id]"]\r\n            VP["Value: [name, balance, region]"]\r\n            CP["Colocation: [id]"]\r\n        end\r\n    end'}),"\n",(0,i.jsxs)(n.p,{children:["The schema tracks column positions across these orderings. A column absent from a specific ordering has position ",(0,i.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"column-types",children:"Column Types"}),"\n",(0,i.jsx)(n.p,{children:"Ignite 3 supports two categories of native types:"}),"\n",(0,i.jsx)(n.h3,{id:"fixed-length-types",children:"Fixed-Length Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Size (bytes)"}),(0,i.jsx)(n.th,{children:"Java Mapping"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BOOLEAN"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INT8"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"byte"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INT16"}),(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"short"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INT32"}),(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INT64"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"long"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"FLOAT"}),(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"float"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DOUBLE"}),(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"double"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"UUID"}),(0,i.jsx)(n.td,{children:"16"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"java.util.UUID"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DATE"}),(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"java.time.LocalDate"})})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"variable-length-types",children:"Variable-Length Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Max Size"}),(0,i.jsx)(n.th,{children:"Java Mapping"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"STRING"}),(0,i.jsx)(n.td,{children:"65536 (default)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"String"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BYTES"}),(0,i.jsx)(n.td,{children:"65536 (default)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"byte[]"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DECIMAL"}),(0,i.jsx)(n.td,{children:"precision/scale"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"BigDecimal"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TIME"}),(0,i.jsx)(n.td,{children:"precision (0-9)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"java.time.LocalTime"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DATETIME"}),(0,i.jsx)(n.td,{children:"precision (0-9)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"java.time.LocalDateTime"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"TIMESTAMP"}),(0,i.jsx)(n.td,{children:"precision (0-9)"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"java.time.Instant"})})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Ignite 3 requires JavaTime API for temporal types. Legacy types like ",(0,i.jsx)(n.code,{children:"java.util.Date"}),", ",(0,i.jsx)(n.code,{children:"java.sql.Date"}),", ",(0,i.jsx)(n.code,{children:"java.sql.Time"}),", and ",(0,i.jsx)(n.code,{children:"java.sql.Timestamp"})," are not supported."]})}),"\n",(0,i.jsx)(n.h2,{id:"primary-keys",children:"Primary Keys"}),"\n",(0,i.jsx)(n.p,{children:"Every table requires a primary key. Ignite 3 supports two primary key types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hash Primary Key"}),": Uses hash-based partitioning for data distribution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sorted Primary Key"}),": Uses range-based partitioning with collation ordering"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Primary key constraints:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"All primary key columns must be non-nullable"}),"\n",(0,i.jsx)(n.li,{children:"No duplicate columns allowed in key definition"}),"\n",(0,i.jsx)(n.li,{children:"All key columns must exist in the table schema"}),"\n",(0,i.jsx)(n.li,{children:"A primary key index is automatically created"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE accounts (\r\n    account_id INT PRIMARY KEY,\r\n    name VARCHAR(100),\r\n    balance DECIMAL(10, 2)\r\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"For composite keys:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE order_items (\r\n    order_id INT,\r\n    item_id INT,\r\n    quantity INT,\r\n    PRIMARY KEY (order_id, item_id)\r\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"schema-versioning",children:"Schema Versioning"}),"\n",(0,i.jsxs)(n.p,{children:["Ignite 3 uses append-only schema versioning. Each ",(0,i.jsx)(n.code,{children:"ALTER TABLE"})," operation increments the catalog version and creates a new schema version for the table."]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Schema Evolution"\r\n        V1["Version 1<br/>[id, name]"]\r\n        V2["Version 2<br/>[id, name, email]"]\r\n        V3["Version 3<br/>[id, name, email, status]"]\r\n    end\r\n\r\n    V1 --\x3e|"ALTER TABLE<br/>ADD email"| V2\r\n    V2 --\x3e|"ALTER TABLE<br/>ADD status"| V3'}),"\n",(0,i.jsx)(n.p,{children:"Key versioning behaviors:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutable versions"}),": Schema versions are never modified after creation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consecutive numbering"}),": Versions increment by 1 with no gaps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Column mapper"}),": Tracks transformations between versions for automatic data migration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Binary row versioning"}),": Each stored row carries its schema version"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When reading data written with an older schema version, Ignite automatically upgrades the row using the ",(0,i.jsx)(n.code,{children:"ColumnMapper"}),". New columns receive their default values."]}),"\n",(0,i.jsx)(n.h2,{id:"table-views",children:"Table Views"}),"\n",(0,i.jsx)(n.p,{children:"Tables expose multiple view abstractions for different access patterns:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    T[Table]\r\n\r\n    subgraph "Record Views"\r\n        TRV["Tuple RecordView<br/>(schema-less)"]\r\n        PRV["POJO RecordView<br/>(type-mapped)"]\r\n    end\r\n\r\n    subgraph "Key-Value Views"\r\n        TKV["Tuple KeyValueView<br/>(schema-less)"]\r\n        PKV["POJO KeyValueView<br/>(type-mapped)"]\r\n    end\r\n\r\n    T --\x3e TRV & PRV\r\n    T --\x3e TKV & PKV'}),"\n",(0,i.jsx)(n.h3,{id:"recordview",children:"RecordView"}),"\n",(0,i.jsx)(n.p,{children:"Works with complete row records containing all fields including the primary key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'RecordView<Account> accounts = table.recordView(Account.class);\r\n\r\nAccount account = new Account(123, "John Doe", 1000.00);\r\naccounts.insert(null, account);\r\n\r\nAccount retrieved = accounts.get(null, new Account(123));\n'})}),"\n",(0,i.jsx)(n.h3,{id:"keyvalueview",children:"KeyValueView"}),"\n",(0,i.jsx)(n.p,{children:"Separates keys from values. Use this when the primary key is not logically part of the domain object:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'KeyValueView<Long, Account> accounts = table.keyValueView(\r\n    Mapper.of(Long.class),\r\n    Mapper.of(Account.class)\r\n);\r\n\r\naccounts.put(null, 123L, new Account("John Doe", 1000.00));\r\nAccount account = accounts.get(null, 123L);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"tuple-views",children:"Tuple Views"}),"\n",(0,i.jsx)(n.p,{children:"For schema-less access without predefined classes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\r\n\r\nTuple record = Tuple.create()\r\n    .set("id", 123)\r\n    .set("name", "John Doe")\r\n    .set("balance", 1000.00);\r\n\r\nview.insert(null, record);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"binary-row-format",children:"Binary Row Format"}),"\n",(0,i.jsx)(n.p,{children:"Data is stored in a compact binary format optimized for zero-copy reads:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "BinaryRow Structure"\r\n        SV[Schema Version<br/>2 bytes]\r\n        NB[Null Bitmap]\r\n        FD[Fixed-Length Data]\r\n        VO[Variable Offsets]\r\n        VD[Variable Data]\r\n    end\r\n\r\n    SV --\x3e NB --\x3e FD --\x3e VO --\x3e VD'}),"\n",(0,i.jsx)(n.p,{children:"The format supports:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Null tracking"}),": Bitmap indicates null columns without storing placeholder data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Direct access"}),": Fixed-length columns accessed by offset without deserialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variable-length efficiency"}),": Offset table enables direct access to variable columns"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"catalog-management",children:"Catalog Management"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Catalog"})," maintains an immutable snapshot of the distributed schema at a specific version:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Tables are created via SQL\r\nclient.sql().execute(null,\r\n    "CREATE TABLE accounts (" +\r\n    "  id INT PRIMARY KEY," +\r\n    "  name VARCHAR(100)," +\r\n    "  balance DECIMAL(10,2)" +\r\n    ") WITH PRIMARY_ZONE=\'default\'"\r\n);\r\n\r\n// Access table via API\r\nTable accounts = client.tables().table("accounts");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Schema operations use ",(0,i.jsx)(n.code,{children:"CatalogCommand"})," implementations:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CreateTableCommand"}),": Creates new table with schema"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AlterTableAddColumnCommand"}),": Adds columns to existing table"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AlterTableDropColumnCommand"}),": Removes columns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DropTableCommand"}),": Removes table"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All catalog operations are atomic and version-tracked."}),"\n",(0,i.jsx)(n.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,i.jsx)(n.p,{children:"When working with tables:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Table creation requires SQL"}),": The Table API only provides read and write operations. Use SQL DDL to create, alter, or drop tables."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Schema version continuity"}),": Schema versions must increment consecutively. Early versions may be pruned but intermediate versions cannot be skipped."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Primary key immutability"}),": Primary key columns cannot be modified after table creation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nullable inference"}),": Primary key columns are automatically non-nullable. Including nullable columns in a primary key raises a validation error."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type constraints"}),": Variable-length types have maximum length constraints. DECIMAL requires explicit precision and scale."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/table-api",children:"Table API"})," for working with table views"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/3.1.0/sql/reference/language-definition/distribution-zones",children:"Distribution Zones"})," for partition configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/3.1.0/sql/reference/data-types-and-functions/data-types",children:"Data Types"})," for SQL type mappings"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);