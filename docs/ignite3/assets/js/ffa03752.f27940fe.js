"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6299],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},36304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"understand/core-concepts/what-is-ignite","title":"What is Apache Ignite 3?","description":"Apache Ignite is a distributed database designed for high-performance transactional and analytical workloads. It combines in-memory speed with disk persistence, providing both SQL and key-value access to the same data with full ACID transaction support.","source":"@site/docs/understand/core-concepts/what-is-ignite.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/what-is-ignite","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/what-is-ignite","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"what-is-ignite","title":"What is Apache Ignite 3?","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Core Concepts","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/"},"next":{"title":"Tables and Schemas","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/tables-and-schemas"}}');var i=t(74848),s=t(28453);const a={id:"what-is-ignite",title:"What is Apache Ignite 3?",sidebar_position:1},o=void 0,c={},d=[{value:"When to Use Ignite",id:"when-to-use-ignite",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Component Layers",id:"component-layers",level:3},{value:"Core Features",id:"core-features",level:2},{value:"Unified Data Model",id:"unified-data-model",level:3},{value:"ACID Transactions",id:"acid-transactions",level:3},{value:"Distribution Zones",id:"distribution-zones",level:3},{value:"Distributed Compute",id:"distributed-compute",level:3},{value:"Distributed SQL",id:"distributed-sql",level:3},{value:"Storage Options",id:"storage-options",level:3},{value:"Clients and Connectivity",id:"clients-and-connectivity",level:2},{value:"Management",id:"management",level:2},{value:"Changes from Ignite 2",id:"changes-from-ignite-2",level:2},{value:"Data Model",id:"data-model",level:3},{value:"Transactions",id:"transactions",level:3},{value:"Distribution Configuration",id:"distribution-configuration",level:3},{value:"Client Model",id:"client-model",level:3},{value:"Compute API",id:"compute-api",level:3},{value:"Management Tools",id:"management-tools",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Apache Ignite is a distributed database designed for high-performance transactional and analytical workloads. It combines in-memory speed with disk persistence, providing both SQL and key-value access to the same data with full ACID transaction support."}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-ignite",children:"When to Use Ignite"}),"\n",(0,i.jsx)(n.p,{children:"Ignite fits workloads that require low-latency data access at scale:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Workload"}),(0,i.jsx)(n.th,{children:"How Ignite Helps"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"High-throughput OLTP"})}),(0,i.jsx)(n.td,{children:"In-memory processing with persistent storage handles millions of transactions per second"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Real-time analytics"})}),(0,i.jsx)(n.td,{children:"Distributed SQL queries execute across partitioned data without ETL"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Caching layer"})}),(0,i.jsx)(n.td,{children:"Replace external caches with a transactional, SQL-queryable data layer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Microservices data"})}),(0,i.jsx)(n.td,{children:"Shared distributed state with strong consistency guarantees"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Event processing"})}),(0,i.jsx)(n.td,{children:"Colocated compute executes business logic where data resides"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Ignite clusters consist of server nodes that store partitioned data and execute distributed queries and compute jobs. Clients connect through a lightweight protocol without joining the cluster topology."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Applications"\r\n        App1[Java App]\r\n        App2[.NET App]\r\n        App3[C++ App]\r\n        SQL[SQL Tools]\r\n    end\r\n\r\n    subgraph "Apache Ignite Cluster"\r\n        subgraph "Node 1"\r\n            P1[Partitions]\r\n            C1[Compute]\r\n        end\r\n        subgraph "Node 2"\r\n            P2[Partitions]\r\n            C2[Compute]\r\n        end\r\n        subgraph "Node 3"\r\n            P3[Partitions]\r\n            C3[Compute]\r\n        end\r\n    end\r\n\r\n    App1 & App2 & App3 --\x3e|"Thin Client"| P1 & P2 & P3\r\n    SQL --\x3e|"JDBC/ODBC"| P1 & P2 & P3'}),"\n",(0,i.jsx)(n.h3,{id:"component-layers",children:"Component Layers"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Client Layer"\r\n        Clients[Thin Clients]\r\n        JDBC[JDBC/ODBC]\r\n    end\r\n\r\n    subgraph "API Layer"\r\n        SQLEngine[SQL Engine]\r\n        TableAPI[Table API]\r\n        ComputeAPI[Compute API]\r\n    end\r\n\r\n    subgraph "Transaction Layer"\r\n        TX[Transaction Manager]\r\n        MVCCStore[MVCC Storage]\r\n        Locks[Lock Manager]\r\n    end\r\n\r\n    subgraph "Distribution Layer"\r\n        Zones[Distribution Zones]\r\n        Placement[Placement Driver]\r\n        Raft[Raft Consensus]\r\n    end\r\n\r\n    subgraph "Storage Layer"\r\n        Memory[In-Memory]\r\n        Disk[Persistent]\r\n    end\r\n\r\n    Clients --\x3e SQLEngine & TableAPI & ComputeAPI\r\n    JDBC --\x3e SQLEngine\r\n    SQLEngine & TableAPI --\x3e TX\r\n    TX --\x3e MVCCStore & Locks\r\n    MVCCStore --\x3e Zones\r\n    Zones --\x3e Placement\r\n    Placement --\x3e Raft\r\n    Raft --\x3e Memory & Disk'}),"\n",(0,i.jsx)(n.h2,{id:"core-features",children:"Core Features"}),"\n",(0,i.jsx)(n.h3,{id:"unified-data-model",children:"Unified Data Model"}),"\n",(0,i.jsx)(n.p,{children:"Tables provide a single data structure for both SQL and key-value operations. The same schema serves distributed queries and low-latency key lookups."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Table"\r\n        Schema[Schema Definition]\r\n    end\r\n\r\n    subgraph "Access Patterns"\r\n        SQL[SQL Queries]\r\n        KV[Key-Value API]\r\n        Compute[Colocated Compute]\r\n    end\r\n\r\n    Schema --\x3e SQL & KV & Compute'}),"\n",(0,i.jsx)(n.p,{children:"Create tables with SQL, then access them through any API:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE accounts (\r\n    id INT PRIMARY KEY,\r\n    name VARCHAR(100),\r\n    balance DECIMAL(10,2)\r\n) WITH PRIMARY_ZONE = 'default';\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Key-value access to the same table\r\nKeyValueView<Long, Account> kv = table.keyValueView(\r\n    Mapper.of(Long.class), Mapper.of(Account.class));\r\nAccount account = kv.get(null, 42L);\r\n\r\n// SQL access\r\nResultSet rs = client.sql().execute(null,\r\n    "SELECT * FROM accounts WHERE balance > ?", 1000);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"acid-transactions",children:"ACID Transactions"}),"\n",(0,i.jsx)(n.p,{children:"All tables support transactions by default using Multi-Version Concurrency Control (MVCC). Read-write transactions execute with serializable isolation. Read-only transactions provide snapshot isolation without acquiring locks."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Transaction Model"\r\n        MVCC["MVCC Engine"]\r\n\r\n        subgraph "Read-Write"\r\n            Serial["Serializable Isolation"]\r\n            Locks2["Lock-based"]\r\n            TwoPC["2PC Commit"]\r\n        end\r\n\r\n        subgraph "Read-Only"\r\n            Snapshot["Snapshot Isolation"]\r\n            LockFree["Lock-free"]\r\n            AnyReplica["Any Replica"]\r\n        end\r\n    end\r\n\r\n    MVCC --\x3e Serial & Snapshot\r\n    Serial --\x3e Locks2 --\x3e TwoPC\r\n    Snapshot --\x3e LockFree --\x3e AnyReplica'}),"\n",(0,i.jsx)(n.p,{children:"Transactions work across SQL and key-value operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'var tx = client.transactions().begin();\r\ntry {\r\n    // Mix SQL and key-value in same transaction\r\n    client.sql().execute(tx, "UPDATE accounts SET balance = balance - 100 WHERE id = ?", 1);\r\n    kv.put(tx, 2L, new Account("Jane", 100.00));\r\n    tx.commit();\r\n} catch (Exception e) {\r\n    tx.rollback();\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"distribution-zones",children:"Distribution Zones"}),"\n",(0,i.jsx)(n.p,{children:"Distribution zones control how data is partitioned and replicated across the cluster. Each zone defines partition count, replication factor, and node placement rules."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Distribution Zone"\r\n        Config["Zone: transactions_zone"]\r\n\r\n        subgraph "Configuration"\r\n            Part["Partitions: 64"]\r\n            Repl["Replicas: 3"]\r\n            Filter["Filter: region=us-east"]\r\n        end\r\n\r\n        subgraph "Assigned Tables"\r\n            T1[orders]\r\n            T2[payments]\r\n            T3[audit_log]\r\n        end\r\n    end\r\n\r\n    Config --\x3e Part & Repl & Filter\r\n    Part --\x3e T1 & T2 & T3'}),"\n",(0,i.jsx)(n.p,{children:"Tables in the same zone with matching colocation keys store related data on the same partitions, enabling efficient joins without network transfers."}),"\n",(0,i.jsx)(n.h3,{id:"distributed-compute",children:"Distributed Compute"}),"\n",(0,i.jsx)(n.p,{children:"Execute code where data resides to minimize network overhead. Jobs can target specific nodes, colocate with data partitions, or broadcast across the cluster."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Job Placement"\r\n        Any["Any Node"]\r\n        Coloc["Colocated"]\r\n        Bcast["Broadcast"]\r\n    end\r\n\r\n    subgraph "Execution"\r\n        N1[Node 1]\r\n        N2[Node 2]\r\n        N3[Node 3]\r\n    end\r\n\r\n    Any --\x3e N1\r\n    Coloc --\x3e|"Data-local"| N2\r\n    Bcast --\x3e N1 & N2 & N3'}),"\n",(0,i.jsx)(n.p,{children:"Colocated execution processes data without network transfer:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Execute on node holding account 42\'s partition\r\nJobExecution<Double> execution = client.compute().submit(\r\n    JobTarget.colocated("accounts", Tuple.create().set("id", 42L)),\r\n    JobDescriptor.builder(CalculateInterestJob.class).build(),\r\n    42L\r\n);\r\nDouble interest = execution.resultAsync().join();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"distributed-sql",children:"Distributed SQL"}),"\n",(0,i.jsx)(n.p,{children:"The SQL engine executes ANSI SQL queries across partitioned data. Query plans push predicates to partitions, aggregate results, and handle distributed joins."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Query Execution"\r\n        Query["SELECT * FROM orders o<br/>JOIN customers c ON o.cust_id = c.id<br/>WHERE c.region = \'US\'"]\r\n    end\r\n\r\n    subgraph "Distributed Plan"\r\n        Parse[Parse & Optimize]\r\n        Frag1[Fragment: customers scan]\r\n        Frag2[Fragment: orders scan]\r\n        Join[Colocated Join]\r\n        Agg[Aggregate Results]\r\n    end\r\n\r\n    Query --\x3e Parse\r\n    Parse --\x3e Frag1 & Frag2\r\n    Frag1 & Frag2 --\x3e Join\r\n    Join --\x3e Agg'}),"\n",(0,i.jsx)(n.p,{children:"Standard JDBC connectivity works with existing SQL tools:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'try (Connection conn = DriverManager.getConnection("jdbc:ignite:thin://localhost:10800")) {\r\n    PreparedStatement stmt = conn.prepareStatement(\r\n        "SELECT region, SUM(amount) FROM orders GROUP BY region");\r\n    ResultSet rs = stmt.executeQuery();\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"storage-options",children:"Storage Options"}),"\n",(0,i.jsx)(n.p,{children:"Ignite supports multiple storage engines optimized for different workloads:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Engine"}),(0,i.jsx)(n.th,{children:"Characteristics"}),(0,i.jsx)(n.th,{children:"Use Case"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"aimem"})}),(0,i.jsx)(n.td,{children:"In-memory only, volatile"}),(0,i.jsx)(n.td,{children:"Caching, session data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"aipersist"})}),(0,i.jsx)(n.td,{children:"In-memory with disk persistence"}),(0,i.jsx)(n.td,{children:"Primary data storage"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"rocksdb"})}),(0,i.jsx)(n.td,{children:"Disk-based with memory cache"}),(0,i.jsx)(n.td,{children:"Large datasets exceeding RAM"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Storage profiles assign engines to distribution zones:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"CREATE ZONE large_data WITH\r\n    STORAGE_PROFILES = 'rocksdb_profile',\r\n    PARTITIONS = 128,\r\n    REPLICAS = 3;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"clients-and-connectivity",children:"Clients and Connectivity"}),"\n",(0,i.jsx)(n.p,{children:"Ignite provides native thin clients and standard database connectivity:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Client"}),(0,i.jsx)(n.th,{children:"Language"}),(0,i.jsx)(n.th,{children:"Protocol"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Java Client"}),(0,i.jsx)(n.td,{children:"Java 11+"}),(0,i.jsx)(n.td,{children:"Binary"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:".NET Client"}),(0,i.jsx)(n.td,{children:".NET 6+"}),(0,i.jsx)(n.td,{children:"Binary"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"C++ Client"}),(0,i.jsx)(n.td,{children:"C++17"}),(0,i.jsx)(n.td,{children:"Binary"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"JDBC Driver"}),(0,i.jsx)(n.td,{children:"Any JVM"}),(0,i.jsx)(n.td,{children:"JDBC"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ODBC Driver"}),(0,i.jsx)(n.td,{children:"Any"}),(0,i.jsx)(n.td,{children:"ODBC"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Thin clients connect directly to cluster nodes without joining the topology:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'IgniteClient client = IgniteClient.builder()\r\n    .addresses("node1:10800", "node2:10800", "node3:10800")\r\n    .build();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"management",children:"Management"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ignite3"})," CLI provides cluster administration, configuration, and disaster recovery operations. Configuration uses HOCON format split between cluster-wide and node-specific settings."]}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "CLI"\r\n        Tool[ignite3]\r\n    end\r\n\r\n    subgraph "Operations"\r\n        Init[Cluster Init]\r\n        Config[Configuration]\r\n        Status[Health/Status]\r\n        Recovery[Disaster Recovery]\r\n    end\r\n\r\n    Tool --\x3e Init & Config & Status & Recovery'}),"\n",(0,i.jsx)(n.h2,{id:"changes-from-ignite-2",children:"Changes from Ignite 2"}),"\n",(0,i.jsx)(n.p,{children:"For teams migrating from Ignite 2, the following section summarizes architectural changes."}),"\n",(0,i.jsx)(n.h3,{id:"data-model",children:"Data Model"}),"\n",(0,i.jsx)(n.p,{children:"Ignite 2 stored data in caches using Binary Object format. SQL and key-value APIs operated on different representations. Ignite 3 replaces caches with tables that provide a unified schema for all access patterns."}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Ignite 2"\r\n        direction TB\r\n        C[Cache]\r\n        BO[Binary Objects]\r\n        SQL2[SQL Schema]\r\n        KV2[Key-Value API]\r\n        C --\x3e BO\r\n        BO --\x3e SQL2\r\n        BO --\x3e KV2\r\n    end\r\n\r\n    subgraph "Ignite 3"\r\n        direction TB\r\n        T[Table]\r\n        Schema2[Single Schema]\r\n        SQL3[SQL API]\r\n        KV3[Key-Value API]\r\n        T --\x3e Schema2\r\n        Schema2 --\x3e SQL3\r\n        Schema2 --\x3e KV3\r\n    end'}),"\n",(0,i.jsx)(n.h3,{id:"transactions",children:"Transactions"}),"\n",(0,i.jsx)(n.p,{children:"Ignite 2 transactions required cache atomicity configuration and had performance implications. Ignite 3 makes all tables transactional by default with MVCC-based concurrency control. The WAIT_DIE algorithm prevents deadlocks without detection overhead."}),"\n",(0,i.jsx)(n.h3,{id:"distribution-configuration",children:"Distribution Configuration"}),"\n",(0,i.jsx)(n.p,{children:"Ignite 2 spread distribution settings across affinity functions, backup configuration, and baseline topology. Ignite 3 consolidates these into distribution zones with explicit partition counts, replica factors, and node filters. Custom affinity functions are replaced by deterministic rendezvous hashing."}),"\n",(0,i.jsx)(n.h3,{id:"client-model",children:"Client Model"}),"\n",(0,i.jsx)(n.p,{children:"Ignite 2 thick clients joined the cluster as nodes, requiring full protocol participation. Ignite 3 uses thin clients exclusively for standard operations. Embedded mode remains available for specialized use cases."}),"\n",(0,i.jsx)(n.h3,{id:"compute-api",children:"Compute API"}),"\n",(0,i.jsxs)(n.p,{children:["Ignite 3 extends Ignite 2's compute capabilities with job state tracking, priority-based queuing, and automatic failover on node departure. All compute operations return ",(0,i.jsx)(n.code,{children:"CompletableFuture"})," for non-blocking execution."]}),"\n",(0,i.jsx)(n.h3,{id:"management-tools",children:"Management Tools"}),"\n",(0,i.jsxs)(n.p,{children:["Ignite 2 used multiple CLI scripts with overlapping functionality. Ignite 3 provides a single ",(0,i.jsx)(n.code,{children:"ignite3"})," CLI with interactive mode and command autocomplete. Configuration moved from XML to HOCON format."]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./tables-and-schemas",children:"Tables and Schemas"})," for data modeling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./distribution-and-colocation",children:"Distribution and Colocation"})," for partitioning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./transactions-and-mvcc",children:"Transactions and MVCC"})," for concurrency control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./compute-and-events",children:"Compute and Events"})," for distributed processing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/3.1.0/getting-started/",children:"Getting Started"})," to deploy your first cluster"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);