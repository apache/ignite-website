"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3280],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}},67572:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"understand/performance/using-explain","title":"Using EXPLAIN Command","description":"The EXPLAIN command displays the execution plan for a SQL query without running it. Use this to understand how the query optimizer processes your query and identify performance bottlenecks.","source":"@site/docs/understand/performance/using-explain.md","sourceDirName":"understand/performance","slug":"/understand/performance/using-explain","permalink":"/docs/ignite3/3.1.0/understand/performance/using-explain","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"using-explain","title":"Using EXPLAIN Command","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Performance","permalink":"/docs/ignite3/3.1.0/understand/performance/"},"next":{"title":"EXPLAIN Operators Reference","permalink":"/docs/ignite3/3.1.0/understand/performance/explain-operators"}}');var r=s(74848),a=s(28453);const t={id:"using-explain",title:"Using EXPLAIN Command",sidebar_position:1},l="Using EXPLAIN Command",o={},d=[{value:"EXPLAIN Command Syntax",id:"explain-command-syntax",level:2},{value:"Understanding The Output",id:"understanding-the-output",level:2},{value:"Operator Categories",id:"operator-categories",level:3},{value:"Plan Structure",id:"plan-structure",level:3},{value:"Common Query Optimization Issues",id:"common-query-optimization-issues",level:2},{value:"Full Scan Instead of Index Scan",id:"full-scan-instead-of-index-scan",level:2},{value:"Suboptimal Indexes",id:"suboptimal-indexes",level:2},{value:"Unexpected Sort Operation",id:"unexpected-sort-operation",level:2},{value:"Performance Impact of Correlated Subqueries",id:"performance-impact-of-correlated-subqueries",level:2},{value:"Excessive Sorting",id:"excessive-sorting",level:2},{value:"Select Count Optimization",id:"select-count-optimization",level:2},{value:"Index Scan Without Exact Search Bounds",id:"index-scan-without-exact-search-bounds",level:2},{value:"Prohibit Index Usage",id:"prohibit-index-usage",level:3},{value:"Manual Type Casting",id:"manual-type-casting",level:3},{value:"Colocation Usage",id:"colocation-usage",level:2},{value:"Additional EXPLAIN Examples",id:"additional-explain-examples",level:2},{value:"Example: Complex Join Query",id:"example-complex-join-query",level:3},{value:"Example: Query Mapping",id:"example-query-mapping",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"using-explain-command",children:"Using EXPLAIN Command"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"EXPLAIN"})," command displays the execution plan for a SQL query without running it. Use this to understand how the query optimizer processes your query and identify performance bottlenecks."]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Query Processing"\n        SQL[SQL Query] --\x3e Parser\n        Parser --\x3e Optimizer\n        Optimizer --\x3e Plan[Execution Plan]\n    end\n\n    subgraph "EXPLAIN Output"\n        Plan --\x3e PLAN[EXPLAIN PLAN<br/>Operator Tree]\n        Plan --\x3e MAP[EXPLAIN MAPPING<br/>Fragment Distribution]\n    end'}),"\n",(0,r.jsx)(n.p,{children:"The execution plan reveals:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Table access order and methods (full scan vs index scan)"}),"\n",(0,r.jsx)(n.li,{children:"Join algorithms (hash join, merge join, nested loop)"}),"\n",(0,r.jsx)(n.li,{children:"Index usage and search bounds"}),"\n",(0,r.jsx)(n.li,{children:"Row count estimates at each stage"}),"\n",(0,r.jsx)(n.li,{children:"Data distribution across cluster nodes (with MAPPING)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"explain-command-syntax",children:"EXPLAIN Command Syntax"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Ignite supports two variations of the ",(0,r.jsx)(n.code,{children:"EXPLAIN"})," command:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN [PLAN | MAPPING] FOR <query>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If neither ",(0,r.jsx)(n.code,{children:"PLAN"})," nor ",(0,r.jsx)(n.code,{children:"MAPPING"})," is specified, then ",(0,r.jsx)(n.code,{children:"PLAN"})," is implicit."]}),"\n",(0,r.jsx)(n.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PLAN"})," - explains query in terms of relational operators tree. This representation is suitable for investigation of performance issues related to the optimizer."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MAPPING"})," - explains query in terms of mapping of query fragment to a particular node of the cluster. This representation is suitable for investigation of performance issues related to the data colocation."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN SELECT * FROM lineitem;\nEXPLAIN PLAN FOR SELECT * FROM lineitem;\nEXPLAIN MAPPING FOR SELECT * FROM lineitem;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"understanding-the-output",children:"Understanding The Output"}),"\n",(0,r.jsx)(n.p,{children:"Each query plan is a tree of relational operators. Data flows from leaf nodes (table scans) up through transformation nodes (joins, sorts) to the root node (final result)."}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Query Plan Tree"\n        Root[Project<br/>fieldNames: result columns]\n        Join[HashJoin<br/>predicate: join condition]\n        Scan1[TableScan<br/>table: ORDERS]\n        Scan2[IndexScan<br/>table: CUSTOMERS<br/>index: IDX_CUST_ID]\n    end\n\n    Root --\x3e Join\n    Join --\x3e Scan1\n    Join --\x3e Scan2\n\n    subgraph "Data Flow"\n        direction TB\n        D1[Rows from ORDERS] --\x3e D3[Joined Rows]\n        D2[Rows from CUSTOMERS] --\x3e D3\n        D3 --\x3e D4[Projected Result]\n    end'}),"\n",(0,r.jsx)(n.p,{children:"Each operator node includes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Name"}),": The algorithm used (TableScan, HashJoin, Sort, etc.)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Attributes"}),": Operator-specific details (table name, predicate, field names)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Estimate"}),": Expected row count at this stage (",(0,r.jsx)(n.code,{children:"est: (rows=N)"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"OperatorName\n    attribute1: value1\n    attribute2: value2\n    est: (rows=N)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"operator-categories",children:"Operator Categories"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Category"}),(0,r.jsx)(n.th,{children:"Operators"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scan"})}),(0,r.jsx)(n.td,{children:"TableScan, IndexScan, SystemViewScan"}),(0,r.jsx)(n.td,{children:"Read data from tables"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Join"})}),(0,r.jsx)(n.td,{children:"HashJoin, MergeJoin, NestedLoopJoin"}),(0,r.jsx)(n.td,{children:"Combine rows from multiple sources"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Aggregate"})}),(0,r.jsx)(n.td,{children:"ColocatedHashAggregate, MapSortAggregate"}),(0,r.jsx)(n.td,{children:"GROUP BY operations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Transform"})}),(0,r.jsx)(n.td,{children:"Project, Filter, Sort, Limit"}),(0,r.jsx)(n.td,{children:"Shape and order results"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Distribution"})}),(0,r.jsx)(n.td,{children:"Exchange, Sender, Receiver"}),(0,r.jsx)(n.td,{children:"Move data between nodes"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"./explain-operators",children:"EXPLAIN Operators Reference"})," for the complete operator list."]}),"\n",(0,r.jsx)(n.h3,{id:"plan-structure",children:"Plan Structure"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leaf nodes"}),": Data sources (TableScan, IndexScan)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Internal nodes"}),": Transformations (Join, Sort, Aggregate)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Root node"}),": Final operator producing the query result"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-query-optimization-issues",children:"Common Query Optimization Issues"}),"\n",(0,r.jsx)(n.p,{children:"SQL EXPLAIN output analysis can help you optimize slow query execution. You can avoid common bottlenecks in SQL execution by following these guidelines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Avoid scanning an entire table."}),"\n",(0,r.jsx)(n.li,{children:"Avoid scanning non-optimal indexes."}),"\n",(0,r.jsx)(n.li,{children:"Avoid suboptimal join ordering or join algorithm."}),"\n",(0,r.jsx)(n.li,{children:"Ensure optimal data colocation for your queries."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In the following sections, we will see some common issues with queries and ways to identify and fix them."}),"\n",(0,r.jsx)(n.h2,{id:"full-scan-instead-of-index-scan",children:"Full Scan Instead of Index Scan"}),"\n",(0,r.jsx)(n.p,{children:"Suppose related sql execution flow looks like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR);\nCREATE INDEX t_col1_idx ON t(col1);\n\nSELECT id FROM t WHERE col1 = '1';\n"})}),"\n",(0,r.jsx)(n.p,{children:"And possible EXPLAIN output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   TableScan\n       table: PUBLIC.T\n       predicate: =(COL1, _UTF-8'1')\n       fieldNames: [ID]\n       est: (rows=1)\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"For simplicity, here and below, information that is not related to the example is omitted from the EXPLAIN output."})}),"\n",(0,r.jsxs)(n.p,{children:["We can see a full scan (",(0,r.jsx)(n.em,{children:"TableScan"})," operator) with predicate. The execution planner chooses which scan implementation (",(0,r.jsx)(n.strong,{children:"TableScan"})," or ",(0,r.jsx)(n.strong,{children:"IndexScan"}),") to use. If you expect that index scan is preferable, you can use the ",(0,r.jsx)(n.code,{children:"FORCE_INDEX"})," hint to manually force ",(0,r.jsx)(n.code,{children:"IndexScan"})," approach:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX(t_col1_idx) */ id FROM t WHERE col1 = '1';\n"})}),"\n",(0,r.jsx)(n.p,{children:"Will show a different plan, like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_IDX\n       type: SORTED\n       predicate: =(COL1, _UTF-8'1')\n       searchBounds: [ExactBounds [bound=_UTF-8'1']]\n       fieldNames: [ID]\n       collation: []\n       est: (rows=1)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"suboptimal-indexes",children:"Suboptimal Indexes"}),"\n",(0,r.jsx)(n.p,{children:"Indexes with less prediction can be chosen, for example schema and query may look as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR, col2 VARCHAR);\nCREATE INDEX t_col1_col2_idx ON T(col1, col2);\nCREATE INDEX t_col1_idx ON t(col1);\n\nSELECT id FROM t WHERE col1 = '1' AND col2 = '2';\n"})}),"\n",(0,r.jsx)(n.p,{children:"and a possible plan would be:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_IDX\n       ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We can see that the execution uses the ",(0,r.jsx)(n.strong,{children:"T_COL1_IDX"})," index, through both predicates ",(0,r.jsx)(n.strong,{children:"COL1 = '1' AND COL2 = '2'"})," are involved and the ",(0,r.jsx)(n.strong,{children:"T_COL1_COL2_IDX"})," is preferable. In this case, the optimal plan would be:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_COL2_IDX\n       ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can also use the ",(0,r.jsx)(n.code,{children:"FORCE_INDEX"})," hint to achieve this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX(t_col1_col2_idx) */ id FROM t WHERE col1 = '1' AND col2 = '2';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"unexpected-sort-operation",children:"Unexpected Sort Operation"}),"\n",(0,r.jsx)(n.p,{children:"By default, sorted indexes store their entries in ascending order. You can adjust the ordering of a sorted index by including the options ASC or DESC."}),"\n",(0,r.jsx)(n.p,{children:"Let's suppose the schema and related query look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1 (id INT PRIMARY KEY, col1 VARCHAR);\nCREATE TABLE t2 (id INT PRIMARY KEY, col1 VARCHAR);\nCREATE INDEX t1_col1_desc_idx ON t1(col1 DESC);\nCREATE INDEX t2_col1_idx ON t2(col1);\n\nSELECT t1.id as t1id, t2.id as t2id FROM t1 JOIN t2 USING (col1);\n"})}),"\n",(0,r.jsx)(n.p,{children:"And the possible execution plan looks like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   MergeJoin\n         ...\n       Sort\n           collation: [COL1 ASC]\n           ...\n       IndexScan\n           index: T2_COL1_IDX\n           ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, the planner adds the ",(0,r.jsx)(n.strong,{children:"Sort"})," operation before performing the ",(0,r.jsx)(n.strong,{children:"IndexScan"}),", as the index used is sorted in descending order, while ascending order is required."]}),"\n",(0,r.jsxs)(n.p,{children:["Extra ",(0,r.jsx)(n.strong,{children:"Sort"})," operations adds performance costs, and we can avoid it by creating an index with the appropriate sort ordering:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE INDEX t1_col1_idx ON t1(col1);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And plan will no longer display the ",(0,r.jsx)(n.strong,{children:"Sort"})," operation, improving query execution speed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   MergeJoin\n         ...\n       IndexScan\n           index: T1_COL1_IDX\n           ...\n       IndexScan\n           index: T2_COL1_IDX\n           ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-impact-of-correlated-subqueries",children:"Performance Impact of Correlated Subqueries"}),"\n",(0,r.jsx)(n.p,{children:"The SQL-99 standard allows for nested subqueries at nearly all places within a query, so Ignite 3 supports nested subqueries, both correlated and not. Performance of certain complex correlated subqueries may be insufficient. Let's consider a correlated query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);\nCREATE TABLE dept(id INTEGER PRIMARY KEY, name VARCHAR);\n\nSELECT emp.name, (SELECT dept.name FROM dept WHERE emp.dept_id=dept.id)\nFROM emp\nWHERE emp.salary > 1000;\n"})}),"\n",(0,r.jsx)(n.p,{children:"We can see nested correlated subquery here, lets check the plan:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   CorrelatedNestedLoopJoin\n         ...\n       TableScan\n           table: PUBLIC.EMP\n           predicate: >(SALARY, 1000)\n           ...\n     ColocatedHashAggregate\n         ...\n         TableScan\n             table: PUBLIC.DEPT\n             predicate: =($cor1.DEPT_ID, ID)\n             ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The example above shows the slow ",(0,r.jsx)(n.strong,{children:"CorrelatedNestedLoopJoin"})," operation. Queries with this operation may cause a number of issues:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Such subqueries may become bottlenecks."}),"\n",(0,r.jsx)(n.li,{children:"Queries can cause high CPU load."}),"\n",(0,r.jsx)(n.li,{children:"Certain queries may perform slower than expected."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If performance issues are found in similar queries, it would be more efficient to rewrite the query without nested subqueries, for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT emp.name, dept.name\nFROM emp, dept\nWHERE emp.salary > 1000 AND emp.dept_id=dept.id;\n"})}),"\n",(0,r.jsx)(n.p,{children:"And new plan becomes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"     HashJoin\n         predicate: =(DEPT_ID, ID)\n         ...\n       TableScan\n           table: PUBLIC.EMP\n           predicate: >(SALARY, 1000)\n           ...\n         TableScan\n             table: PUBLIC.DEPT\n             ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Without the ",(0,r.jsx)(n.strong,{children:"CorrelatedNestedLoopJoin"})," operation, the query should perform much better than the previous one."]}),"\n",(0,r.jsx)(n.h2,{id:"excessive-sorting",children:"Excessive Sorting"}),"\n",(0,r.jsx)(n.p,{children:"Let's explain we have an index involved two columns one of them is participate in predicate and other in ordering, or in sql terms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);\nCREATE INDEX emp_salary_name_idx ON emp(salary, name);\n\nSELECT dept_id FROM emp WHERE salary = 1 ORDER BY name;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Expectations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Index need to be used here."}),"\n",(0,r.jsxs)(n.li,{children:["No additional sort is needed because index is ordered by ",(0,r.jsx)(n.strong,{children:"name"})," column is satisfies initial query ordering."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"But the real execution plan shows a different result:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"     Sort\n         collation: [NAME ASC]\n         ...\n       TableScan\n           table: PUBLIC.EMP\n           predicate: =(SALARY, 1)\n           ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We can see a redundant ",(0,r.jsx)(n.strong,{children:"Sort"})," operator. A bit query refactoring can help to avoid excessive sorting:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT dept_id FROM emp WHERE salary = 1 ORDER BY salary, name;\n"})}),"\n",(0,r.jsx)(n.p,{children:"And the plan becomes as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"     IndexScan\n         table: PUBLIC.EMP\n         index: EMP_SALARY_NAME_IDX\n         predicate: =(SALARY, 1)\n         ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"select-count-optimization",children:"Select Count Optimization"}),"\n",(0,r.jsx)(n.p,{children:"Some queries can be optimized to use more optimal plans which brings performance speed up. For example, plan for:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT COUNT(*) FROM emp;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Can look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:" SelectCount\n     table: PUBLIC.EMP\n     est: (rows=43)\n     ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"But there are numerous cases where such optimization is not applicable. In such a cases, a plan can be different and the execution may require more time."}),"\n",(0,r.jsx)(n.p,{children:"The same query as above, but with explicit transaction may produce a different plan, for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   ReduceSortAggregate\n       ...\n       MapSortAggregate\n           ...\n         TableScan\n             table: PUBLIC.EMP\n             est: (rows=43)\n             ...\n"})}),"\n",(0,r.jsx)(n.h2,{id:"index-scan-without-exact-search-bounds",children:"Index Scan Without Exact Search Bounds"}),"\n",(0,r.jsx)(n.p,{children:"Table scans are available in two implementations: direct table scan and scan through index. Index scans contain predicate and search bounds. Predicate provides final rows comparison. If search bounds are absent, the query degenerates into table scan through index scan (requiring an additional store look up), with further predicate comparison, that incurs additional performance overhead costs."}),"\n",(0,r.jsx)(n.p,{children:"Let's suppose we have schema and query like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INTEGER PRIMARY KEY, col1 DECIMAL(5, 3));\nCREATE INDEX t_col1_idx ON t(col1);\n\nSELECT id FROM t WHERE col1 = 43;\n"})}),"\n",(0,r.jsx)(n.p,{children:"And possible plan would look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_IDX\n       predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)\n       ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We can see here only ",(0,r.jsx)(n.strong,{children:"predicate"})," (and no ",(0,r.jsx)(n.strong,{children:"searchBounds"}),") which means that ",(0,r.jsx)(n.strong,{children:"all"})," rows from index will go through predicate and bring additional performance penalty."]}),"\n",(0,r.jsx)(n.p,{children:"Two type of solutions are possible here:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You can prohibit suboptimal index usage."}),"\n",(0,r.jsx)(n.li,{children:"You can explicitly help the planner with type derivation."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"prohibit-index-usage",children:"Prohibit Index Usage"}),"\n",(0,r.jsxs)(n.p,{children:["For the first approach, use the ",(0,r.jsx)(n.strong,{children:"NO_INDEX"})," hint to prohibit index usage:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ NO_INDEX */ id FROM t WHERE col1 = 43;\n\n-- or with direct index mention:\n\nSELECT /*+ NO_INDEX(t_col1_idx) */ id FROM t WHERE col1 = 43;\n"})}),"\n",(0,r.jsx)(n.p,{children:"As a result, you will have a plan similar to this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   TableScan\n       table: PUBLIC.T\n       predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)\n       ...\n"})}),"\n",(0,r.jsx)(n.h3,{id:"manual-type-casting",children:"Manual Type Casting"}),"\n",(0,r.jsx)(n.p,{children:"You can append additional cast to the same query to explicitly cast data as a specific type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT id FROM t WHERE col1 = 43::DECIMAL(5, 3);\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_IDX\n       predicate: =(COL1, 43.000)\n       searchBounds: [ExactBounds [bound=43.000:DECIMAL(5, 3)]]\n       ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We can see here both ",(0,r.jsx)(n.strong,{children:"searchBounds"})," and ",(0,r.jsx)(n.strong,{children:"predicate"})," which means that only exact lookup through index will be involved."]}),"\n",(0,r.jsx)(n.p,{children:"The same case as above but for a bit complicated query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t (id INT PRIMARY KEY, col1 INT);\nCREATE INDEX t_col1_asc_idx ON t (col1);\n\nSELECT * FROM t WHERE col1::varchar = SUBSTR(CURRENT_DATE::varchar, 4);\n"})}),"\n",(0,r.jsx)(n.p,{children:"Possible plan:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_IDX\n       predicate: =(CAST(COL1):VARCHAR CHARACTER SET "UTF-8", SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4))\n       ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["And we also can see that no ",(0,r.jsx)(n.strong,{children:"search bounds"})," are involved here."]}),"\n",(0,r.jsx)(n.p,{children:"Try to change it like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM t WHERE col1 = SUBSTR(CURRENT_DATE::varchar, 4)::int;\n"})}),"\n",(0,r.jsx)(n.p,{children:"And the possible plan will become:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'   IndexScan\n       table: PUBLIC.T\n       index: T_COL1_ASC_IDX\n       predicate: =(COL1, CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER NOT NULL)\n       searchBounds: [ExactBounds [bound=CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER]]\n       ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We can see that ",(0,r.jsx)(n.strong,{children:"searchBounds"})," are present, thus more productive execution flow is expected here."]}),"\n",(0,r.jsx)(n.h2,{id:"colocation-usage",children:"Colocation Usage"}),"\n",(0,r.jsx)(n.p,{children:"Data colocation eliminates network transfers during joins by ensuring related rows reside on the same node. The EXPLAIN output shows this through Exchange operators."}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Without Colocation"\n        direction TB\n        J1[HashJoin]\n        E1[Exchange<br/>distribution: single]\n        E2[Exchange<br/>distribution: single]\n        T1[TableScan: emp]\n        T2[TableScan: dept]\n\n        J1 --\x3e E1 --\x3e T1\n        J1 --\x3e E2 --\x3e T2\n    end\n\n    subgraph "With Colocation"\n        direction TB\n        J2[HashJoin]\n        T3[TableScan: emp]\n        T4[TableScan: dept]\n\n        J2 --\x3e T3\n        J2 --\x3e T4\n    end'}),"\n",(0,r.jsx)(n.p,{children:"Exchange operators indicate data movement between nodes. Fewer Exchange operators mean less network overhead."}),"\n",(0,r.jsx)(n.p,{children:"For example, if tables are created without colocation consideration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- by default, the table is implicitly colocated by PRIMARY KEY\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));\n\n-- implicitly colocated by PRIMARY KEY\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(name, id));\n"})}),"\n",(0,r.jsx)(n.p,{children:"And query as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT emp.name, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id AND emp.salary > 1000;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Bring plan like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"   HashJoin\n       predicate: =(DEPT_ID, ID)\n       ...\n     Exchange\n         ...\n       TableScan\n           table: PUBLIC.EMP\n           ...\n     Exchange\n         ...\n       TableScan\n           table: PUBLIC.DEPT\n           ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We can see two ",(0,r.jsx)(n.strong,{children:"Exchange"})," operators, which means that all rows are transferred into a single node and then are joined. This execution flow brings a performance cost and slows down query execution."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's try to improve it by adding explicit colocation for the ",(0,r.jsx)(n.strong,{children:"dept"})," table by the ",(0,r.jsx)(n.strong,{children:"ID"})," column:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- implicitly colocated by PRIMARY KEY\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));\n-- explicitly colocated by ID\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(name, id)) COLOCATE BY (id);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now the dependent rows from ",(0,r.jsx)(n.strong,{children:"emp"})," table are transferred into the appropriate node where ",(0,r.jsx)(n.strong,{children:"dept"})," holds the rows according to ",(0,r.jsx)(n.strong,{children:"DEPT.ID"})," distribution:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:'     HashJoin\n         predicate: =(DEPT_ID, ID)\n         ...\n       Exchange\n           distribution: table PUBLIC.DEPT in zone "Default" by [DEPT_ID]\n           ...\n         TableScan\n             table: PUBLIC.EMP\n             ...\n       TableScan\n           table: PUBLIC.DEPT\n           ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Only one ",(0,r.jsx)(n.strong,{children:"Exchange"})," operator for now, which, once again, mean only rows transferring from ",(0,r.jsx)(n.strong,{children:"emp"})," table to appropriate ",(0,r.jsx)(n.strong,{children:"dept"})," one."]}),"\n",(0,r.jsx)(n.p,{children:"And finally, both join predicate related columns are colocated:"}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The following colocation example will only work if the ",(0,r.jsx)(n.strong,{children:"emp"})," and ",(0,r.jsx)(n.strong,{children:"dept"})," tables belong to the same distribution zone."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- explicitly colocated by DEPT_ID\nCREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name)) COLOCATE BY(dept_id);\n-- explicitly colocated by ID\nCREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(id, name)) COLOCATE BY(id);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, the ",(0,r.jsx)(n.strong,{children:"emp"})," and ",(0,r.jsx)(n.strong,{children:"dept"})," tables are both colocated."]}),"\n",(0,r.jsx)(n.p,{children:"And the final plan will look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"     HashJoin\n        predicate: =(DEPT_ID, ID)\n         ...\n       TableScan\n           table: PUBLIC.EMP\n           ...\n       TableScan\n           table: PUBLIC.DEPT\n           ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["No ",(0,r.jsx)(n.strong,{children:"Exchange"})," operators are involved in the explanation, which means that no excessive rows transfer has occurred."]}),"\n",(0,r.jsx)(n.h2,{id:"additional-explain-examples",children:"Additional EXPLAIN Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-complex-join-query",children:"Example: Complex Join Query"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN PLAN FOR\n SELECT\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\n   FROM Users U, Reviews R, Products P\n  WHERE U.UserID = R.UserID\n    AND R.ProductID = P.ProductID\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,r.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Project\n    fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n    projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n    est: (rows=16650)\n  HashJoin\n      predicate: =(USERID$0, USERID)\n      fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\n      type: inner\n      est: (rows=16650)\n    HashJoin\n        predicate: =(PRODUCTID, PRODUCTID$0)\n        fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\n        type: inner\n        est: (rows=16650)\n      Exchange\n          distribution: single\n          est: (rows=50000)\n        TableScan\n            table: PUBLIC.REVIEWS\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n            est: (rows=50000)\n      Exchange\n          distribution: single\n          est: (rows=1665)\n        TableScan\n            table: PUBLIC.PRODUCTS\n            predicate: =(PRODUCTNAME, ||(_UTF-8'Product_', CAST(?0):VARCHAR CHARACTER SET \"UTF-8\"))\n            fieldNames: [PRODUCTID, PRODUCTNAME]\n            est: (rows=1665)\n    Exchange\n        distribution: single\n        est: (rows=10000)\n      TableScan\n          table: PUBLIC.USERS\n          fieldNames: [USERID, USERNAME]\n          est: (rows=10000)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This execution plan represents a query that joins three tables: ",(0,r.jsx)(n.code,{children:"USERS"}),", ",(0,r.jsx)(n.code,{children:"REVIEWS"}),", and ",(0,r.jsx)(n.code,{children:"PRODUCTS"}),", and selects four fields after filtering by product name."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Project"})," (root node): Outputs the final selected fields (USERNAME, PRODUCTNAME, REVIEWTEXT, and RATING)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HashJoins"})," (two levels): Perform the inner joins.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The first (bottom-most) joins REVIEWS with PRODUCTS on PRODUCTID."}),"\n",(0,r.jsx)(n.li,{children:"The second joins the result with USERS on USERID."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TableScans"}),": Each table is scanned:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"REVIEWS is fully scanned."}),"\n",(0,r.jsx)(n.li,{children:"PRODUCTS is scanned with a filter on PRODUCTNAME."}),"\n",(0,r.jsx)(n.li,{children:"USERS is fully scanned."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exchange"})," nodes: Indicate data redistribution between operators."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each node includes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"fieldNames"}),": Output columns at that stage."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"predicate"}),": Join or filter condition."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"est"}),": Estimated number of rows at that point in the plan."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-query-mapping",children:"Example: Query Mapping"}),"\n",(0,r.jsx)(n.p,{children:"A result of EXPLAIN MAPPING command includes additional metadata providing insight at how the query is mapped on cluster topology. So, for the command like below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN MAPPING FOR\n SELECT\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\n   FROM Users U, Reviews R, Products P\n  WHERE U.UserID = R.UserID\n    AND R.ProductID = P.ProductID\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,r.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'Fragment#0 root\n  distribution: single\n  executionNodes: [node_1]\n  tree:\n    Project\n        fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n        projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n        est: (rows=1)\n      HashJoin\n          predicate: =(USERID$0, USERID)\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\n          type: inner\n          est: (rows=1)\n        HashJoin\n            predicate: =(PRODUCTID, PRODUCTID$0)\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\n            type: inner\n            est: (rows=1)\n          Receiver\n              fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n              sourceFragmentId: 1\n              est: (rows=1)\n          Receiver\n              fieldNames: [PRODUCTID, PRODUCTNAME]\n              sourceFragmentId: 2\n              est: (rows=1)\n        Receiver\n            fieldNames: [USERID, USERNAME]\n            sourceFragmentId: 3\n            est: (rows=1)\n\nFragment#1\n  distribution: random\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [REVIEWS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=50000)\n      TableScan\n          table: PUBLIC.REVIEWS\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n          est: (rows=50000)\n\nFragment#2\n  distribution: table PUBLIC.PRODUCTS in zone "Default"\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [PRODUCTS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=1665)\n      TableScan\n          table: PUBLIC.PRODUCTS\n          predicate: =(PRODUCTNAME, ||(_UTF-8\'Product_\', CAST(?0):VARCHAR CHARACTER SET "UTF-8"))\n          fieldNames: [PRODUCTID, PRODUCTNAME]\n          est: (rows=1665)\n\nFragment#3\n  distribution: table PUBLIC.USERS in zone "Default"\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [USERS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=10000)\n      TableScan\n          table: PUBLIC.USERS\n          fieldNames: [USERID, USERNAME]\n          est: (rows=10000)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fragment#0"})," means fragment with id=0"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"root"})," marks a fragment which is considered as root fragment, i.e. a fragment which represents user's cursor"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"distribution"})," attribute provides an insight into which mapping strategy was applied to this particular fragment"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"executionNodes"})," attribute provides a list of nodes this fragment will be executed on"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"partitions"})," attribute provides an insight into which partitions of which tables will be read from which nodes"]}),"\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.strong,{children:"tree"})," attribute specifies which part of the relational tree corresponds to this fragment"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The output above shows how the query is broken into multiple execution fragments and distributed across the cluster. It gives insight into both the logical execution plan and how it maps to the physical topology."}),"\n",(0,r.jsxs)(n.p,{children:["The query starts execution in ",(0,r.jsx)(n.em,{children:"Fragment#0"}),", which serves as the root of the plan (this is where the final result is produced). It runs on a single node (",(0,r.jsx)(n.code,{children:"node_1"}),") and contains the main logic of the query, including the projection and two nested hash joins. Instead of scanning tables directly, it receives data from other fragments through ",(0,r.jsx)(n.code,{children:"Receiver"})," operators. These incoming streams correspond to the ",(0,r.jsx)(n.code,{children:"REVIEWS"}),", ",(0,r.jsx)(n.code,{children:"PRODUCTS"}),", and ",(0,r.jsx)(n.code,{children:"USERS"})," tables."]}),"\n",(0,r.jsxs)(n.p,{children:["The actual table scans happen in ",(0,r.jsx)(n.em,{children:"Fragments 1 through 3"}),", each responsible for one of the involved tables. These fragments operate in parallel across the cluster. Each performs a scan on its respective table and then sends the results back to Fragment#0."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Fragment#1"})," handles the ",(0,r.jsx)(n.code,{children:"REVIEWS"})," table. It runs on all nodes and uses a random distribution strategy. Data is partitioned across nodes, and after scanning the table, results are sent upstream."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Fragment#2"})," is in charge of the ",(0,r.jsx)(n.code,{children:"PRODUCTS"})," table. It also spans all nodes but follows a zone-based distribution linked to the table's partitioning. There's a filter applied to ",(0,r.jsx)(n.code,{children:"PRODUCTNAME"}),", which limits the amount of data sent to the root."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"Fragment#3"})," covers the ",(0,r.jsx)(n.code,{children:"USERS"})," table. Like the others, it's distributed and reads from table partitions spread across the cluster."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each fragment includes metadata such as the nodes it's executed on, how data is partitioned, and how results are sent between fragments. This layout provides a clear view of not only how the query is logically processed, but also how the workload is split and coordinated in a distributed environment."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);