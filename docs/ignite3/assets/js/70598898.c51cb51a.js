"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7076],{28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>i});var s=r(96540);const t={},o=s.createContext(t);function d(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(o.Provider,{value:n},e.children)}},38964:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"api-reference/native-clients/cpp/network-api","title":"Network API","description":"The Network API provides access to cluster topology information. It exposes cluster node metadata used for compute job targeting and cluster monitoring.","source":"@site/docs/api-reference/native-clients/cpp/network-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/network-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/network-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Network API","id":"network-api","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api"},"next":{"title":"SQL-Only APIs","permalink":"/docs/ignite3/3.1.0/api-reference/sql-only-apis/"}}');var t=r(74848),o=r(28453);const d={title:"Network API",id:"network-api",sidebar_position:6},i="Network API",c={},a=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Cluster Nodes",id:"cluster-nodes",level:3},{value:"Node Identity",id:"node-identity",level:3},{value:"Network Addresses",id:"network-addresses",level:3},{value:"Cluster Node",id:"cluster-node",level:2},{value:"Node Properties",id:"node-properties",level:3},{value:"Accessing Node Information",id:"accessing-node-information",level:3},{value:"Node Comparison",id:"node-comparison",level:3},{value:"Retrieving Cluster Nodes",id:"retrieving-cluster-nodes",level:2},{value:"Synchronous Retrieval",id:"synchronous-retrieval",level:3},{value:"Asynchronous Retrieval",id:"asynchronous-retrieval",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Node Selection for Compute",id:"node-selection-for-compute",level:3},{value:"Finding Specific Nodes",id:"finding-specific-nodes",level:3},{value:"Cluster Monitoring",id:"cluster-monitoring",level:3},{value:"Broadcasting to All Nodes",id:"broadcasting-to-all-nodes",level:3},{value:"Node Filtering",id:"node-filtering",level:3},{value:"Round-Robin Selection",id:"round-robin-selection",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:2},{value:"Node Restart Impact",id:"node-restart-impact",level:3},{value:"Topology Changes",id:"topology-changes",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Network Errors",id:"network-errors",level:3},{value:"Empty Topology",id:"empty-topology",level:3},{value:"Integration with Compute API",id:"integration-with-compute-api",level:2},{value:"Job Targeting",id:"job-targeting",level:3},{value:"Node Affinity",id:"node-affinity",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Cache Topology Information",id:"cache-topology-information",level:3},{value:"Use Stable References",id:"use-stable-references",level:3},{value:"Handle Dynamic Topology",id:"handle-dynamic-topology",level:3},{value:"Reference",id:"reference",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"network-api",children:"Network API"})}),"\n",(0,t.jsx)(n.p,{children:"The Network API provides access to cluster topology information. It exposes cluster node metadata used for compute job targeting and cluster monitoring."}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"cluster-nodes",children:"Cluster Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Cluster nodes represent individual server instances in the Ignite cluster. Each node has a unique identifier, a stable name, and network address information."}),"\n",(0,t.jsx)(n.h3,{id:"node-identity",children:"Node Identity"}),"\n",(0,t.jsx)(n.p,{children:"Nodes have two forms of identification:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node ID"})," - A UUID that changes when the node restarts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Node Name"})," - A stable string name that persists across restarts"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use node names for stable references. Use node IDs for runtime identification."}),"\n",(0,t.jsx)(n.h3,{id:"network-addresses",children:"Network Addresses"}),"\n",(0,t.jsx)(n.p,{children:"Each node exposes a network endpoint containing host and port information. Clients use these addresses to establish connections for operations."}),"\n",(0,t.jsx)(n.h2,{id:"cluster-node",children:"Cluster Node"}),"\n",(0,t.jsx)(n.h3,{id:"node-properties",children:"Node Properties"}),"\n",(0,t.jsx)(n.p,{children:"Cluster nodes provide three key properties:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"using namespace ignite;\r\n\r\nauto nodes = client.get_cluster_nodes();\r\nfor (const auto& node : nodes) {\r\n    // Unique ID (changes on restart)\r\n    uuid id = node.get_id();\r\n\r\n    // Stable name (persists across restarts)\r\n    std::string name = node.get_name();\r\n\r\n    // Network address\r\n    end_point address = node.get_address();\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"accessing-node-information",children:"Accessing Node Information"}),"\n",(0,t.jsx)(n.p,{children:"Get the node ID:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'uuid node_id = node.get_id();\r\nstd::cout << "Node ID: " << node_id << std::endl;\n'})}),"\n",(0,t.jsx)(n.p,{children:"Get the node name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::string node_name = node.get_name();\r\nstd::cout << "Node: " << node_name << std::endl;\n'})}),"\n",(0,t.jsx)(n.p,{children:"Get the network address:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'end_point addr = node.get_address();\r\nstd::cout << "Host: " << addr.host << std::endl;\r\nstd::cout << "Port: " << addr.port << std::endl;\n'})}),"\n",(0,t.jsx)(n.h3,{id:"node-comparison",children:"Node Comparison"}),"\n",(0,t.jsx)(n.p,{children:"Cluster nodes support full comparison:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'cluster_node node1 = nodes[0];\r\ncluster_node node2 = nodes[1];\r\n\r\nif (node1 == node2) {\r\n    std::cout << "Same node" << std::endl;\r\n}\r\n\r\nif (node1 < node2) {\r\n    std::cout << "node1 sorts before node2" << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Comparison enables sorting and set operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Sort nodes by name\r\nstd::sort(nodes.begin(), nodes.end(),\r\n    [](const auto& n1, const auto& n2) {\r\n        return n1.get_name() < n2.get_name();\r\n    });\r\n\r\n// Create a set of nodes\r\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\n"})}),"\n",(0,t.jsx)(n.h2,{id:"retrieving-cluster-nodes",children:"Retrieving Cluster Nodes"}),"\n",(0,t.jsx)(n.h3,{id:"synchronous-retrieval",children:"Synchronous Retrieval"}),"\n",(0,t.jsx)(n.p,{children:"Get all cluster nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\n\r\nstd::cout << "Cluster has " << nodes.size() << " nodes" << std::endl;\r\n\r\nfor (const auto& node : nodes) {\r\n    std::cout << node.get_name() << " at "\r\n              << node.get_address().host << ":"\r\n              << node.get_address().port << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-retrieval",children:"Asynchronous Retrieval"}),"\n",(0,t.jsx)(n.p,{children:"Get nodes without blocking:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'client.get_cluster_nodes_async([](ignite_result<std::vector<cluster_node>> result) {\r\n    if (!result.has_error()) {\r\n        auto nodes = std::move(result).value();\r\n        std::cout << "Found " << nodes.size() << " nodes" << std::endl;\r\n    } else {\r\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\r\n    }\r\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsx)(n.h3,{id:"node-selection-for-compute",children:"Node Selection for Compute"}),"\n",(0,t.jsx)(n.p,{children:"Select specific nodes for job execution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\n\r\n// Execute on first node\r\nif (!nodes.empty()) {\r\n    auto target = job_target::node(nodes[0]);\r\n    auto execution = client.get_compute().submit(target, descriptor, arg);\r\n}\r\n\r\n// Execute on any node\r\nauto target = job_target::any_node(nodes);\r\nauto execution = client.get_compute().submit(target, descriptor, arg);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"finding-specific-nodes",children:"Finding Specific Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Locate nodes by name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\n\r\nauto it = std::find_if(nodes.begin(), nodes.end(),\r\n    [](const auto& node) {\r\n        return node.get_name() == "my-node-01";\r\n    });\r\n\r\nif (it != nodes.end()) {\r\n    cluster_node target_node = *it;\r\n    // Use node\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"cluster-monitoring",children:"Cluster Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"Monitor cluster size:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\nsize_t cluster_size = nodes.size();\r\n\r\nif (cluster_size < 3) {\r\n    std::cerr << "Warning: Cluster has only " << cluster_size << " nodes" << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Track node addresses:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::map<std::string, end_point> node_map;\r\n\r\nfor (const auto& node : nodes) {\r\n    node_map[node.get_name()] = node.get_address();\r\n}\r\n\r\n// Check if specific node is available\r\nif (node_map.find("my-node-01") != node_map.end()) {\r\n    std::cout << "Node my-node-01 is online" << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"broadcasting-to-all-nodes",children:"Broadcasting to All Nodes"}),"\n",(0,t.jsx)(n.p,{children:"Execute jobs on all cluster nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\r\n\r\nauto target = broadcast_job_target::nodes(node_set);\r\nauto broadcast = client.get_compute().submit_broadcast(target, descriptor, arg);\r\n\r\nauto executions = broadcast.get_job_executions();\r\nstd::cout << "Broadcast to " << executions.size() << " nodes" << std::endl;\n'})}),"\n",(0,t.jsx)(n.h3,{id:"node-filtering",children:"Node Filtering"}),"\n",(0,t.jsx)(n.p,{children:"Filter nodes by criteria:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\n\r\n// Get nodes on specific host\r\nstd::vector<cluster_node> local_nodes;\r\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(local_nodes),\r\n    [](const auto& node) {\r\n        return node.get_address().host == "192.168.1.100";\r\n    });\r\n\r\n// Get nodes in port range\r\nstd::vector<cluster_node> dev_nodes;\r\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(dev_nodes),\r\n    [](const auto& node) {\r\n        return node.get_address().port >= 10800 && node.get_address().port < 10900;\r\n    });\n'})}),"\n",(0,t.jsx)(n.h3,{id:"round-robin-selection",children:"Round-Robin Selection"}),"\n",(0,t.jsx)(n.p,{children:"Distribute work across nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\nsize_t current_index = 0;\r\n\r\nfor (const auto& task : tasks) {\r\n    auto target = job_target::node(nodes[current_index]);\r\n    compute.submit(target, descriptor, task);\r\n\r\n    current_index = (current_index + 1) % nodes.size();\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,t.jsx)(n.h3,{id:"node-restart-impact",children:"Node Restart Impact"}),"\n",(0,t.jsx)(n.p,{children:"When a node restarts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Node ID changes to a new UUID"}),"\n",(0,t.jsx)(n.li,{children:"Node name remains the same"}),"\n",(0,t.jsx)(n.li,{children:"Network address typically remains the same"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Use node names for stable node references across restarts."}),"\n",(0,t.jsx)(n.h3,{id:"topology-changes",children:"Topology Changes"}),"\n",(0,t.jsx)(n.p,{children:"The cluster topology may change between calls:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Initial topology\r\nauto nodes1 = client.get_cluster_nodes();\r\nsize_t size1 = nodes1.size();\r\n\r\n// Topology may change\r\nstd::this_thread::sleep_for(std::chrono::seconds(10));\r\n\r\n// Updated topology\r\nauto nodes2 = client.get_cluster_nodes();\r\nsize_t size2 = nodes2.size();\r\n\r\nif (size2 != size1) {\r\n    std::cout << "Topology changed: "\r\n              << size1 << " -> " << size2 << " nodes" << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Always retrieve fresh topology information before node-specific operations."}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"network-errors",children:"Network Errors"}),"\n",(0,t.jsx)(n.p,{children:"Handle connection failures:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'try {\r\n    auto nodes = client.get_cluster_nodes();\r\n} catch (const ignite_error& e) {\r\n    std::cerr << "Failed to get cluster nodes: " << e.what_str() << std::endl;\r\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"With async operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'client.get_cluster_nodes_async([](ignite_result<std::vector<cluster_node>> result) {\r\n    if (result.has_error()) {\r\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\r\n    } else {\r\n        auto nodes = std::move(result).value();\r\n        // Use nodes\r\n    }\r\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"empty-topology",children:"Empty Topology"}),"\n",(0,t.jsx)(n.p,{children:"Check for empty clusters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\n\r\nif (nodes.empty()) {\r\n    std::cerr << "Warning: No nodes available in cluster" << std::endl;\r\n} else {\r\n    // Proceed with operations\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-compute-api",children:"Integration with Compute API"}),"\n",(0,t.jsx)(n.h3,{id:"job-targeting",children:"Job Targeting"}),"\n",(0,t.jsx)(n.p,{children:"Use topology information for compute targeting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\r\n\r\n// Target specific node\r\nauto target = job_target::node(nodes[0]);\r\n\r\n// Target any node from set\r\nauto target = job_target::any_node(nodes);\r\n\r\n// Broadcast to all nodes\r\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\r\nauto broadcast_target = broadcast_job_target::nodes(node_set);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"node-affinity",children:"Node Affinity"}),"\n",(0,t.jsx)(n.p,{children:"Select nodes based on affinity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\r\n\r\n// Find preferred nodes (example: local datacenter)\r\nstd::vector<cluster_node> preferred_nodes;\r\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(preferred_nodes),\r\n    [](const auto& node) {\r\n        return node.get_address().host.find("dc1") != std::string::npos;\r\n    });\r\n\r\n// Use preferred nodes for execution\r\nif (!preferred_nodes.empty()) {\r\n    auto target = job_target::any_node(preferred_nodes);\r\n    compute.submit(target, descriptor, arg);\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"cache-topology-information",children:"Cache Topology Information"}),"\n",(0,t.jsx)(n.p,{children:"Cache node information for short-lived operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class compute_scheduler {\r\n    std::vector<cluster_node> nodes_;\r\n    std::chrono::steady_clock::time_point last_refresh_;\r\n    std::chrono::seconds refresh_interval_{30};\r\n\r\npublic:\r\n    void maybe_refresh_topology(ignite_client& client) {\r\n        auto now = std::chrono::steady_clock::now();\r\n        if (now - last_refresh_ > refresh_interval_) {\r\n            nodes_ = client.get_cluster_nodes();\r\n            last_refresh_ = now;\r\n        }\r\n    }\r\n\r\n    std::vector<cluster_node> get_nodes() const {\r\n        return nodes_;\r\n    }\r\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"use-stable-references",children:"Use Stable References"}),"\n",(0,t.jsx)(n.p,{children:"Prefer node names over IDs for persistent references:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'// Good: Use node name\r\nstd::string target_node_name = "my-node-01";\r\nauto nodes = client.get_cluster_nodes();\r\nauto it = std::find_if(nodes.begin(), nodes.end(),\r\n    [&](const auto& n) { return n.get_name() == target_node_name; });\r\n\r\n// Avoid: Using node ID (changes on restart)\r\nuuid target_node_id = saved_id;  // May be stale after restart\n'})}),"\n",(0,t.jsx)(n.h3,{id:"handle-dynamic-topology",children:"Handle Dynamic Topology"}),"\n",(0,t.jsx)(n.p,{children:"Account for nodes joining and leaving:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'void execute_with_fallback(ignite_client& client,\r\n                           std::shared_ptr<job_descriptor> descriptor,\r\n                           const binary_object& arg) {\r\n    auto nodes = client.get_cluster_nodes();\r\n\r\n    if (nodes.empty()) {\r\n        throw ignite_error("No nodes available");\r\n    }\r\n\r\n    // Try first node\r\n    try {\r\n        auto target = job_target::node(nodes[0]);\r\n        compute.submit(target, descriptor, arg);\r\n    } catch (const ignite_error& e) {\r\n        // Fallback to any available node\r\n        auto target = job_target::any_node(nodes);\r\n        compute.submit(target, descriptor, arg);\r\n    }\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"./compute-api",children:"Compute API"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);