"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7505],{28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var t=r(96540);const l={},a=t.createContext(l);function i(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),t.createElement(a.Provider,{value:n},e.children)}},57080:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"api-reference/native-clients/cpp/tables-api","title":"Tables API","description":"The Tables API provides CRUD operations on table data. It supports both binary tuple operations and typed C++ object operations through record views and key-value views.","source":"@site/docs/api-reference/native-clients/cpp/tables-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/tables-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/tables-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Tables API","id":"tables-api","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Client API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/client-api"},"next":{"title":"SQL API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/sql-api"}}');var l=r(74848),a=r(28453);const i={title:"Tables API",id:"tables-api",sidebar_position:2},s="Tables API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Table Access",id:"table-access",level:3},{value:"View Types",id:"view-types",level:3},{value:"Binary vs Typed Operations",id:"binary-vs-typed-operations",level:3},{value:"Transaction Support",id:"transaction-support",level:3},{value:"Getting Tables",id:"getting-tables",level:2},{value:"Retrieve a Single Table",id:"retrieve-a-single-table",level:3},{value:"List All Tables",id:"list-all-tables",level:3},{value:"Record Views",id:"record-views",level:2},{value:"Binary Record View",id:"binary-record-view",level:3},{value:"Typed Record View",id:"typed-record-view",level:3},{value:"Record View Operations",id:"record-view-operations",level:3},{value:"Key-Value Views",id:"key-value-views",level:2},{value:"Binary Key-Value View",id:"binary-key-value-view",level:3},{value:"Typed Key-Value View",id:"typed-key-value-view",level:3},{value:"Key-Value View Operations",id:"key-value-view-operations",level:3},{value:"Ignite Tuple",id:"ignite-tuple",level:2},{value:"Creating Tuples",id:"creating-tuples",level:3},{value:"Accessing Values",id:"accessing-values",level:3},{value:"Column Metadata",id:"column-metadata",level:3},{value:"Column Names",id:"column-names",level:3},{value:"Asynchronous Operations",id:"asynchronous-operations",level:2},{value:"Transaction Integration",id:"transaction-integration",level:2},{value:"Reference",id:"reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"tables-api",children:"Tables API"})}),"\n",(0,l.jsx)(n.p,{children:"The Tables API provides CRUD operations on table data. It supports both binary tuple operations and typed C++ object operations through record views and key-value views."}),"\n",(0,l.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,l.jsx)(n.h3,{id:"table-access",children:"Table Access"}),"\n",(0,l.jsxs)(n.p,{children:["Tables are accessed through the ",(0,l.jsx)(n.code,{children:"tables"})," interface obtained from the client. Each table provides multiple view types for different access patterns."]}),"\n",(0,l.jsx)(n.h3,{id:"view-types",children:"View Types"}),"\n",(0,l.jsx)(n.p,{children:"Apache Ignite provides two view categories:"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Record Views"})," operate on complete row data. A single tuple or object contains all columns including the primary key. Use record views when working with complete records."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Key-Value Views"})," separate primary key columns from value columns. Operations use distinct key and value tuples or objects. Use key-value views when the domain model separates keys from data."]}),"\n",(0,l.jsx)(n.h3,{id:"binary-vs-typed-operations",children:"Binary vs Typed Operations"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Binary Views"})," use ",(0,l.jsx)(n.code,{children:"ignite_tuple"})," for dynamic column access without schema knowledge. Column values are accessed by name or index at runtime."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Typed Views"})," use C++ structs or classes with compile-time type safety. Type conversion happens through ",(0,l.jsx)(n.code,{children:"convert_to_tuple"})," and ",(0,l.jsx)(n.code,{children:"convert_from_tuple"})," template specializations."]}),"\n",(0,l.jsx)(n.h3,{id:"transaction-support",children:"Transaction Support"}),"\n",(0,l.jsxs)(n.p,{children:["All view operations accept an optional ",(0,l.jsx)(n.code,{children:"transaction*"})," parameter. Pass ",(0,l.jsx)(n.code,{children:"nullptr"})," for implicit transactions. Pass a transaction object for explicit transaction control."]}),"\n",(0,l.jsx)(n.h2,{id:"getting-tables",children:"Getting Tables"}),"\n",(0,l.jsx)(n.h3,{id:"retrieve-a-single-table",children:"Retrieve a Single Table"}),"\n",(0,l.jsx)(n.p,{children:"Get a table by name:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'using namespace ignite;\r\n\r\nauto tables = client.get_tables();\r\nauto table = tables.get_table("my_table");\r\n\r\nif (table.has_value()) {\r\n    // Use table\r\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"Get a table with qualified name:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("my_schema.my_table");\n'})}),"\n",(0,l.jsx)(n.p,{children:"Use async retrieval:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'tables.get_table_async("my_table", [](ignite_result<std::optional<table>> result) {\r\n    if (!result.has_error()) {\r\n        auto table = std::move(result).value();\r\n        if (table.has_value()) {\r\n            // Use table\r\n        }\r\n    }\r\n});\n'})}),"\n",(0,l.jsx)(n.h3,{id:"list-all-tables",children:"List All Tables"}),"\n",(0,l.jsx)(n.p,{children:"Retrieve all tables:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"auto all_tables = tables.get_tables();\r\nfor (const auto& table : all_tables) {\r\n    std::cout << table.get_name() << std::endl;\r\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Use async retrieval:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"tables.get_tables_async([](ignite_result<std::vector<table>> result) {\r\n    if (!result.has_error()) {\r\n        auto all_tables = std::move(result).value();\r\n        // Process tables\r\n    }\r\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"record-views",children:"Record Views"}),"\n",(0,l.jsx)(n.h3,{id:"binary-record-view",children:"Binary Record View"}),"\n",(0,l.jsx)(n.p,{children:"Work with tuples directly:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("accounts").value();\r\nauto view = table.get_record_binary_view();\r\n\r\n// Insert a record\r\nignite_tuple record{\r\n    {"id", 42},\r\n    {"name", "John Doe"},\r\n    {"balance", 1000.0}\r\n};\r\n\r\nview.upsert(nullptr, record);\r\n\r\n// Retrieve a record\r\nignite_tuple key{{"id", 42}};\r\nauto result = view.get(nullptr, key);\r\n\r\nif (result.has_value()) {\r\n    auto balance = result->get<double>("balance");\r\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"typed-record-view",children:"Typed Record View"}),"\n",(0,l.jsx)(n.p,{children:"Work with C++ types:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'struct account {\r\n    int64_t id;\r\n    std::string name;\r\n    double balance;\r\n};\r\n\r\n// Define type conversion (typically in a header)\r\nnamespace ignite {\r\n    template<>\r\n    struct convert_to_tuple<account> {\r\n        static ignite_tuple to_tuple(const account& obj) {\r\n            return ignite_tuple{\r\n                {"id", obj.id},\r\n                {"name", obj.name},\r\n                {"balance", obj.balance}\r\n            };\r\n        }\r\n    };\r\n\r\n    template<>\r\n    struct convert_from_tuple<account> {\r\n        static account from_tuple(const ignite_tuple& tuple) {\r\n            return account{\r\n                tuple.get<int64_t>("id"),\r\n                tuple.get<std::string>("name"),\r\n                tuple.get<double>("balance")\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\n// Use typed view\r\nauto table = tables.get_table("accounts").value();\r\nauto view = table.get_record_view<account>();\r\n\r\naccount new_account{42, "John Doe", 1000.0};\r\nview.upsert(nullptr, new_account);\r\n\r\naccount key{42};\r\nauto result = view.get(nullptr, key);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"record-view-operations",children:"Record View Operations"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Basic Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"// Insert (fails if exists)\r\nbool inserted = view.insert(nullptr, record);\r\n\r\n// Upsert (insert or replace)\r\nview.upsert(nullptr, record);\r\n\r\n// Replace (fails if not exists)\r\nbool replaced = view.replace(nullptr, record);\r\n\r\n// Replace with old value check\r\nbool replaced = view.replace(nullptr, old_record, new_record);\r\n\r\n// Get and replace atomically\r\nauto old_record = view.get_and_replace(nullptr, new_record);\r\n\r\n// Get and upsert atomically\r\nauto old_record = view.get_and_upsert(nullptr, record);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Delete Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"// Remove by key\r\nbool removed = view.remove(nullptr, key);\r\n\r\n// Remove exact match\r\nbool removed = view.remove_exact(nullptr, full_record);\r\n\r\n// Remove and return old value\r\nauto old_record = view.get_and_remove(nullptr, key);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Batch Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"std::vector<ignite_tuple> records = {record1, record2, record3};\r\n\r\n// Get multiple records\r\nauto results = view.get_all(nullptr, keys);\r\n\r\n// Insert multiple (returns skipped records)\r\nauto skipped = view.insert_all(nullptr, records);\r\n\r\n// Upsert multiple\r\nview.upsert_all(nullptr, records);\r\n\r\n// Remove multiple (returns non-existent keys)\r\nauto non_existent = view.remove_all(nullptr, keys);\r\n\r\n// Remove exact multiple\r\nauto not_matched = view.remove_all_exact(nullptr, records);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"key-value-views",children:"Key-Value Views"}),"\n",(0,l.jsx)(n.h3,{id:"binary-key-value-view",children:"Binary Key-Value View"}),"\n",(0,l.jsx)(n.p,{children:"Separate keys from values:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'auto table = tables.get_table("accounts").value();\r\nauto view = table.get_key_value_binary_view();\r\n\r\n// Put a key-value pair\r\nignite_tuple key{{"id", 42}};\r\nignite_tuple value{\r\n    {"name", "John Doe"},\r\n    {"balance", 1000.0}\r\n};\r\n\r\nview.put(nullptr, key, value);\r\n\r\n// Get value by key\r\nauto result = view.get(nullptr, key);\r\n\r\n// Check key existence\r\nbool exists = view.contains(nullptr, key);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"typed-key-value-view",children:"Typed Key-Value View"}),"\n",(0,l.jsx)(n.p,{children:"Use separate C++ types for keys and values:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'struct account_key {\r\n    int64_t id;\r\n};\r\n\r\nstruct account_data {\r\n    std::string name;\r\n    double balance;\r\n};\r\n\r\n// Define conversions for both types\r\n// (Similar to record view example)\r\n\r\nauto table = tables.get_table("accounts").value();\r\nauto view = table.get_key_value_view<account_key, account_data>();\r\n\r\naccount_key key{42};\r\naccount_data data{"John Doe", 1000.0};\r\n\r\nview.put(nullptr, key, data);\r\nauto result = view.get(nullptr, key);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"key-value-view-operations",children:"Key-Value View Operations"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Basic Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"// Put (insert or replace)\r\nview.put(nullptr, key, value);\r\n\r\n// Put if absent\r\nbool inserted = view.put_if_absent(nullptr, key, value);\r\n\r\n// Get and put atomically\r\nauto old_value = view.get_and_put(nullptr, key, value);\r\n\r\n// Replace\r\nbool replaced = view.replace(nullptr, key, value);\r\n\r\n// Replace with old value check\r\nbool replaced = view.replace(nullptr, key, old_value, new_value);\r\n\r\n// Get and replace atomically\r\nauto old_value = view.get_and_replace(nullptr, key, value);\r\n\r\n// Check existence\r\nbool exists = view.contains(nullptr, key);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Delete Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"// Remove by key\r\nbool removed = view.remove(nullptr, key);\r\n\r\n// Remove with value check\r\nbool removed = view.remove(nullptr, key, expected_value);\r\n\r\n// Remove and return value\r\nauto old_value = view.get_and_remove(nullptr, key);\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Batch Operations:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"std::vector<std::pair<K, V>> pairs = {{key1, val1}, {key2, val2}};\r\n\r\n// Get multiple values\r\nauto values = view.get_all(nullptr, keys);\r\n\r\n// Put multiple pairs\r\nview.put_all(nullptr, pairs);\r\n\r\n// Remove multiple keys\r\nauto non_existent = view.remove_all(nullptr, keys);\r\n\r\n// Remove multiple pairs with value checks\r\nauto not_matched = view.remove_all(nullptr, pairs);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"ignite-tuple",children:"Ignite Tuple"}),"\n",(0,l.jsx)(n.h3,{id:"creating-tuples",children:"Creating Tuples"}),"\n",(0,l.jsx)(n.p,{children:"Use initializer lists:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple tuple{\r\n    {"id", 42},\r\n    {"name", "John"},\r\n    {"active", true}\r\n};\n'})}),"\n",(0,l.jsx)(n.p,{children:"Construct with capacity hint:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple tuple(10); // Reserve space for 10 columns\r\ntuple.set("id", 42);\r\ntuple.set("name", "John");\n'})}),"\n",(0,l.jsx)(n.h3,{id:"accessing-values",children:"Accessing Values"}),"\n",(0,l.jsx)(n.p,{children:"Access by name:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'auto id = tuple.get<int64_t>("id");\r\nauto name = tuple.get<std::string>("name");\r\n\r\n// Or use primitive wrapper\r\nauto value = tuple.get("id"); // Returns primitive\n'})}),"\n",(0,l.jsx)(n.p,{children:"Access by index:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"auto id = tuple.get<int64_t>(0);\r\nauto name = tuple.get<std::string>(1);\n"})}),"\n",(0,l.jsx)(n.h3,{id:"column-metadata",children:"Column Metadata"}),"\n",(0,l.jsx)(n.p,{children:"Query column information:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'int32_t count = tuple.column_count();\r\nstd::string name = tuple.column_name(0);\r\nint32_t index = tuple.column_ordinal("id");\n'})}),"\n",(0,l.jsx)(n.h3,{id:"column-names",children:"Column Names"}),"\n",(0,l.jsx)(n.p,{children:"Column names are case-insensitive and normalized to uppercase unless quoted:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:'tuple.set("ID", 42);\r\ntuple.set("id", 42);  // Same as above\r\ntuple.set("Id", 42);  // Same as above\r\n\r\n// Use quotes for case-sensitive names\r\ntuple.set("\\"Id\\"", 42);  // Different from above\n'})}),"\n",(0,l.jsx)(n.h2,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,l.jsxs)(n.p,{children:["All operations have async variants with ",(0,l.jsx)(n.code,{children:"_async"})," suffix:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"view.get_async(nullptr, key, [](ignite_result<std::optional<ignite_tuple>> result) {\r\n    if (!result.has_error()) {\r\n        auto tuple = std::move(result).value();\r\n        if (tuple.has_value()) {\r\n            // Use tuple\r\n        }\r\n    }\r\n});\r\n\r\nview.upsert_async(nullptr, record, [](ignite_result<void> result) {\r\n    if (!result.has_error()) {\r\n        // Operation succeeded\r\n    }\r\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"transaction-integration",children:"Transaction Integration"}),"\n",(0,l.jsx)(n.p,{children:"Use explicit transactions:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"auto tx = client.get_transactions().begin();\r\n\r\ntry {\r\n    view.upsert(&tx, record1);\r\n    view.upsert(&tx, record2);\r\n    tx.commit();\r\n} catch (const ignite_error& e) {\r\n    tx.rollback();\r\n    throw;\r\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/3.1.0/cppdoc/",children:"C++ API Documentation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"./sql-api",children:"SQL API"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"./transactions-api",children:"Transactions API"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);