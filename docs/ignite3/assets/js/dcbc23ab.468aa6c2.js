"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[797],{28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>c});var i=t(96540);const r={},o=i.createContext(r);function s(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(o.Provider,{value:e},n.children)}},58922:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"api-reference/native-clients/dotnet/network-api","title":"Network API","description":"The Network API provides information about cluster topology and active client connections. Use this API to discover cluster nodes, inspect connection status, and understand cluster composition.","source":"@site/docs/api-reference/native-clients/dotnet/network-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/network-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/network-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Network API","id":"network-api","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/compute-api"},"next":{"title":"C++ API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/"}}');var r=t(74848),o=t(28453);const s={title:"Network API",id:"network-api",sidebar_position:7},c="Network API",l={},a=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Node Identity",id:"node-identity",level:3},{value:"Connection Management",id:"connection-management",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Getting Cluster Nodes",id:"getting-cluster-nodes",level:3},{value:"Inspecting Active Connections",id:"inspecting-active-connections",level:3},{value:"Finding Specific Nodes",id:"finding-specific-nodes",level:3},{value:"Monitoring Connection Health",id:"monitoring-connection-health",level:3},{value:"Using Node Information for Job Targeting",id:"using-node-information-for-job-targeting",level:3},{value:"Connection Status Check",id:"connection-status-check",level:3},{value:"SSL Connection Information",id:"ssl-connection-information",level:3},{value:"Cluster Size Monitoring",id:"cluster-size-monitoring",level:3},{value:"Node Address Parsing",id:"node-address-parsing",level:3},{value:"Reference",id:"reference",level:2},{value:"IClusterNode Interface",id:"iclusternode-interface",level:3},{value:"IConnectionInfo Interface",id:"iconnectioninfo-interface",level:3},{value:"ISslInfo Interface",id:"isslinfo-interface",level:3},{value:"IIgniteClient Methods",id:"iigniteclient-methods",level:3},{value:"Best Practices",id:"best-practices",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"network-api",children:"Network API"})}),"\n",(0,r.jsx)(e.p,{children:"The Network API provides information about cluster topology and active client connections. Use this API to discover cluster nodes, inspect connection status, and understand cluster composition."}),"\n",(0,r.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(e.p,{children:"Cluster nodes represent individual server instances in the Ignite cluster. Each node has a unique identifier and network address. The client maintains connections to cluster nodes and distributes operations across them."}),"\n",(0,r.jsx)(e.h3,{id:"node-identity",children:"Node Identity"}),"\n",(0,r.jsx)(e.p,{children:"Nodes have two identifiers. The node ID changes after restart and uniquely identifies the current node instance. The node name (consistent ID) persists across restarts and identifies the node permanently."}),"\n",(0,r.jsx)(e.h3,{id:"connection-management",children:"Connection Management"}),"\n",(0,r.jsx)(e.p,{children:"The client automatically manages connections to cluster nodes. Query active connections to understand which nodes the client is currently connected to and inspect connection properties like SSL configuration."}),"\n",(0,r.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(e.h3,{id:"getting-cluster-nodes",children:"Getting Cluster Nodes"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var client = await IgniteClient.StartAsync(configuration);\r\n\r\n// Get all cluster nodes\r\nvar nodes = await client.GetClusterNodesAsync();\r\n\r\nforeach (var node in nodes)\r\n{\r\n    Console.WriteLine($"Node: {node.Name}");\r\n    Console.WriteLine($"  ID: {node.Id}");\r\n    Console.WriteLine($"  Address: {node.Address}");\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"inspecting-active-connections",children:"Inspecting Active Connections"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var connections = client.GetConnections();\r\n\r\nConsole.WriteLine($"Active connections: {connections.Count}");\r\n\r\nforeach (var conn in connections)\r\n{\r\n    Console.WriteLine($"Connected to: {conn.Node.Name}");\r\n    Console.WriteLine($"  Node ID: {conn.Node.Id}");\r\n    Console.WriteLine($"  Address: {conn.Node.Address}");\r\n\r\n    if (conn.SslInfo != null)\r\n    {\r\n        Console.WriteLine($"  SSL: Enabled");\r\n        Console.WriteLine($"  Protocol: {conn.SslInfo.SslProtocol}");\r\n        Console.WriteLine($"  Cipher: {conn.SslInfo.NegotiatedCipherSuiteName}");\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"finding-specific-nodes",children:"Finding Specific Nodes"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\r\n\r\n// Find by name\r\nvar targetNode = nodes.FirstOrDefault(n => n.Name == "node-01");\r\nif (targetNode != null)\r\n{\r\n    Console.WriteLine($"Found node: {targetNode.Name} at {targetNode.Address}");\r\n}\r\n\r\n// Find by ID\r\nvar nodeId = Guid.Parse("550e8400-e29b-41d4-a716-446655440000");\r\nvar nodeById = nodes.FirstOrDefault(n => n.Id == nodeId);\n'})}),"\n",(0,r.jsx)(e.h3,{id:"monitoring-connection-health",children:"Monitoring Connection Health"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var checkInterval = TimeSpan.FromSeconds(30);\r\n\r\nwhile (true)\r\n{\r\n    var connections = client.GetConnections();\r\n\r\n    if (connections.Count == 0)\r\n    {\r\n        Console.WriteLine("WARNING: No active connections!");\r\n    }\r\n    else\r\n    {\r\n        Console.WriteLine($"Connected to {connections.Count} nodes:");\r\n        foreach (var conn in connections)\r\n        {\r\n            Console.WriteLine($"  - {conn.Node.Name}");\r\n        }\r\n    }\r\n\r\n    await Task.Delay(checkInterval);\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"using-node-information-for-job-targeting",children:"Using Node Information for Job Targeting"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\r\nvar compute = client.Compute;\r\n\r\n// Target specific node by name\r\nvar targetNode = nodes.FirstOrDefault(n => n.Name.StartsWith("compute"));\r\nif (targetNode != null)\r\n{\r\n    var jobTarget = JobTarget.Node(targetNode);\r\n    var execution = await compute.SubmitAsync(\r\n        jobTarget, jobDescriptor, "input");\r\n    var result = await execution.GetResultAsync();\r\n}\r\n\r\n// Target node by index (round-robin)\r\nvar nodeIndex = DateTime.UtcNow.Ticks % nodes.Count;\r\nvar selectedNode = nodes[(int)nodeIndex];\n'})}),"\n",(0,r.jsx)(e.h3,{id:"connection-status-check",children:"Connection Status Check"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:"public async Task<bool> IsConnectedToCluster(IIgniteClient client)\r\n{\r\n    try\r\n    {\r\n        var connections = client.GetConnections();\r\n        var nodes = await client.GetClusterNodesAsync();\r\n\r\n        return connections.Count > 0 && nodes.Count > 0;\r\n    }\r\n    catch (Exception)\r\n    {\r\n        return false;\r\n    }\r\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"ssl-connection-information",children:"SSL Connection Information"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var connections = client.GetConnections();\r\n\r\nforeach (var conn in connections)\r\n{\r\n    if (conn.SslInfo != null)\r\n    {\r\n        Console.WriteLine($"Node: {conn.Node.Name}");\r\n        Console.WriteLine($"  SSL Protocol: {conn.SslInfo.SslProtocol}");\r\n        Console.WriteLine($"  Cipher Suite: {conn.SslInfo.NegotiatedCipherSuiteName}");\r\n        Console.WriteLine($"  Target Host: {conn.SslInfo.TargetHostName}");\r\n        Console.WriteLine($"  Mutually Authenticated: {conn.SslInfo.IsMutuallyAuthenticated}");\r\n\r\n        var localCert = conn.SslInfo.LocalCertificate;\r\n        var remoteCert = conn.SslInfo.RemoteCertificate;\r\n\r\n        if (localCert != null)\r\n        {\r\n            Console.WriteLine($"  Local Certificate: {localCert.Subject}");\r\n        }\r\n\r\n        if (remoteCert != null)\r\n        {\r\n            Console.WriteLine($"  Remote Certificate: {remoteCert.Subject}");\r\n            Console.WriteLine($"  Valid Until: {remoteCert.GetExpirationDateString()}");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Console.WriteLine($"Node: {conn.Node.Name} (unencrypted)");\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"cluster-size-monitoring",children:"Cluster Size Monitoring"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'public class ClusterMonitor\r\n{\r\n    private readonly IIgniteClient _client;\r\n    private int _lastKnownSize;\r\n\r\n    public ClusterMonitor(IIgniteClient client)\r\n    {\r\n        _client = client;\r\n    }\r\n\r\n    public async Task MonitorAsync(CancellationToken cancellationToken)\r\n    {\r\n        while (!cancellationToken.IsCancellationRequested)\r\n        {\r\n            var nodes = await _client.GetClusterNodesAsync();\r\n            var currentSize = nodes.Count;\r\n\r\n            if (currentSize != _lastKnownSize)\r\n            {\r\n                if (_lastKnownSize > 0)\r\n                {\r\n                    if (currentSize > _lastKnownSize)\r\n                    {\r\n                        Console.WriteLine($"Cluster grew: {_lastKnownSize} -> {currentSize} nodes");\r\n                    }\r\n                    else\r\n                    {\r\n                        Console.WriteLine($"Cluster shrunk: {_lastKnownSize} -> {currentSize} nodes");\r\n                    }\r\n                }\r\n\r\n                _lastKnownSize = currentSize;\r\n            }\r\n\r\n            await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken);\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"node-address-parsing",children:"Node Address Parsing"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\r\n\r\nforeach (var node in nodes)\r\n{\r\n    var address = node.Address;\r\n\r\n    if (address is IPEndPoint ipEndPoint)\r\n    {\r\n        Console.WriteLine($"Node: {node.Name}");\r\n        Console.WriteLine($"  IP: {ipEndPoint.Address}");\r\n        Console.WriteLine($"  Port: {ipEndPoint.Port}");\r\n    }\r\n    else if (address is DnsEndPoint dnsEndPoint)\r\n    {\r\n        Console.WriteLine($"Node: {node.Name}");\r\n        Console.WriteLine($"  Host: {dnsEndPoint.Host}");\r\n        Console.WriteLine($"  Port: {dnsEndPoint.Port}");\r\n    }\r\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,r.jsx)(e.h3,{id:"iclusternode-interface",children:"IClusterNode Interface"}),"\n",(0,r.jsx)(e.p,{children:"Properties:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Id"})," - Unique node identifier (Guid) that changes after node restart"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Name"})," - Consistent node name that persists across restarts"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Address"})," - Network endpoint (IPEndPoint or DnsEndPoint)"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The node ID is unique to the current node instance and changes when the node restarts. The node name remains consistent across restarts and serves as a stable identifier for the node."}),"\n",(0,r.jsx)(e.h3,{id:"iconnectioninfo-interface",children:"IConnectionInfo Interface"}),"\n",(0,r.jsx)(e.p,{children:"Properties:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Node"})," - The cluster node this connection targets"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"SslInfo"})," - SSL connection details (null if SSL not enabled)"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Connection info describes an active client connection to a cluster node. The client may maintain multiple connections to different nodes simultaneously."}),"\n",(0,r.jsx)(e.h3,{id:"isslinfo-interface",children:"ISslInfo Interface"}),"\n",(0,r.jsx)(e.p,{children:"Properties:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"SslProtocol"})," - SSL/TLS protocol version (e.g., Tls12, Tls13)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"NegotiatedCipherSuiteName"})," - Cipher suite negotiated for the connection"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"TargetHostName"})," - Server hostname used for certificate validation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"IsMutuallyAuthenticated"})," - Whether both client and server are authenticated"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"LocalCertificate"})," - Client certificate (if provided)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RemoteCertificate"})," - Server certificate"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"SSL information is only available when SSL is configured through IgniteClientConfiguration.SslStreamFactory. When SSL is not enabled, IConnectionInfo.SslInfo returns null."}),"\n",(0,r.jsx)(e.h3,{id:"iigniteclient-methods",children:"IIgniteClient Methods"}),"\n",(0,r.jsx)(e.p,{children:"Node discovery:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"GetClusterNodesAsync()"})," - Get all cluster nodes"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Connection inspection:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"GetConnections()"})," - Get active client connections to cluster nodes"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cache node lists"})," when possible. Cluster topology changes infrequently, so repeated calls to GetClusterNodesAsync may be unnecessary."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use node names for stable targeting"}),". Node IDs change on restart, but node names persist. Use names when you need consistent targeting across node restarts."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Monitor connection count"})," to detect connectivity issues. A sudden drop in active connections may indicate network problems or node failures."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Check SSL configuration"})," in production. Verify SSL is properly configured by inspecting ISslInfo properties to ensure connections are encrypted."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Handle node changes gracefully"}),". Cluster topology can change as nodes join or leave. Design applications to adapt to topology changes without manual intervention."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use connection info for diagnostics"}),". Connection details help troubleshoot network issues, SSL problems, and load distribution across nodes."]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);