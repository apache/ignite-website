"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2418],{4679:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"understand/core-concepts/compute-and-events","title":"Compute and Events","description":"Ignite 3 provides distributed compute for executing jobs across cluster nodes and an event system for monitoring cluster activity. The compute API uses an asynchronous, priority-based execution model built on CompletableFuture.","source":"@site/docs/understand/core-concepts/compute-and-events.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/compute-and-events","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/compute-and-events","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"compute-and-events","title":"Compute and Events","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Data Partitioning","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/data-partitioning"},"next":{"title":"Architecture","permalink":"/docs/ignite3/3.1.0/understand/architecture/"}}');var s=r(74848),i=r(28453);const o={id:"compute-and-events",title:"Compute and Events",sidebar_position:5},c=void 0,d={},l=[{value:"Distributed Compute Architecture",id:"distributed-compute-architecture",level:2},{value:"Job Execution Model",id:"job-execution-model",level:2},{value:"ComputeJob Interface",id:"computejob-interface",level:3},{value:"Job Targets",id:"job-targets",level:3},{value:"Any Node Execution",id:"any-node-execution",level:4},{value:"Colocated Execution",id:"colocated-execution",level:4},{value:"Broadcast Execution",id:"broadcast-execution",level:4},{value:"Job Scheduling",id:"job-scheduling",level:2},{value:"Job Priority",id:"job-priority",level:3},{value:"Job Failover",id:"job-failover",level:2},{value:"Job State Management",id:"job-state-management",level:2},{value:"Map-Reduce Tasks",id:"map-reduce-tasks",level:2},{value:"Event System",id:"event-system",level:2},{value:"Event Architecture",id:"event-architecture",level:3},{value:"Compute Events",id:"compute-events",level:3},{value:"Event Listeners",id:"event-listeners",level:3},{value:"Code Deployment",id:"code-deployment",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Ignite 3 provides distributed compute for executing jobs across cluster nodes and an event system for monitoring cluster activity. The compute API uses an asynchronous, priority-based execution model built on ",(0,s.jsx)(n.code,{children:"CompletableFuture"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"distributed-compute-architecture",children:"Distributed Compute Architecture"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Client"\r\n        Submit[Submit Job]\r\n    end\r\n\r\n    subgraph "Job Routing"\r\n        Target{Job Target}\r\n        Any[Any Node]\r\n        Coloc[Colocated]\r\n        Bcast[Broadcast]\r\n    end\r\n\r\n    subgraph "Cluster Nodes"\r\n        N1[Node 1<br/>Executor]\r\n        N2[Node 2<br/>Executor]\r\n        N3[Node 3<br/>Executor]\r\n    end\r\n\r\n    Submit --\x3e Target\r\n    Target --\x3e|AnyNode| Any\r\n    Target --\x3e|Colocated| Coloc\r\n    Target --\x3e|Broadcast| Bcast\r\n    Any --\x3e N1\r\n    Coloc --\x3e N2\r\n    Bcast --\x3e N1 & N2 & N3'}),"\n",(0,s.jsx)(n.p,{children:"Key characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Asynchronous execution returning ",(0,s.jsx)(n.code,{children:"CompletableFuture<R>"})]}),"\n",(0,s.jsx)(n.li,{children:"Job placement based on target type (any node, colocated, broadcast)"}),"\n",(0,s.jsx)(n.li,{children:"Priority-based queue with configurable thread pool"}),"\n",(0,s.jsx)(n.li,{children:"Automatic failover on node departure"}),"\n",(0,s.jsx)(n.li,{children:"Map-reduce support for split/aggregate patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"job-execution-model",children:"Job Execution Model"}),"\n",(0,s.jsx)(n.h3,{id:"computejob-interface",children:"ComputeJob Interface"}),"\n",(0,s.jsxs)(n.p,{children:["Jobs implement the ",(0,s.jsx)(n.code,{children:"ComputeJob<T, R>"})," interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public interface ComputeJob<T, R> {\r\n    CompletableFuture<R> executeAsync(\r\n        JobExecutionContext context,\r\n        T arg\r\n    );\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"JobExecutionContext"})," provides:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite()"})}),(0,s.jsx)(n.td,{children:"Ignite instance for cluster operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isCancelled()"})}),(0,s.jsx)(n.td,{children:"Check if cancellation requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"partition()"})}),(0,s.jsx)(n.td,{children:"Partition info for colocated jobs"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Example job implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class AccountBalanceJob implements ComputeJob<Long, Double> {\r\n    @Override\r\n    public CompletableFuture<Double> executeAsync(\r\n            JobExecutionContext context,\r\n            Long accountId) {\r\n\r\n        Table accounts = context.ignite().tables().table("accounts");\r\n        RecordView<Tuple> view = accounts.recordView();\r\n\r\n        Tuple key = Tuple.create().set("id", accountId);\r\n        Tuple record = view.get(null, key);\r\n\r\n        return CompletableFuture.completedFuture(\r\n            record.doubleValue("balance")\r\n        );\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"job-targets",children:"Job Targets"}),"\n",(0,s.jsx)(n.p,{children:"Job targets determine where jobs execute:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Target Types"\r\n        ANY["AnyNode<br/>Single node from set"]\r\n        COLOC["Colocated<br/>Node with key\'s partition"]\r\n        BCAST["Broadcast<br/>All nodes in set"]\r\n    end'}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Target"}),(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Return Type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"AnyNode"})}),(0,s.jsx)(n.td,{children:"Stateless computation"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JobExecution<R>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Colocated"})}),(0,s.jsx)(n.td,{children:"Data-local processing"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JobExecution<R>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Broadcast"})}),(0,s.jsx)(n.td,{children:"Cluster-wide operations"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BroadcastExecution<R>"})})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"any-node-execution",children:"Any Node Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on any available node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<Long, Double> descriptor = JobDescriptor\r\n    .<Long, Double>builder(AccountBalanceJob.class)\r\n    .build();\r\n\r\nJobExecution<Double> execution = client.compute()\r\n    .submit(JobTarget.anyNode(client.clusterNodes()), descriptor, accountId);\r\n\r\nDouble balance = execution.resultAsync().join();\n"})}),"\n",(0,s.jsx)(n.h4,{id:"colocated-execution",children:"Colocated Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on the node holding specific data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Execute where account 42\'s data lives\r\nJobExecution<Double> execution = client.compute().submit(\r\n    JobTarget.colocated("accounts", Tuple.create().set("id", 42L)),\r\n    descriptor,\r\n    42L\r\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"This eliminates network transfer for data-intensive operations."}),"\n",(0,s.jsx)(n.h4,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on all specified nodes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"BroadcastExecution<String> execution = client.compute().submitBroadcast(\r\n    client.clusterNodes(),\r\n    JobDescriptor.builder(NodeInfoJob.class).build(),\r\n    null\r\n);\r\n\r\n// Get results from all nodes\r\nMap<ClusterNode, String> results = execution.resultsAsync().join();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"job-scheduling",children:"Job Scheduling"}),"\n",(0,s.jsx)(n.p,{children:"Jobs execute through a priority-based queue system:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Priority Queue"\r\n        P0["Priority 0<br/>(highest)"]\r\n        P1["Priority 1"]\r\n        P2["Priority 2"]\r\n        PN["Priority N<br/>(lowest)"]\r\n    end\r\n\r\n    subgraph "Thread Pool"\r\n        T1[Worker 1]\r\n        T2[Worker 2]\r\n        TN[Worker N]\r\n    end\r\n\r\n    P0 --\x3e T1\r\n    P1 --\x3e T2\r\n    P2 --\x3e TN'}),"\n",(0,s.jsx)(n.p,{children:"Configuration options:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Setting"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"threadPoolSize"})}),(0,s.jsx)(n.td,{children:"max(CPU cores, 8)"}),(0,s.jsx)(n.td,{children:"Worker thread count"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"queueMaxSize"})}),(0,s.jsx)(n.td,{children:"Integer.MAX_VALUE"}),(0,s.jsx)(n.td,{children:"Maximum queued jobs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"statesLifetimeMillis"})}),(0,s.jsx)(n.td,{children:"60,000"}),(0,s.jsx)(n.td,{children:"Job state retention"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"job-priority",children:"Job Priority"}),"\n",(0,s.jsx)(n.p,{children:"Set priority when submitting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<String, String> descriptor = JobDescriptor\r\n    .<String, String>builder(MyJob.class)\r\n    .priority(5)  // Higher number = lower priority\r\n    .build();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change priority during execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobExecution<String> execution = client.compute().submit(target, descriptor, arg);\r\nexecution.changePriorityAsync(1);  // Move to higher priority\n"})}),"\n",(0,s.jsx)(n.p,{children:"Jobs with the same priority execute in FIFO order."}),"\n",(0,s.jsx)(n.h2,{id:"job-failover",children:"Job Failover"}),"\n",(0,s.jsx)(n.p,{children:"Ignite automatically handles node failures during job execution:"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    participant C as Client\r\n    participant N1 as Node A\r\n    participant N2 as Node B\r\n\r\n    C->>N1: Submit job\r\n    Note over N1: Executing...\r\n    Note over N1: Node fails\r\n    Note over C: Detects topology change\r\n    C->>N2: Re-submit job\r\n    N2--\x3e>C: Result"}),"\n",(0,s.jsx)(n.p,{children:"Failover behavior:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Triggered only on node departure (not job exceptions)"}),"\n",(0,s.jsx)(n.li,{children:"Selects next worker from remaining candidates"}),"\n",(0,s.jsx)(n.li,{children:"Continues until candidates exhausted"}),"\n",(0,s.jsx)(n.li,{children:"Application exceptions propagate to caller without retry"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For application-level retries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<String, String> descriptor = JobDescriptor\r\n    .<String, String>builder(MyJob.class)\r\n    .maxRetries(3)  // Retry on job failure\r\n    .build();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"job-state-management",children:"Job State Management"}),"\n",(0,s.jsx)(n.p,{children:"Track job execution through states:"}),"\n",(0,s.jsx)(n.mermaid,{value:"stateDiagram-v2\r\n    [*] --\x3e QUEUED: submit()\r\n    QUEUED --\x3e EXECUTING: worker picks up\r\n    EXECUTING --\x3e COMPLETED: success\r\n    EXECUTING --\x3e FAILED: exception\r\n    QUEUED --\x3e CANCELING: cancel()\r\n    EXECUTING --\x3e CANCELING: cancel()\r\n    CANCELING --\x3e CANCELED: acknowledged"}),"\n",(0,s.jsx)(n.p,{children:"Query job state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'JobExecution<String> execution = client.compute().submit(target, descriptor, arg);\r\n\r\nJobState state = execution.stateAsync().join();\r\nSystem.out.println("Status: " + state.status());\r\nSystem.out.println("Created: " + state.createTime());\r\nSystem.out.println("Started: " + state.startTime());\n'})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUED"}),(0,s.jsx)(n.td,{children:"Waiting in priority queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"EXECUTING"}),(0,s.jsx)(n.td,{children:"Running on worker thread"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPLETED"}),(0,s.jsx)(n.td,{children:"Finished successfully"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FAILED"}),(0,s.jsx)(n.td,{children:"Terminated with exception"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CANCELING"}),(0,s.jsx)(n.td,{children:"Cancellation in progress"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CANCELED"}),(0,s.jsx)(n.td,{children:"Cancelled by request"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"map-reduce-tasks",children:"Map-Reduce Tasks"}),"\n",(0,s.jsxs)(n.p,{children:["For split/aggregate computation patterns, use ",(0,s.jsx)(n.code,{children:"MapReduceTask"}),":"]}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\r\n    subgraph "Split Phase"\r\n        Input[Input Data]\r\n        S1[Job 1]\r\n        S2[Job 2]\r\n        S3[Job 3]\r\n    end\r\n\r\n    subgraph "Map Phase"\r\n        N1[Node 1<br/>Execute Job 1]\r\n        N2[Node 2<br/>Execute Job 2]\r\n        N3[Node 3<br/>Execute Job 3]\r\n    end\r\n\r\n    subgraph "Reduce Phase"\r\n        Agg[Aggregate Results]\r\n        Output[Final Result]\r\n    end\r\n\r\n    Input --\x3e S1 & S2 & S3\r\n    S1 --\x3e N1\r\n    S2 --\x3e N2\r\n    S3 --\x3e N3\r\n    N1 & N2 & N3 --\x3e Agg\r\n    Agg --\x3e Output'}),"\n",(0,s.jsx)(n.p,{children:"Implement the task interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class WordCountTask implements MapReduceTask<String, String, Map<String, Long>, Map<String, Long>> {\r\n\r\n    @Override\r\n    public CompletableFuture<List<MapReduceJob<String, Map<String, Long>>>> splitAsync(\r\n            TaskExecutionContext context,\r\n            String input) {\r\n\r\n        // Split input into chunks for parallel processing\r\n        List<MapReduceJob<String, Map<String, Long>>> jobs = Arrays.stream(input.split("\\n\\n"))\r\n            .map(chunk -> MapReduceJob.<String, Map<String, Long>>builder()\r\n                .jobDescriptor(JobDescriptor.builder(CountWordsJob.class).build())\r\n                .args(chunk)\r\n                .build())\r\n            .toList();\r\n\r\n        return CompletableFuture.completedFuture(jobs);\r\n    }\r\n\r\n    @Override\r\n    public CompletableFuture<Map<String, Long>> reduceAsync(\r\n            TaskExecutionContext context,\r\n            Map<UUID, Map<String, Long>> results) {\r\n\r\n        // Aggregate word counts from all jobs\r\n        Map<String, Long> totals = new HashMap<>();\r\n        for (Map<String, Long> partial : results.values()) {\r\n            partial.forEach((word, count) ->\r\n                totals.merge(word, count, Long::sum));\r\n        }\r\n        return CompletableFuture.completedFuture(totals);\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Submit the task:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"TaskDescriptor<String, Map<String, Long>> descriptor = TaskDescriptor\r\n    .<String, Map<String, Long>>builder(WordCountTask.class)\r\n    .build();\r\n\r\nTaskExecution<Map<String, Long>> execution = client.compute()\r\n    .submitMapReduce(descriptor, document);\r\n\r\nMap<String, Long> wordCounts = execution.resultAsync().join();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-system",children:"Event System"}),"\n",(0,s.jsx)(n.p,{children:"Ignite provides an event system for monitoring cluster and compute activity."}),"\n",(0,s.jsx)(n.h3,{id:"event-architecture",children:"Event Architecture"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\r\n    subgraph "Event Sources"\r\n        Compute[Compute Events]\r\n        Cluster[Cluster Events]\r\n    end\r\n\r\n    subgraph "Event Producer"\r\n        Fire[fireEvent]\r\n        Listeners[Listener Registry]\r\n    end\r\n\r\n    subgraph "Handlers"\r\n        L1[Listener 1]\r\n        L2[Listener 2]\r\n        L3[Listener 3]\r\n    end\r\n\r\n    Compute --\x3e Fire\r\n    Cluster --\x3e Fire\r\n    Fire --\x3e Listeners\r\n    Listeners --\x3e L1 & L2 & L3'}),"\n",(0,s.jsx)(n.h3,{id:"compute-events",children:"Compute Events"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event"}),(0,s.jsx)(n.th,{children:"Trigger"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_QUEUED"}),(0,s.jsx)(n.td,{children:"Job added to queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_EXECUTING"}),(0,s.jsx)(n.td,{children:"Job started execution"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_COMPLETED"}),(0,s.jsx)(n.td,{children:"Job finished successfully"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_FAILED"}),(0,s.jsx)(n.td,{children:"Job terminated with error"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_CANCELING"}),(0,s.jsx)(n.td,{children:"Cancellation requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_CANCELED"}),(0,s.jsx)(n.td,{children:"Job cancelled"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"event-listeners",children:"Event Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Register listeners for specific events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'EventListener<ComputeEventParameters> listener = params -> {\r\n    System.out.println("Job " + params.jobId() + " status: " + params.status());\r\n    return CompletableFuture.completedFuture(false);  // Keep listening\r\n};\r\n\r\nclient.compute().listen(IgniteEventType.COMPUTE_JOB_COMPLETED, listener);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Listener return values:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Return"}),(0,s.jsx)(n.th,{children:"Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Keep listener active"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Remove listener after this event"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"For synchronous handlers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'EventListener<ComputeEventParameters> listener = EventListener.fromConsumer(params -> {\r\n    log.info("Job completed: {}", params.jobId());\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"code-deployment",children:"Code Deployment"}),"\n",(0,s.jsx)(n.p,{children:"Jobs require their classes to be available on executing nodes. Deploy code using deployment units:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Create deployment unit from JAR\r\nDeploymentUnit unit = DeploymentUnit.fromPath(\r\n    "my-jobs",\r\n    "1.0.0",\r\n    Path.of("my-jobs.jar")\r\n);\r\n\r\n// Deploy to cluster\r\nclient.deployment().deployAsync(unit).join();\r\n\r\n// Reference in job descriptor\r\nJobDescriptor<String, String> descriptor = JobDescriptor\r\n    .<String, String>builder("com.example.MyJob")\r\n    .deploymentUnits(List.of(new DeploymentUnit("my-jobs", "1.0.0")))\r\n    .build();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stateless jobs"}),": Jobs should not maintain state between executions. Store state in tables if needed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Serializable arguments"}),": Job arguments and results must be serializable for network transfer."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Failover scope"}),": Automatic failover handles infrastructure failures only. Application exceptions propagate without retry unless ",(0,s.jsx)(n.code,{children:"maxRetries"})," is configured."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event ordering"}),": Listeners execute in registration order per event, but no global ordering across nodes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"One-shot listeners"}),": Return ",(0,s.jsx)(n.code,{children:"true"})," to auto-unsubscribe. Useful for waiting on specific events."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Thread pool bounds"}),": The executor thread pool is bounded. Long-running jobs can block other jobs."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/compute",children:"Compute API"})," for detailed API usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/code-deployment",children:"Code Deployment"})," for deployment patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/events",children:"Events"})," for event handling details"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var t=r(96540);const s={},i=t.createContext(s);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);