"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[180],{11470:(e,n,r)=>{r.d(n,{A:()=>A});var t=r(96540),a=r(34164),s=r(17559),i=r(23104),l=r(56347),o=r(205),c=r(57485),d=r(31682),u=r(70679);function L(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function S(e){const{values:n,children:r}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return L(e).map(({props:{value:e,label:n,attributes:r,default:t}})=>({value:e,label:n,attributes:r,default:t}))}(r);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,r])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function h({queryString:e=!1,groupId:n}){const r=(0,l.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(a),(0,t.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(r.location.search);n.set(a,e),r.replace({...r.location,search:n.toString()})},[a,r])]}function g(e){const{defaultValue:n,queryString:r=!1,groupId:a}=e,s=S(e),[i,l]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find(e=>e.default)??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s})),[c,d]=h({queryString:r,groupId:a}),[L,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,a]=(0,u.Dv)(n);return[r,(0,t.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),p=(()=>{const e=c??L;return m({value:e,tabValues:s})?e:null})();(0,o.A)(()=>{p&&l(p)},[p]);return{selectedValue:i,selectValue:(0,t.useCallback)(e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)},[d,g,s]),tabValues:s}}var p=r(92303);const Q={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=r(74848);function b({className:e,block:n,selectedValue:r,selectValue:t,tabValues:s}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,i.a_)(),c=e=>{const n=e.currentTarget,a=l.indexOf(n),i=s[a].value;i!==r&&(o(n),t(i))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const r=l.indexOf(e.currentTarget)+1;n=l[r]??l[0];break}case"ArrowLeft":{const r=l.indexOf(e.currentTarget)-1;n=l[r]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:t})=>(0,f.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...t,className:(0,a.A)("tabs__item",Q.tabItem,t?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:r}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===r);return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function _(e){const n=g(e);return(0,f.jsxs)("div",{className:(0,a.A)(s.G.tabs.container,"tabs-container",Q.tabList),children:[(0,f.jsx)(b,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function A(e){const n=(0,p.A)();return(0,f.jsx)(_,{...e,children:L(e.children)},String(n))}},19365:(e,n,r)=>{r.d(n,{A:()=>i});r(96540);var t=r(34164);const a={tabItem:"tabItem_Ymn6"};var s=r(74848);function i({children:e,hidden:n,className:r}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.A)(a.tabItem,r),hidden:n,children:e})}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(96540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}},33496:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>S,frontMatter:()=>o,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"developers-guide/sql/odbc/querying-modifying-data","title":"Querying and Modifying Data","description":"{/*","source":"@site/versioned_docs/version-3.0.0/developers-guide/sql/odbc/querying-modifying-data.md","sourceDirName":"developers-guide/sql/odbc","slug":"/developers-guide/sql/odbc/querying-modifying-data","permalink":"/docs/ignite3/3.0.0/developers-guide/sql/odbc/querying-modifying-data","draft":false,"unlisted":false,"tags":[],"version":"3.0.0","frontMatter":{"title":"Querying and Modifying Data","sidebar_label":"Querying and Modifying Data"},"sidebar":"tutorialSidebar","previous":{"title":"Connection String","permalink":"/docs/ignite3/3.0.0/developers-guide/sql/odbc/connection-string"},"next":{"title":"ODBC Standard Conformance","permalink":"/docs/ignite3/3.0.0/developers-guide/sql/odbc/specification"}}');var a=r(74848),s=r(28453),i=r(11470),l=r(19365);const o={title:"Querying and Modifying Data",sidebar_label:"Querying and Modifying Data"},c=void 0,d={},u=[{value:"Overview",id:"overview",level:2},{value:"Creating Tables",id:"creating-tables",level:2},{value:"Handling Errors",id:"handling-errors",level:2},{value:"Querying Data",id:"querying-data",level:2},{value:"Columns binding",id:"columns-binding",level:3},{value:"Inserting Data",id:"inserting-data",level:2},{value:"Error Checking",id:"error-checking",level:3},{value:"Updating Data",id:"updating-data",level:2},{value:"Deleting Data",id:"deleting-data",level:2}];function L(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:["\n","\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"This page describes how to connect to a cluster and execute a variety of SQL queries by using the ODBC driver."}),"\n",(0,a.jsx)(n.p,{children:"The ODBC driver supports DML (Data Modification Layer), which means that you can modify your data using an ODBC connection."}),"\n",(0,a.jsx)(n.h2,{id:"creating-tables",children:"Creating Tables"}),"\n",(0,a.jsx)(n.p,{children:"The simplest way to create tables by using ODBC Driver is to use DDL statements:"}),"\n",(0,a.jsx)(i.A,{children:(0,a.jsx)(l.A,{value:"ddl",label:"DDL",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'SQLHENV env;\r\n\r\n// Allocate an environment handle\r\nSQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &env);\r\n\r\n// Use ODBC ver 3.8\r\nSQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, reinterpret_cast<void*>(SQL_OV_ODBC3_80), 0);\r\n\r\nSQLHDBC dbc;\r\n\r\n// Allocate a connection handle\r\nSQLAllocHandle(SQL_HANDLE_DBC, env, &dbc);\r\n\r\n// Prepare the connection string\r\nSQLCHAR connectStr[] = "Driver={Apache Ignite 3};ADDRESS=localhost:10800;SCHEMA=PUBLIC;";\r\n\r\n// Connecting to the Cluster.\r\nSQLDriverConnect(dbc, NULL, connectStr, SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE);\r\n\r\nSQLHSTMT stmt;\r\n\r\n// Allocate a statement handle\r\nSQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\nSQLCHAR query1[] = "CREATE TABLE Person ( "\r\n    "id LONG PRIMARY KEY, "\r\n    "firstName VARCHAR, "\r\n    "lastName VARCHAR, "\r\n    "salary FLOAT) "";\r\n\r\nSQLExecDirect(stmt, query1, SQL_NTS);\r\n\r\nSQLCHAR query2[] = "CREATE TABLE Organization ( "\r\n    "id LONG PRIMARY KEY, "\r\n    "name VARCHAR) "";\r\n\r\nSQLExecDirect(stmt, query2, SQL_NTS);\r\n\r\nSQLCHAR query3[] = "CREATE INDEX idx_organization_name ON Organization (name)";\r\n\r\nSQLExecDirect(stmt, query3, SQL_NTS);\n'})})})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, we defined two tables that will contain the data of ",(0,a.jsx)(n.code,{children:"Person"})," and ",(0,a.jsx)(n.code,{children:"Organization"})," types.\r\nFor both types, we listed specific fields and indexes that will be read or updated using SQL."]}),"\n",(0,a.jsx)(n.h2,{id:"handling-errors",children:"Handling Errors"}),"\n",(0,a.jsx)(n.p,{children:"The section below covers how you can handle possible errors when working with ODBC. In this example we handle an issue with connecting to the cluster"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'// Connecting to Ignite Cluster.\r\nSQLRETURN ret = SQLDriverConnect(dbc, NULL, connectStr, SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE);\r\n\r\nif (!SQL_SUCCEEDED(ret))\r\n{\r\n  SQLCHAR sqlstate[7] = { 0 };\r\n  SQLINTEGER nativeCode;\r\n\r\n  SQLCHAR errMsg[BUFFER_SIZE] = { 0 };\r\n  SQLSMALLINT errMsgLen = static_cast<SQLSMALLINT>(sizeof(errMsg));\r\n\r\n  SQLGetDiagRec(SQL_HANDLE_DBC, dbc, 1, sqlstate, &nativeCode, errMsg, errMsgLen, &errMsgLen);\r\n\r\n  std::cerr << "Failed to connect to Ignite: "\r\n            << reinterpret_cast<char*>(sqlstate) << ": "\r\n            << reinterpret_cast<char*>(errMsg) << ", "\r\n            << "Native error code: " << nativeCode\r\n            << std::endl;\r\n\r\n  // Releasing allocated handles.\r\n  SQLFreeHandle(SQL_HANDLE_DBC, dbc);\r\n  SQLFreeHandle(SQL_HANDLE_ENV, env);\r\n\r\n  return;\r\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"querying-data",children:"Querying Data"}),"\n",(0,a.jsxs)(n.p,{children:["After everything is up and running, we're ready to execute ",(0,a.jsx)(n.code,{children:"SQL SELECT"})," queries using the ",(0,a.jsx)(n.code,{children:"ODBC API"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'SQLHSTMT stmt;\r\n\r\n// Allocate a statement handle\r\nSQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\nSQLCHAR query[] = "SELECT firstName, lastName, salary, Organization.name FROM Person "\r\n  "INNER JOIN Organization ON Person.orgId = Organization.id"\r\nSQLSMALLINT queryLen = static_cast<SQLSMALLINT>(sizeof(queryLen));\r\n\r\nSQLRETURN ret = SQLExecDirect(stmt, query, queryLen);\r\n\r\nif (!SQL_SUCCEEDED(ret))\r\n{\r\n  SQLCHAR sqlstate[7] = { 0 };\r\n  SQLINTEGER nativeCode;\r\n\r\n  SQLCHAR errMsg[BUFFER_SIZE] = { 0 };\r\n  SQLSMALLINT errMsgLen = static_cast<SQLSMALLINT>(sizeof(errMsg));\r\n\r\n  SQLGetDiagRec(SQL_HANDLE_DBC, dbc, 1, sqlstate, &nativeCode, errMsg, errMsgLen, &errMsgLen);\r\n\r\n  std::cerr << "Failed to perform SQL query: "\r\n            << reinterpret_cast<char*>(sqlstate) << ": "\r\n            << reinterpret_cast<char*>(errMsg) << ", "\r\n            << "Native error code: " << nativeCode\r\n            << std::endl;\r\n}\r\nelse\r\n{\r\n  // Printing the result set.\r\n  struct OdbcStringBuffer\r\n  {\r\n    SQLCHAR buffer[BUFFER_SIZE];\r\n    SQLLEN resLen;\r\n  };\r\n\r\n  // Getting a number of columns in the result set.\r\n  SQLSMALLINT columnsCnt = 0;\r\n  SQLNumResultCols(stmt, &columnsCnt);\r\n\r\n  // Allocating buffers for columns.\r\n  std::vector<OdbcStringBuffer> columns(columnsCnt);\r\n\r\n  // Binding columns. For simplicity we are going to use only\r\n  // string buffers here.\r\n  for (SQLSMALLINT i = 0; i < columnsCnt; ++i)\r\n    SQLBindCol(stmt, i + 1, SQL_C_CHAR, columns[i].buffer, BUFFER_SIZE, &columns[i].resLen);\r\n\r\n  // Fetching and printing data in a loop.\r\n  ret = SQLFetch(stmt);\r\n  while (SQL_SUCCEEDED(ret))\r\n  {\r\n    for (size_t i = 0; i < columns.size(); ++i)\r\n      std::cout << std::setw(16) << std::left << columns[i].buffer << " ";\r\n\r\n    std::cout << std::endl;\r\n\r\n    ret = SQLFetch(stmt);\r\n  }\r\n}\r\n\r\n// Releasing statement handle.\r\nSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n'})}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsx)(n.h3,{id:"columns-binding",children:"Columns binding"}),(0,a.jsx)(n.p,{children:"In the example above, we bind all columns to the SQL_C_CHAR columns. This means that all values are going to be converted to strings upon fetching. This is done for the sake of simplicity. Value conversion upon fetching can be pretty slow; so your default decision should be to fetch the value the same way as it is stored."})]}),"\n",(0,a.jsx)(n.h2,{id:"inserting-data",children:"Inserting Data"}),"\n",(0,a.jsxs)(n.p,{children:["To insert new data into the cluster, ",(0,a.jsx)(n.code,{children:"SQL INSERT"})," statements can be used from the ODBC side."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'SQLHSTMT stmt;\r\n\r\n// Allocate a statement handle\r\nSQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\nSQLCHAR query[] =\r\n\t"INSERT INTO Person (id, orgId, firstName, lastName, resume, salary) "\r\n\t"VALUES (?, ?, ?, ?, ?, ?)";\r\n\r\nSQLPrepare(stmt, query, static_cast<SQLSMALLINT>(sizeof(query)));\r\n\r\n// Binding columns.\r\nint64_t key = 0;\r\nint64_t orgId = 0;\r\nchar name[1024] = { 0 };\r\nSQLLEN nameLen = SQL_NTS;\r\ndouble salary = 0.0;\r\n\r\nSQLBindParameter(stmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_BIGINT, 0, 0, &key, 0, 0);\r\nSQLBindParameter(stmt, 2, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_BIGINT, 0, 0, &orgId, 0, 0);\r\nSQLBindParameter(stmt, 3, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR,\tsizeof(name), sizeof(name), name, 0, &nameLen);\r\nSQLBindParameter(stmt, 4, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_DOUBLE, 0, 0, &salary, 0, 0);\r\n\r\n// Filling cache.\r\nkey = 1;\r\norgId = 1;\r\nstrncpy(name, "John", sizeof(name));\r\nsalary = 2200.0;\r\n\r\nSQLExecute(stmt);\r\nSQLMoreResults(stmt);\r\n\r\n++key;\r\norgId = 1;\r\nstrncpy(name, "Jane", sizeof(name));\r\nsalary = 1300.0;\r\n\r\nSQLExecute(stmt);\r\nSQLMoreResults(stmt);\r\n\r\n++key;\r\norgId = 2;\r\nstrncpy(name, "Richard", sizeof(name));\r\nsalary = 900.0;\r\n\r\nSQLExecute(stmt);\r\nSQLMoreResults(stmt);\r\n\r\n++key;\r\norgId = 2;\r\nstrncpy(name, "Mary", sizeof(name));\r\nsalary = 2400.0;\r\n\r\nSQLExecute(stmt);\r\n\r\n// Releasing statement handle.\r\nSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Next, we are going to insert additional organizations without the usage of prepared statements."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"SQLHSTMT stmt;\r\n\r\n// Allocate a statement handle\r\nSQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\nSQLCHAR query1[] = \"INSERT INTO Organization (id, name) VALUES (1L, 'Some company')\";\r\n\r\nSQLExecDirect(stmt, query1, static_cast<SQLSMALLINT>(sizeof(query1)));\r\n\r\nSQLFreeStmt(stmt, SQL_CLOSE);\r\n\r\nSQLCHAR query2[] = \"INSERT INTO Organization (id, name) VALUES (2L, 'Some other company')\";\r\n\r\n  SQLExecDirect(stmt, query2, static_cast<SQLSMALLINT>(sizeof(query2)));\r\n\r\n// Releasing statement handle.\r\nSQLFreeHandle(SQL_HANDLE_STMT, stmt);\n"})}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsx)(n.h3,{id:"error-checking",children:"Error Checking"}),(0,a.jsx)(n.p,{children:"For simplicity the example code above does not check for an error return code. You will want to do error checking in production."})]}),"\n",(0,a.jsx)(n.h2,{id:"updating-data",children:"Updating Data"}),"\n",(0,a.jsxs)(n.p,{children:["Let's now update the salary for some of the persons stored in the cluster using SQL ",(0,a.jsx)(n.code,{children:"UPDATE"})," statement."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'void AdjustSalary(SQLHDBC dbc, int64_t key, double salary)\r\n{\r\n  SQLHSTMT stmt;\r\n\r\n  // Allocate a statement handle\r\n  SQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\n  SQLCHAR query[] = "UPDATE Person SET salary=? WHERE id=?";\r\n\r\n  SQLBindParameter(stmt, 1, SQL_PARAM_INPUT,\r\n      SQL_C_DOUBLE, SQL_DOUBLE, 0, 0, &salary, 0, 0);\r\n\r\n  SQLBindParameter(stmt, 2, SQL_PARAM_INPUT, SQL_C_SLONG,\r\n      SQL_BIGINT, 0, 0, &key, 0, 0);\r\n\r\n  SQLExecDirect(stmt, query, static_cast<SQLSMALLINT>(sizeof(query)));\r\n\r\n  // Releasing statement handle.\r\n  SQLFreeHandle(SQL_HANDLE_STMT, stmt);\r\n}\r\n\r\n...\r\nAdjustSalary(dbc, 3, 1200.0);\r\nAdjustSalary(dbc, 1, 2500.0);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"deleting-data",children:"Deleting Data"}),"\n",(0,a.jsxs)(n.p,{children:["Finally, let's remove a few records with the help of SQL ",(0,a.jsx)(n.code,{children:"DELETE"})," statement."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'void DeletePerson(SQLHDBC dbc, int64_t key)\r\n{\r\n  SQLHSTMT stmt;\r\n\r\n  // Allocate a statement handle\r\n  SQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\r\n\r\n  SQLCHAR query[] = "DELETE FROM Person WHERE id=?";\r\n\r\n  SQLBindParameter(stmt, 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_BIGINT,\r\n      0, 0, &key, 0, 0);\r\n\r\n  SQLExecDirect(stmt, query, static_cast<SQLSMALLINT>(sizeof(query)));\r\n\r\n  // Releasing statement handle.\r\n  SQLFreeHandle(SQL_HANDLE_STMT, stmt);\r\n}\r\n\r\n...\r\nDeletePerson(dbc, 1);\r\nDeletePerson(dbc, 4);\n'})})]})}function S(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(L,{...e})}):L(e)}}}]);