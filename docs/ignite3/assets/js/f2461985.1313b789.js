"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2418],{4679:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"understand/core-concepts/compute-and-events","title":"Compute and Events","description":"Ignite 3 provides distributed compute for executing jobs across cluster nodes and an event system for monitoring cluster activity. The compute API uses an asynchronous, priority-based execution model built on CompletableFuture.","source":"@site/docs/understand/core-concepts/compute-and-events.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/compute-and-events","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/compute-and-events","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"compute-and-events","title":"Compute and Events","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Data Partitioning","permalink":"/docs/ignite3/3.1.0/understand/core-concepts/data-partitioning"},"next":{"title":"Architecture","permalink":"/docs/ignite3/3.1.0/understand/architecture/"}}');var s=t(74848),i=t(28453);const o={id:"compute-and-events",title:"Compute and Events",sidebar_position:5},c=void 0,d={},l=[{value:"Distributed Compute Architecture",id:"distributed-compute-architecture",level:2},{value:"Job Execution Model",id:"job-execution-model",level:2},{value:"ComputeJob Interface",id:"computejob-interface",level:3},{value:"Job Targets",id:"job-targets",level:3},{value:"Any Node Execution",id:"any-node-execution",level:4},{value:"Colocated Execution",id:"colocated-execution",level:4},{value:"Broadcast Execution",id:"broadcast-execution",level:4},{value:"Job Scheduling",id:"job-scheduling",level:2},{value:"Job Priority",id:"job-priority",level:3},{value:"Job Failover",id:"job-failover",level:2},{value:"Job State Management",id:"job-state-management",level:2},{value:"Map-Reduce Tasks",id:"map-reduce-tasks",level:2},{value:"Event System",id:"event-system",level:2},{value:"Event Architecture",id:"event-architecture",level:3},{value:"Compute Events",id:"compute-events",level:3},{value:"Event Listeners",id:"event-listeners",level:3},{value:"Code Deployment",id:"code-deployment",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Ignite 3 provides distributed compute for executing jobs across cluster nodes and an event system for monitoring cluster activity. The compute API uses an asynchronous, priority-based execution model built on ",(0,s.jsx)(n.code,{children:"CompletableFuture"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"distributed-compute-architecture",children:"Distributed Compute Architecture"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Client"\n        Submit[Submit Job]\n    end\n\n    subgraph "Job Routing"\n        Target{Job Target}\n        Any[Any Node]\n        Coloc[Colocated]\n        Bcast[Broadcast]\n    end\n\n    subgraph "Cluster Nodes"\n        N1[Node 1<br/>Executor]\n        N2[Node 2<br/>Executor]\n        N3[Node 3<br/>Executor]\n    end\n\n    Submit --\x3e Target\n    Target --\x3e|AnyNode| Any\n    Target --\x3e|Colocated| Coloc\n    Target --\x3e|Broadcast| Bcast\n    Any --\x3e N1\n    Coloc --\x3e N2\n    Bcast --\x3e N1 & N2 & N3'}),"\n",(0,s.jsx)(n.p,{children:"Key characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Asynchronous execution returning ",(0,s.jsx)(n.code,{children:"CompletableFuture<R>"})]}),"\n",(0,s.jsx)(n.li,{children:"Job placement based on target type (any node, colocated, broadcast)"}),"\n",(0,s.jsx)(n.li,{children:"Priority-based queue with configurable thread pool"}),"\n",(0,s.jsx)(n.li,{children:"Automatic failover on node departure"}),"\n",(0,s.jsx)(n.li,{children:"Map-reduce support for split/aggregate patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"job-execution-model",children:"Job Execution Model"}),"\n",(0,s.jsx)(n.h3,{id:"computejob-interface",children:"ComputeJob Interface"}),"\n",(0,s.jsxs)(n.p,{children:["Jobs implement the ",(0,s.jsx)(n.code,{children:"ComputeJob<T, R>"})," interface:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public interface ComputeJob<T, R> {\n    CompletableFuture<R> executeAsync(\n        JobExecutionContext context,\n        T arg\n    );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"JobExecutionContext"})," provides:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ignite()"})}),(0,s.jsx)(n.td,{children:"Ignite instance for cluster operations"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isCancelled()"})}),(0,s.jsx)(n.td,{children:"Check if cancellation requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"partition()"})}),(0,s.jsx)(n.td,{children:"Partition info for colocated jobs"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Example job implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class AccountBalanceJob implements ComputeJob<Long, Double> {\n    @Override\n    public CompletableFuture<Double> executeAsync(\n            JobExecutionContext context,\n            Long accountId) {\n\n        Table accounts = context.ignite().tables().table("accounts");\n        RecordView<Tuple> view = accounts.recordView();\n\n        Tuple key = Tuple.create().set("id", accountId);\n        Tuple record = view.get(null, key);\n\n        return CompletableFuture.completedFuture(\n            record.doubleValue("balance")\n        );\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"job-targets",children:"Job Targets"}),"\n",(0,s.jsx)(n.p,{children:"Job targets determine where jobs execute:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Target Types"\n        ANY["AnyNode<br/>Single node from set"]\n        COLOC["Colocated<br/>Node with key\'s partition"]\n        BCAST["Broadcast<br/>All nodes in set"]\n    end'}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Target"}),(0,s.jsx)(n.th,{children:"Use Case"}),(0,s.jsx)(n.th,{children:"Return Type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"AnyNode"})}),(0,s.jsx)(n.td,{children:"Stateless computation"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JobExecution<R>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Colocated"})}),(0,s.jsx)(n.td,{children:"Data-local processing"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JobExecution<R>"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Broadcast"})}),(0,s.jsx)(n.td,{children:"Cluster-wide operations"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BroadcastExecution<R>"})})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"any-node-execution",children:"Any Node Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on any available node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<Long, Double> descriptor = JobDescriptor\n    .<Long, Double>builder(AccountBalanceJob.class)\n    .build();\n\nJobExecution<Double> execution = client.compute()\n    .submit(JobTarget.anyNode(client.clusterNodes()), descriptor, accountId);\n\nDouble balance = execution.resultAsync().join();\n"})}),"\n",(0,s.jsx)(n.h4,{id:"colocated-execution",children:"Colocated Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on the node holding specific data:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Execute where account 42\'s data lives\nJobExecution<Double> execution = client.compute().submit(\n    JobTarget.colocated("accounts", Tuple.create().set("id", 42L)),\n    descriptor,\n    42L\n);\n'})}),"\n",(0,s.jsx)(n.p,{children:"This eliminates network transfer for data-intensive operations."}),"\n",(0,s.jsx)(n.h4,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,s.jsx)(n.p,{children:"Execute on all specified nodes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"BroadcastExecution<String> execution = client.compute().submitBroadcast(\n    client.clusterNodes(),\n    JobDescriptor.builder(NodeInfoJob.class).build(),\n    null\n);\n\n// Get results from all nodes\nMap<ClusterNode, String> results = execution.resultsAsync().join();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"job-scheduling",children:"Job Scheduling"}),"\n",(0,s.jsx)(n.p,{children:"Jobs execute through a priority-based queue system:"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Priority Queue"\n        P0["Priority 0<br/>(highest)"]\n        P1["Priority 1"]\n        P2["Priority 2"]\n        PN["Priority N<br/>(lowest)"]\n    end\n\n    subgraph "Thread Pool"\n        T1[Worker 1]\n        T2[Worker 2]\n        TN[Worker N]\n    end\n\n    P0 --\x3e T1\n    P1 --\x3e T2\n    P2 --\x3e TN'}),"\n",(0,s.jsx)(n.p,{children:"Configuration options:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Setting"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"threadPoolSize"})}),(0,s.jsx)(n.td,{children:"max(CPU cores, 8)"}),(0,s.jsx)(n.td,{children:"Worker thread count"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"queueMaxSize"})}),(0,s.jsx)(n.td,{children:"Integer.MAX_VALUE"}),(0,s.jsx)(n.td,{children:"Maximum queued jobs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"statesLifetimeMillis"})}),(0,s.jsx)(n.td,{children:"60,000"}),(0,s.jsx)(n.td,{children:"Job state retention"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"job-priority",children:"Job Priority"}),"\n",(0,s.jsx)(n.p,{children:"Set priority when submitting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<String, String> descriptor = JobDescriptor\n    .<String, String>builder(MyJob.class)\n    .priority(5)  // Higher number = lower priority\n    .build();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Change priority during execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobExecution<String> execution = client.compute().submit(target, descriptor, arg);\nexecution.changePriorityAsync(1);  // Move to higher priority\n"})}),"\n",(0,s.jsx)(n.p,{children:"Jobs with the same priority execute in FIFO order."}),"\n",(0,s.jsx)(n.h2,{id:"job-failover",children:"Job Failover"}),"\n",(0,s.jsx)(n.p,{children:"Ignite automatically handles node failures during job execution:"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant C as Client\n    participant N1 as Node A\n    participant N2 as Node B\n\n    C->>N1: Submit job\n    Note over N1: Executing...\n    Note over N1: Node fails\n    Note over C: Detects topology change\n    C->>N2: Re-submit job\n    N2--\x3e>C: Result"}),"\n",(0,s.jsx)(n.p,{children:"Failover behavior:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Triggered only on node departure (not job exceptions)"}),"\n",(0,s.jsx)(n.li,{children:"Selects next worker from remaining candidates"}),"\n",(0,s.jsx)(n.li,{children:"Continues until candidates exhausted"}),"\n",(0,s.jsx)(n.li,{children:"Application exceptions propagate to caller without retry"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For application-level retries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"JobDescriptor<String, String> descriptor = JobDescriptor\n    .<String, String>builder(MyJob.class)\n    .maxRetries(3)  // Retry on job failure\n    .build();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"job-state-management",children:"Job State Management"}),"\n",(0,s.jsx)(n.p,{children:"Track job execution through states:"}),"\n",(0,s.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e QUEUED: submit()\n    QUEUED --\x3e EXECUTING: worker picks up\n    EXECUTING --\x3e COMPLETED: success\n    EXECUTING --\x3e FAILED: exception\n    QUEUED --\x3e CANCELING: cancel()\n    EXECUTING --\x3e CANCELING: cancel()\n    CANCELING --\x3e CANCELED: acknowledged"}),"\n",(0,s.jsx)(n.p,{children:"Query job state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'JobExecution<String> execution = client.compute().submit(target, descriptor, arg);\n\nJobState state = execution.stateAsync().join();\nSystem.out.println("Status: " + state.status());\nSystem.out.println("Created: " + state.createTime());\nSystem.out.println("Started: " + state.startTime());\n'})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"QUEUED"}),(0,s.jsx)(n.td,{children:"Waiting in priority queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"EXECUTING"}),(0,s.jsx)(n.td,{children:"Running on worker thread"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPLETED"}),(0,s.jsx)(n.td,{children:"Finished successfully"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"FAILED"}),(0,s.jsx)(n.td,{children:"Terminated with exception"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CANCELING"}),(0,s.jsx)(n.td,{children:"Cancellation in progress"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CANCELED"}),(0,s.jsx)(n.td,{children:"Cancelled by request"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"map-reduce-tasks",children:"Map-Reduce Tasks"}),"\n",(0,s.jsxs)(n.p,{children:["For split/aggregate computation patterns, use ",(0,s.jsx)(n.code,{children:"MapReduceTask"}),":"]}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Split Phase"\n        Input[Input Data]\n        S1[Job 1]\n        S2[Job 2]\n        S3[Job 3]\n    end\n\n    subgraph "Map Phase"\n        N1[Node 1<br/>Execute Job 1]\n        N2[Node 2<br/>Execute Job 2]\n        N3[Node 3<br/>Execute Job 3]\n    end\n\n    subgraph "Reduce Phase"\n        Agg[Aggregate Results]\n        Output[Final Result]\n    end\n\n    Input --\x3e S1 & S2 & S3\n    S1 --\x3e N1\n    S2 --\x3e N2\n    S3 --\x3e N3\n    N1 & N2 & N3 --\x3e Agg\n    Agg --\x3e Output'}),"\n",(0,s.jsx)(n.p,{children:"Implement the task interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class WordCountTask implements MapReduceTask<String, String, Map<String, Long>, Map<String, Long>> {\n\n    @Override\n    public CompletableFuture<List<MapReduceJob<String, Map<String, Long>>>> splitAsync(\n            TaskExecutionContext context,\n            String input) {\n\n        // Split input into chunks for parallel processing\n        List<MapReduceJob<String, Map<String, Long>>> jobs = Arrays.stream(input.split("\\n\\n"))\n            .map(chunk -> MapReduceJob.<String, Map<String, Long>>builder()\n                .jobDescriptor(JobDescriptor.builder(CountWordsJob.class).build())\n                .args(chunk)\n                .build())\n            .toList();\n\n        return CompletableFuture.completedFuture(jobs);\n    }\n\n    @Override\n    public CompletableFuture<Map<String, Long>> reduceAsync(\n            TaskExecutionContext context,\n            Map<UUID, Map<String, Long>> results) {\n\n        // Aggregate word counts from all jobs\n        Map<String, Long> totals = new HashMap<>();\n        for (Map<String, Long> partial : results.values()) {\n            partial.forEach((word, count) ->\n                totals.merge(word, count, Long::sum));\n        }\n        return CompletableFuture.completedFuture(totals);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Submit the task:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"TaskDescriptor<String, Map<String, Long>> descriptor = TaskDescriptor\n    .<String, Map<String, Long>>builder(WordCountTask.class)\n    .build();\n\nTaskExecution<Map<String, Long>> execution = client.compute()\n    .submitMapReduce(descriptor, document);\n\nMap<String, Long> wordCounts = execution.resultAsync().join();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-system",children:"Event System"}),"\n",(0,s.jsx)(n.p,{children:"Ignite provides an event system for monitoring cluster and compute activity."}),"\n",(0,s.jsx)(n.h3,{id:"event-architecture",children:"Event Architecture"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Event Sources"\n        Compute[Compute Events]\n        Cluster[Cluster Events]\n    end\n\n    subgraph "Event Producer"\n        Fire[fireEvent]\n        Listeners[Listener Registry]\n    end\n\n    subgraph "Handlers"\n        L1[Listener 1]\n        L2[Listener 2]\n        L3[Listener 3]\n    end\n\n    Compute --\x3e Fire\n    Cluster --\x3e Fire\n    Fire --\x3e Listeners\n    Listeners --\x3e L1 & L2 & L3'}),"\n",(0,s.jsx)(n.h3,{id:"compute-events",children:"Compute Events"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event"}),(0,s.jsx)(n.th,{children:"Trigger"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_QUEUED"}),(0,s.jsx)(n.td,{children:"Job added to queue"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_EXECUTING"}),(0,s.jsx)(n.td,{children:"Job started execution"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_COMPLETED"}),(0,s.jsx)(n.td,{children:"Job finished successfully"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_FAILED"}),(0,s.jsx)(n.td,{children:"Job terminated with error"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_CANCELING"}),(0,s.jsx)(n.td,{children:"Cancellation requested"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"COMPUTE_JOB_CANCELED"}),(0,s.jsx)(n.td,{children:"Job cancelled"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"event-listeners",children:"Event Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Register listeners for specific events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'EventListener<ComputeEventParameters> listener = params -> {\n    System.out.println("Job " + params.jobId() + " status: " + params.status());\n    return CompletableFuture.completedFuture(false);  // Keep listening\n};\n\nclient.compute().listen(IgniteEventType.COMPUTE_JOB_COMPLETED, listener);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Listener return values:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Return"}),(0,s.jsx)(n.th,{children:"Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"Keep listener active"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Remove listener after this event"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"For synchronous handlers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'EventListener<ComputeEventParameters> listener = EventListener.fromConsumer(params -> {\n    log.info("Job completed: {}", params.jobId());\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"code-deployment",children:"Code Deployment"}),"\n",(0,s.jsx)(n.p,{children:"Jobs require their classes to be available on executing nodes. Deploy code using deployment units:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Create deployment unit from JAR\nDeploymentUnit unit = DeploymentUnit.fromPath(\n    "my-jobs",\n    "1.0.0",\n    Path.of("my-jobs.jar")\n);\n\n// Deploy to cluster\nclient.deployment().deployAsync(unit).join();\n\n// Reference in job descriptor\nJobDescriptor<String, String> descriptor = JobDescriptor\n    .<String, String>builder("com.example.MyJob")\n    .deploymentUnits(List.of(new DeploymentUnit("my-jobs", "1.0.0")))\n    .build();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stateless jobs"}),": Jobs should not maintain state between executions. Store state in tables if needed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Serializable arguments"}),": Job arguments and results must be serializable for network transfer."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Failover scope"}),": Automatic failover handles infrastructure failures only. Application exceptions propagate without retry unless ",(0,s.jsx)(n.code,{children:"maxRetries"})," is configured."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event ordering"}),": Listeners execute in registration order per event, but no global ordering across nodes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"One-shot listeners"}),": Return ",(0,s.jsx)(n.code,{children:"true"})," to auto-unsubscribe. Useful for waiting on specific events."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Thread pool bounds"}),": The executor thread pool is bounded. Long-running jobs can block other jobs."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/compute",children:"Compute API"})," for detailed API usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/code-deployment",children:"Code Deployment"})," for deployment patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/develop/work-with-data/events",children:"Events"})," for event handling details"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var r=t(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);