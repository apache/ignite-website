"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[179],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}},77222:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"understand/core-concepts/tables-and-schemas","title":"Tables and Schemas","description":"Tables are the primary data structure in Ignite 3. Unlike Ignite 2\'s cache-based model with Binary Objects, Ignite 3 stores data in tables with SQL-compatible schemas. This unifies the SQL and Key-Value APIs under a single data model.","source":"@site/docs/understand/core-concepts/tables-and-schemas.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/tables-and-schemas","permalink":"/suggested-site/docs/3.1.0/understand/core-concepts/tables-and-schemas","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/understand/core-concepts/tables-and-schemas.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"tables-and-schemas","title":"Tables and Schemas","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"What is Apache Ignite 3?","permalink":"/suggested-site/docs/3.1.0/understand/core-concepts/what-is-ignite"},"next":{"title":"Transactions and MVCC","permalink":"/suggested-site/docs/3.1.0/understand/core-concepts/transactions-and-mvcc"}}');var r=s(74848),a=s(28453);const t={id:"tables-and-schemas",title:"Tables and Schemas",sidebar_position:2},l=void 0,c={},d=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Schema Structure",id:"schema-structure",level:2},{value:"Column Types",id:"column-types",level:2},{value:"Fixed-Length Types",id:"fixed-length-types",level:3},{value:"Variable-Length Types",id:"variable-length-types",level:3},{value:"Primary Keys",id:"primary-keys",level:2},{value:"Schema Versioning",id:"schema-versioning",level:2},{value:"Table Views",id:"table-views",level:2},{value:"RecordView",id:"recordview",level:3},{value:"KeyValueView",id:"keyvalueview",level:3},{value:"Tuple Views",id:"tuple-views",level:3},{value:"Binary Row Format",id:"binary-row-format",level:2},{value:"Catalog Management",id:"catalog-management",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Tables are the primary data structure in Ignite 3. Unlike Ignite 2's cache-based model with Binary Objects, Ignite 3 stores data in tables with SQL-compatible schemas. This unifies the SQL and Key-Value APIs under a single data model."}),"\n",(0,r.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(n.p,{children:"The table system consists of three layers:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Public API Layer"\n        Table[Table Interface]\n        RV[RecordView]\n        KV[KeyValueView]\n        TV[TupleView]\n    end\n\n    subgraph "Schema Layer"\n        SD[SchemaDescriptor]\n        Col[Column Definitions]\n        Marsh[Marshallers]\n    end\n\n    subgraph "Catalog Layer"\n        Cat[Catalog]\n        CTD[CatalogTableDescriptor]\n        CSV[CatalogSchemaVersions]\n    end\n\n    subgraph "Storage Layer"\n        IT[InternalTable]\n        Part[Partitions]\n        BR[BinaryRow]\n    end\n\n    Table --\x3e RV & KV & TV\n    RV & KV & TV --\x3e Marsh\n    Marsh --\x3e SD\n    SD --\x3e Col\n    CTD --\x3e CSV\n    Cat --\x3e CTD\n    IT --\x3e Part\n    Part --\x3e BR\n    SD -.-> CTD'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Catalog Layer"}),": Maintains versioned metadata for schemas, tables, indexes, and distribution zones"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema Layer"}),": Defines column types, handles binary serialization, and manages schema evolution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Storage Layer"}),": Manages partitioned data storage using binary row format"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"schema-structure",children:"Schema Structure"}),"\n",(0,r.jsxs)(n.p,{children:["Each table has a ",(0,r.jsx)(n.code,{children:"SchemaDescriptor"})," that defines its structure. The descriptor maintains multiple column orderings:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Ordering"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Row position"}),(0,r.jsx)(n.td,{children:"Full row serialization order"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Key position"}),(0,r.jsx)(n.td,{children:"Primary key columns only"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Value position"}),(0,r.jsx)(n.td,{children:"Non-key columns only"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Colocation position"}),(0,r.jsx)(n.td,{children:"Columns used for partition assignment"})]})]})]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "SchemaDescriptor"\n        direction TB\n        V[Version: 1]\n\n        subgraph "Column Orderings"\n            RP["Row: [id, name, balance, region]"]\n            KP["Key: [id]"]\n            VP["Value: [name, balance, region]"]\n            CP["Colocation: [id]"]\n        end\n    end'}),"\n",(0,r.jsxs)(n.p,{children:["The schema tracks column positions across these orderings. A column absent from a specific ordering has position ",(0,r.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"column-types",children:"Column Types"}),"\n",(0,r.jsx)(n.p,{children:"Ignite 3 supports two categories of native types:"}),"\n",(0,r.jsx)(n.h3,{id:"fixed-length-types",children:"Fixed-Length Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Size (bytes)"}),(0,r.jsx)(n.th,{children:"Java Mapping"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"BOOLEAN"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"boolean"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"INT8"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"byte"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"INT16"}),(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"short"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"INT32"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"INT64"}),(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"long"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"FLOAT"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DOUBLE"}),(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"double"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"UUID"}),(0,r.jsx)(n.td,{children:"16"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"java.util.UUID"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DATE"}),(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"java.time.LocalDate"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"variable-length-types",children:"Variable-Length Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Max Size"}),(0,r.jsx)(n.th,{children:"Java Mapping"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"STRING"}),(0,r.jsx)(n.td,{children:"65536 (default)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"String"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"BYTES"}),(0,r.jsx)(n.td,{children:"65536 (default)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"byte[]"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DECIMAL"}),(0,r.jsx)(n.td,{children:"precision/scale"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BigDecimal"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"TIME"}),(0,r.jsx)(n.td,{children:"precision (0-9)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"java.time.LocalTime"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DATETIME"}),(0,r.jsx)(n.td,{children:"precision (0-9)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"java.time.LocalDateTime"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"TIMESTAMP"}),(0,r.jsx)(n.td,{children:"precision (0-9)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"java.time.Instant"})})]})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Ignite 3 requires JavaTime API for temporal types. Legacy types like ",(0,r.jsx)(n.code,{children:"java.util.Date"}),", ",(0,r.jsx)(n.code,{children:"java.sql.Date"}),", ",(0,r.jsx)(n.code,{children:"java.sql.Time"}),", and ",(0,r.jsx)(n.code,{children:"java.sql.Timestamp"})," are not supported."]})}),"\n",(0,r.jsx)(n.h2,{id:"primary-keys",children:"Primary Keys"}),"\n",(0,r.jsx)(n.p,{children:"Every table requires a primary key. Ignite 3 supports two primary key types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hash Primary Key"}),": Uses hash-based partitioning for data distribution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sorted Primary Key"}),": Uses range-based partitioning with collation ordering"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Primary key constraints:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All primary key columns must be non-nullable"}),"\n",(0,r.jsx)(n.li,{children:"No duplicate columns allowed in key definition"}),"\n",(0,r.jsx)(n.li,{children:"All key columns must exist in the table schema"}),"\n",(0,r.jsx)(n.li,{children:"A primary key index is automatically created"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE accounts (\n    account_id INT PRIMARY KEY,\n    name VARCHAR(100),\n    balance DECIMAL(10, 2)\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"For composite keys:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE order_items (\n    order_id INT,\n    item_id INT,\n    quantity INT,\n    PRIMARY KEY (order_id, item_id)\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"schema-versioning",children:"Schema Versioning"}),"\n",(0,r.jsxs)(n.p,{children:["Ignite 3 uses append-only schema versioning. Each ",(0,r.jsx)(n.code,{children:"ALTER TABLE"})," operation increments the catalog version and creates a new schema version for the table."]}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Schema Evolution"\n        V1["Version 1<br/>[id, name]"]\n        V2["Version 2<br/>[id, name, email]"]\n        V3["Version 3<br/>[id, name, email, status]"]\n    end\n\n    V1 --\x3e|"ALTER TABLE<br/>ADD email"| V2\n    V2 --\x3e|"ALTER TABLE<br/>ADD status"| V3'}),"\n",(0,r.jsx)(n.p,{children:"Key versioning behaviors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Immutable versions"}),": Schema versions are never modified after creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consecutive numbering"}),": Versions increment by 1 with no gaps"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Column mapper"}),": Tracks transformations between versions for automatic data migration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary row versioning"}),": Each stored row carries its schema version"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When reading data written with an older schema version, Ignite automatically upgrades the row using the ",(0,r.jsx)(n.code,{children:"ColumnMapper"}),". New columns receive their default values."]}),"\n",(0,r.jsx)(n.h2,{id:"table-views",children:"Table Views"}),"\n",(0,r.jsx)(n.p,{children:"Tables expose multiple view abstractions for different access patterns:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TB\n    T[Table]\n\n    subgraph "Record Views"\n        TRV["Tuple RecordView<br/>(schema-less)"]\n        PRV["POJO RecordView<br/>(type-mapped)"]\n    end\n\n    subgraph "Key-Value Views"\n        TKV["Tuple KeyValueView<br/>(schema-less)"]\n        PKV["POJO KeyValueView<br/>(type-mapped)"]\n    end\n\n    T --\x3e TRV & PRV\n    T --\x3e TKV & PKV'}),"\n",(0,r.jsx)(n.h3,{id:"recordview",children:"RecordView"}),"\n",(0,r.jsx)(n.p,{children:"Works with complete row records containing all fields including the primary key:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'RecordView<Account> accounts = table.recordView(Account.class);\n\nAccount account = new Account(123, "John Doe", 1000.00);\naccounts.insert(null, account);\n\nAccount retrieved = accounts.get(null, new Account(123));\n'})}),"\n",(0,r.jsx)(n.h3,{id:"keyvalueview",children:"KeyValueView"}),"\n",(0,r.jsx)(n.p,{children:"Separates keys from values. Use this when the primary key is not logically part of the domain object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'KeyValueView<Long, Account> accounts = table.keyValueView(\n    Mapper.of(Long.class),\n    Mapper.of(Account.class)\n);\n\naccounts.put(null, 123L, new Account("John Doe", 1000.00));\nAccount account = accounts.get(null, 123L);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"tuple-views",children:"Tuple Views"}),"\n",(0,r.jsx)(n.p,{children:"For schema-less access without predefined classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\n\nTuple record = Tuple.create()\n    .set("id", 123)\n    .set("name", "John Doe")\n    .set("balance", 1000.00);\n\nview.insert(null, record);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"binary-row-format",children:"Binary Row Format"}),"\n",(0,r.jsx)(n.p,{children:"Data is stored in a compact binary format optimized for zero-copy reads:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "BinaryRow Structure"\n        SV[Schema Version<br/>2 bytes]\n        NB[Null Bitmap]\n        FD[Fixed-Length Data]\n        VO[Variable Offsets]\n        VD[Variable Data]\n    end\n\n    SV --\x3e NB --\x3e FD --\x3e VO --\x3e VD'}),"\n",(0,r.jsx)(n.p,{children:"The format supports:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Null tracking"}),": Bitmap indicates null columns without storing placeholder data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Direct access"}),": Fixed-length columns accessed by offset without deserialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Variable-length efficiency"}),": Offset table enables direct access to variable columns"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"catalog-management",children:"Catalog Management"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Catalog"})," maintains an immutable snapshot of the distributed schema at a specific version:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Tables are created via SQL\nclient.sql().execute(null,\n    "CREATE TABLE accounts (" +\n    "  id INT PRIMARY KEY," +\n    "  name VARCHAR(100)," +\n    "  balance DECIMAL(10,2)" +\n    ") WITH PRIMARY_ZONE=\'default\'"\n);\n\n// Access table via API\nTable accounts = client.tables().table("accounts");\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Schema operations use ",(0,r.jsx)(n.code,{children:"CatalogCommand"})," implementations:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CreateTableCommand"}),": Creates new table with schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AlterTableAddColumnCommand"}),": Adds columns to existing table"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AlterTableDropColumnCommand"}),": Removes columns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"DropTableCommand"}),": Removes table"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"All catalog operations are atomic and version-tracked."}),"\n",(0,r.jsx)(n.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,r.jsx)(n.p,{children:"When working with tables:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Table creation requires SQL"}),": The Table API only provides read and write operations. Use SQL DDL to create, alter, or drop tables."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Schema version continuity"}),": Schema versions must increment consecutively. Early versions may be pruned but intermediate versions cannot be skipped."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Primary key immutability"}),": Primary key columns cannot be modified after table creation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nullable inference"}),": Primary key columns are automatically non-nullable. Including nullable columns in a primary key raises a validation error."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type constraints"}),": Variable-length types have maximum length constraints. DECIMAL requires explicit precision and scale."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/3.1.0/develop/work-with-data/table-api",children:"Table API"})," for working with table views"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/3.1.0/sql/reference/language-definition/distribution-zones",children:"Distribution Zones"})," for partition configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/3.1.0/sql/reference/data-types",children:"Data Types"})," for SQL type mappings"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);