"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[543],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(96540);const l={},r=i.createContext(l);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),i.createElement(r.Provider,{value:n},e.children)}},83890:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"api-reference/native-clients/dotnet/tables-api","title":"Tables API","description":"The Tables API provides type-safe data access through record views and key-value views. This API supports both strongly-typed operations using C# classes and schema-free operations using tuples.","source":"@site/docs/api-reference/native-clients/dotnet/tables-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/tables-api","permalink":"/suggested-site/docs/3.1.0/api-reference/native-clients/dotnet/tables-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/dotnet/tables-api.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Tables API","id":"tables-api","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Client API","permalink":"/suggested-site/docs/3.1.0/api-reference/native-clients/dotnet/client-api"},"next":{"title":"LINQ API","permalink":"/suggested-site/docs/3.1.0/api-reference/native-clients/dotnet/linq-api"}}');var l=s(74848),r=s(28453);const t={title:"Tables API",id:"tables-api",sidebar_position:2},a="Tables API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"View Types",id:"view-types",level:3},{value:"Transaction Support",id:"transaction-support",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Getting Tables",id:"getting-tables",level:3},{value:"Record View Operations",id:"record-view-operations",level:3},{value:"Key-Value View Operations",id:"key-value-view-operations",level:3},{value:"Binary View with Tuples",id:"binary-view-with-tuples",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Conditional Operations",id:"conditional-operations",level:3},{value:"Get-and-Modify Operations",id:"get-and-modify-operations",level:3},{value:"LINQ Queries",id:"linq-queries",level:3},{value:"Reference",id:"reference",level:2},{value:"ITables Interface",id:"itables-interface",level:3},{value:"ITable Interface",id:"itable-interface",level:3},{value:"IRecordView&lt;T&gt; Interface",id:"irecordviewt-interface",level:3},{value:"IKeyValueView&lt;TK, TV&gt; Interface",id:"ikeyvalueviewtk-tv-interface",level:3},{value:"IIgniteTuple Interface",id:"iignitetuple-interface",level:3},{value:"Option&lt;T&gt; Type",id:"optiont-type",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"tables-api",children:"Tables API"})}),"\n",(0,l.jsx)(n.p,{children:"The Tables API provides type-safe data access through record views and key-value views. This API supports both strongly-typed operations using C# classes and schema-free operations using tuples."}),"\n",(0,l.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,l.jsx)(n.p,{children:"Tables in Ignite 3 are accessed through view interfaces that provide different access patterns. Record views work with complete rows as single objects, while key-value views separate keys and values into distinct objects. Both patterns support typed access (using C# classes) and untyped access (using IIgniteTuple)."}),"\n",(0,l.jsx)(n.h3,{id:"view-types",children:"View Types"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Record View"})," treats each row as a single object containing all columns. Use this when your operations work with complete records."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Key-Value View"})," separates key columns from value columns into distinct objects. Use this when you primarily access data by key or when your schema naturally divides into key and value sections."]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Binary View"})," provides untyped access using IIgniteTuple. Use this for dynamic schemas or when working with multiple table types through generic code."]}),"\n",(0,l.jsx)(n.h3,{id:"transaction-support",children:"Transaction Support"}),"\n",(0,l.jsx)(n.p,{children:"All data operations accept an optional transaction parameter. Pass null for auto-commit mode or pass an ITransaction instance to include operations in a transaction scope."}),"\n",(0,l.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,l.jsx)(n.h3,{id:"getting-tables",children:"Getting Tables"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var tables = client.Tables;\n\n// Get table by name\nvar table = await tables.GetTableAsync("customers");\n\n// Get table by qualified name (schema.table)\nvar qualifiedName = QualifiedName.Of("public", "orders");\nvar table = await tables.GetTableAsync(qualifiedName);\n\n// List all tables\nvar allTables = await tables.GetTablesAsync();\n'})}),"\n",(0,l.jsx)(n.h3,{id:"record-view-operations",children:"Record View Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'// Define a POCO class matching table schema\npublic class Customer\n{\n    public long Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\nvar table = await tables.GetTableAsync("customers");\nvar view = table.GetRecordView<Customer>();\n\n// Insert or replace\nvar customer = new Customer { Id = 1, Name = "Alice", Email = "alice@example.com" };\nawait view.UpsertAsync(null, customer);\n\n// Get by key (only Id field used)\nvar key = new Customer { Id = 1 };\nvar result = await view.GetAsync(null, key);\nif (result.HasValue)\n{\n    Console.WriteLine($"Found: {result.Value.Name}");\n}\n\n// Delete by key\nawait view.DeleteAsync(null, key);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"key-value-view-operations",children:"Key-Value View Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public class OrderKey\n{\n    public long OrderId { get; set; }\n}\n\npublic class OrderValue\n{\n    public long CustomerId { get; set; }\n    public DateTime OrderDate { get; set; }\n    public decimal Amount { get; set; }\n}\n\nvar table = await tables.GetTableAsync("orders");\nvar view = table.GetKeyValueView<OrderKey, OrderValue>();\n\n// Put key-value pair\nvar key = new OrderKey { OrderId = 100 };\nvar value = new OrderValue\n{\n    CustomerId = 1,\n    OrderDate = DateTime.UtcNow,\n    Amount = 49.99m\n};\nawait view.PutAsync(null, key, value);\n\n// Get value by key\nvar result = await view.GetAsync(null, key);\nif (result.HasValue)\n{\n    Console.WriteLine($"Amount: {result.Value.Amount}");\n}\n\n// Remove by key\nawait view.RemoveAsync(null, key);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"binary-view-with-tuples",children:"Binary View with Tuples"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var table = await tables.GetTableAsync("products");\nvar view = table.RecordBinaryView;\n\n// Create tuple\nvar tuple = new IgniteTuple\n{\n    ["id"] = 1L,\n    ["name"] = "Widget",\n    ["price"] = 29.99\n};\n\n// Upsert\nawait view.UpsertAsync(null, tuple);\n\n// Get by key tuple\nvar keyTuple = new IgniteTuple { ["id"] = 1L };\nvar result = await view.GetAsync(null, keyTuple);\nif (result.HasValue)\n{\n    Console.WriteLine($"Price: {result.Value["price"]}");\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var view = table.GetRecordView<Customer>();\n\n// Upsert multiple records\nvar customers = new[]\n{\n    new Customer { Id = 1, Name = "Alice", Email = "alice@example.com" },\n    new Customer { Id = 2, Name = "Bob", Email = "bob@example.com" },\n    new Customer { Id = 3, Name = "Carol", Email = "carol@example.com" }\n};\nawait view.UpsertAllAsync(null, customers);\n\n// Get multiple records\nvar keys = new[]\n{\n    new Customer { Id = 1 },\n    new Customer { Id = 2 },\n    new Customer { Id = 3 }\n};\nvar results = await view.GetAllAsync(null, keys);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"conditional-operations",children:"Conditional Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var view = table.GetRecordView<Customer>();\nvar key = new Customer { Id = 1 };\n\n// Insert only if not exists\nvar inserted = await view.InsertAsync(null, customer);\n\n// Replace only if exists\nvar replaced = await view.ReplaceAsync(null, customer);\n\n// Replace with compare-and-swap\nvar oldRecord = new Customer { Id = 1, Name = "Alice", Email = "alice@example.com" };\nvar newRecord = new Customer { Id = 1, Name = "Alice", Email = "alice@newdomain.com" };\nvar swapped = await view.ReplaceAsync(null, oldRecord, newRecord);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"get-and-modify-operations",children:"Get-and-Modify Operations"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var view = table.GetRecordView<Customer>();\n\n// Upsert and get old value\nvar result = await view.GetAndUpsertAsync(null, customer);\nif (result.HasValue)\n{\n    Console.WriteLine($"Replaced: {result.Value.Name}");\n}\n\n// Delete and get old value\nvar key = new Customer { Id = 1 };\nvar deleted = await view.GetAndDeleteAsync(null, key);\nif (deleted.HasValue)\n{\n    Console.WriteLine($"Deleted: {deleted.Value.Name}");\n}\n'})}),"\n",(0,l.jsx)(n.h3,{id:"linq-queries",children:"LINQ Queries"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var view = table.GetRecordView<Customer>();\n\n// Use LINQ with queryable and ToListAsync\nvar results = await view.AsQueryable()\n    .Where(c => c.Name.StartsWith("A"))\n    .OrderBy(c => c.Email)\n    .ToListAsync();\n\nforeach (var customer in results)\n{\n    Console.WriteLine($"{customer.Name}: {customer.Email}");\n}\n\n// Alternative: use ToResultSetAsync for streaming results\nvar resultSet = await view.AsQueryable()\n    .Where(c => c.Name.StartsWith("A"))\n    .OrderBy(c => c.Email)\n    .ToResultSetAsync();\n\nawait foreach (var customer in resultSet)\n{\n    Console.WriteLine($"{customer.Name}: {customer.Email}");\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,l.jsx)(n.h3,{id:"itables-interface",children:"ITables Interface"}),"\n",(0,l.jsx)(n.p,{children:"Methods for table discovery:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetTableAsync(string name)"})," - Get table by name, returns null if not found"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetTableAsync(QualifiedName name)"})," - Get table by schema-qualified name"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetTablesAsync()"})," - Get all available tables in the cluster"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"itable-interface",children:"ITable Interface"}),"\n",(0,l.jsx)(n.p,{children:"Properties:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Name"})," - Table name without schema qualifier"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"QualifiedName"})," - Full schema-qualified name"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RecordBinaryView"})," - Untyped record view using IIgniteTuple"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"KeyValueBinaryView"})," - Untyped key-value view using IIgniteTuple"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"PartitionManager"})," - Advanced partition management"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Methods:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetRecordView<T>()"})," - Create typed record view for type T"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetKeyValueView<TK, TV>()"})," - Create typed key-value view with key type TK and value type TV"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"irecordviewt-interface",children:"IRecordView<T> Interface"}),"\n",(0,l.jsx)(n.p,{children:"Read operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAsync(ITransaction?, T key)"})," - Get record by key, returns Option<T>"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAllAsync(ITransaction?, IEnumerable<T> keys)"})," - Get multiple records"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ContainsKeyAsync(ITransaction?, T key)"})," - Check if key exists"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Write operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"UpsertAsync(ITransaction?, T record)"})," - Insert or replace record"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"UpsertAllAsync(ITransaction?, IEnumerable<T> records)"})," - Insert or replace multiple records"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"InsertAsync(ITransaction?, T record)"})," - Insert only if not exists, returns bool"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"InsertAllAsync(ITransaction?, IEnumerable<T> records)"})," - Insert multiple, returns list of skipped keys"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ReplaceAsync(ITransaction?, T record)"})," - Replace existing record, returns bool"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ReplaceAsync(ITransaction?, T record, T newRecord)"})," - Conditional replace (compare-and-swap)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Delete operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"DeleteAsync(ITransaction?, T key)"})," - Delete by key, returns bool"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"DeleteAllAsync(ITransaction?, IEnumerable<T> keys)"})," - Delete multiple, returns list of non-existent keys"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"DeleteExactAsync(ITransaction?, T record)"})," - Delete only if exact match on all columns"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"DeleteAllExactAsync(ITransaction?, IEnumerable<T> records)"})," - Delete exact matches"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Get-and-modify operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndUpsertAsync(ITransaction?, T record)"})," - Upsert and return old value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndReplaceAsync(ITransaction?, T record)"})," - Replace and return old value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndDeleteAsync(ITransaction?, T key)"})," - Delete and return old value"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Query operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"AsQueryable(ITransaction?, QueryableOptions?)"})," - Create LINQ queryable interface"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"ikeyvalueviewtk-tv-interface",children:"IKeyValueView<TK, TV> Interface"}),"\n",(0,l.jsx)(n.p,{children:"Read operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAsync(ITransaction?, TK key)"})," - Get value by key, returns Option<TV>"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAllAsync(ITransaction?, IEnumerable<TK> keys)"})," - Get multiple values, returns Dictionary"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ContainsAsync(ITransaction?, TK key)"})," - Check if key exists"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Write operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"PutAsync(ITransaction?, TK key, TV val)"})," - Put key-value pair"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"PutAllAsync(ITransaction?, IEnumerable<KeyValuePair<TK, TV>> pairs)"})," - Put multiple pairs"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"PutIfAbsentAsync(ITransaction?, TK key, TV val)"})," - Put only if key absent, returns bool"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Replace operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ReplaceAsync(ITransaction?, TK key, TV val)"})," - Replace value for existing key, returns bool"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ReplaceAsync(ITransaction?, TK key, TV oldVal, TV newVal)"})," - Conditional replace"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Remove operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RemoveAsync(ITransaction?, TK key)"})," - Remove by key, returns bool"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RemoveAsync(ITransaction?, TK key, TV val)"})," - Remove only if value matches"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RemoveAllAsync(ITransaction?, IEnumerable<TK> keys)"})," - Remove multiple by key"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RemoveAllAsync(ITransaction?, IEnumerable<KeyValuePair<TK, TV>> pairs)"})," - Remove by key-value pairs"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Get-and-modify operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndPutAsync(ITransaction?, TK key, TV val)"})," - Put and return old value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndReplaceAsync(ITransaction?, TK key, TV val)"})," - Replace and return old value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetAndRemoveAsync(ITransaction?, TK key)"})," - Remove and return value"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Query operations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"AsQueryable(ITransaction?, QueryableOptions?)"})," - Create LINQ queryable interface"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"iignitetuple-interface",children:"IIgniteTuple Interface"}),"\n",(0,l.jsx)(n.p,{children:"Properties:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"FieldCount"})," - Number of columns in the tuple"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"this[int ordinal]"})," - Get or set column value by ordinal position"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"this[string name]"})," - Get or set column value by name"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Methods:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetName(int ordinal)"})," - Get column name by ordinal"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetOrdinal(string name)"})," - Get column ordinal by name (returns -1 if not found)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Static methods:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GetHashCode(IIgniteTuple)"})," - Compute hash considering names and values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Equals(IIgniteTuple?, IIgniteTuple?)"})," - Compare tuples ignoring column order"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ToString(IIgniteTuple)"})," - Generate string representation"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"optiont-type",children:"Option<T> Type"}),"\n",(0,l.jsx)(n.p,{children:"The Option type wraps nullable results:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"HasValue"})," - True if value exists"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Value"})," - The actual value (throws if HasValue is false)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This pattern avoids null reference issues and makes null handling explicit."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);