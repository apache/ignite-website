"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2313],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(96540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},40879:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"sql/advanced/performance-tuning","title":"Performance Tuning","description":"Optimizer Hints","source":"@site/docs/sql/advanced/performance-tuning.md","sourceDirName":"sql/advanced","slug":"/sql/advanced/performance-tuning","permalink":"/suggested-site/docs/ignite3/3.1.0/sql/advanced/performance-tuning","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/sql/advanced/performance-tuning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Performance Tuning","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"EXPLAIN Statement","permalink":"/suggested-site/docs/ignite3/3.1.0/sql/advanced/explain-statement"},"next":{"title":"Configure and Operate","permalink":"/suggested-site/docs/ignite3/3.1.0/configure-and-operate/"}}');var r=i(74848),a=i(28453);const s={title:"Performance Tuning",sidebar_position:3},o="SQL Performance Tuning",l={},d=[{value:"Optimizer Hints",id:"optimizer-hints",level:2},{value:"Hints format",id:"hints-format",level:3},{value:"Hint parameters",id:"hint-parameters",level:4},{value:"Hints errors",id:"hints-errors",level:3},{value:"Supported hints",id:"supported-hints",level:3},{value:"FORCE_INDEX / NO_INDEX",id:"force_index--no_index",level:4},{value:"Parameters:",id:"parameters",level:5},{value:"Examples:",id:"examples",level:5},{value:"Using EXPLAIN Statement",id:"using-explain-statement",level:2},{value:"EXPLAIN PLAN FOR Statement",id:"explain-plan-for-statement",level:3},{value:"EXPLAIN MAPPING FOR Statement",id:"explain-mapping-for-statement",level:3},{value:"Query Batching",id:"query-batching",level:2},{value:"Performance Consideration For Correlated Subqueries",id:"performance-consideration-for-correlated-subqueries",level:2},{value:"What Are Correlated Subqueries",id:"what-are-correlated-subqueries",level:3},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Improving Performance",id:"improving-performance",level:3},{value:"Examples of Improved Queries",id:"examples-of-improved-queries",level:3},{value:"Dropping Cached Plans",id:"dropping-cached-plans",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sql-performance-tuning",children:"SQL Performance Tuning"})}),"\n",(0,r.jsx)(n.h2,{id:"optimizer-hints",children:"Optimizer Hints"}),"\n",(0,r.jsx)(n.p,{children:"The query optimizer tries to execute the fastest execution plan. However, you can know about the data design, application design or data distribution in your cluster better. SQL hints can help the optimizer to make optimizations more rationally or build execution plan faster."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"SQL hints are optional to apply and might be skipped in some cases."})}),"\n",(0,r.jsx)(n.h3,{id:"hints-format",children:"Hints format"}),"\n",(0,r.jsxs)(n.p,{children:["SQL hints are defined by a special comment ",(0,r.jsx)(n.code,{children:"/*+ HINT */"}),", referred to as a ",(0,r.jsx)(n.em,{children:"hint block"}),". Spaces before and after the\nhint name are required. The hint block must be placed right after the operator. Several hints for one relation operator are not supported."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ NO_INDEX */ T1.* FROM TBL1 where T1.V1=? and T1.V2=?\n"})}),"\n",(0,r.jsx)(n.h4,{id:"hint-parameters",children:"Hint parameters"}),"\n",(0,r.jsx)(n.p,{children:"Hint parameters, if required, are placed in brackets after the hint name and separated by commas."}),"\n",(0,r.jsx)(n.p,{children:"The hint parameter can be quoted. Quoted parameter is case-sensitive. The quoted and unquoted parameters cannot be\ndefined for the same hint."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX(TBL1_IDX2,TBL2_IDX1) */ T1.V1, T2.V1 FROM TBL1 T1, TBL2 T2 WHERE T1.V1 = T2.V1 AND T1.V2 > ? AND T2.V2 > ?;\n\nSELECT /*+ FORCE_INDEX('TBL2_idx1') */ T1.V1, T2.V1 FROM TBL1 T1, TBL2 T2 WHERE T1.V1 = T2.V1 AND T1.V2 > ? AND T2.V2 > ?;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hints-errors",children:"Hints errors"}),"\n",(0,r.jsx)(n.p,{children:"The optimizer tries to apply every hint and its parameters, if possible. But it skips the hint or hint parameter if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The hint is not supported."}),"\n",(0,r.jsx)(n.li,{children:"Required hint parameters are not passed."}),"\n",(0,r.jsx)(n.li,{children:"The hint parameters have been passed, but the hint does not support any parameter."}),"\n",(0,r.jsx)(n.li,{children:"The hint parameter is incorrect or refers to a nonexistent object, such as a nonexistent index or table."}),"\n",(0,r.jsx)(n.li,{children:"The current hints or current parameters are incompatible with the previous ones, such as forcing the use and disabling of the same index."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.code,{children:"FORCE_INDEX"})," hint references an index that does not exist, the following error will be thrown:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'Hints mentioned indexes "IDX_NOT_FOUND1", "IDX_NOT_FOUND2" were not found.\n'})}),"\n",(0,r.jsx)(n.h3,{id:"supported-hints",children:"Supported hints"}),"\n",(0,r.jsx)(n.h4,{id:"force_index--no_index",children:"FORCE_INDEX / NO_INDEX"}),"\n",(0,r.jsx)(n.p,{children:"Forces or disables index scan."}),"\n",(0,r.jsx)(n.h5,{id:"parameters",children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Empty. To force an index scan for every underlying table. Optimizer will choose any available index. Or to disable all indexes."}),"\n",(0,r.jsx)(n.li,{children:"Single index name to use or skip exactly this index."}),"\n",(0,r.jsx)(n.li,{children:"Several index names. They can relate to different tables. The optimizer will choose indexes for scanning or skip them all."}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"examples",children:"Examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT /*+ FORCE_INDEX */ T1.* FROM TBL1 T1 WHERE T1.V1 = T2.V1 AND T1.V2 > ?;\n\nSELECT /*+ FORCE_INDEX(TBL1_IDX2, TBL2_IDX1) */ T1.V1, T2.V1 FROM TBL1 T1, TBL2 T2 WHERE T1.V1 = T2.V1 AND T1.V2 > ? AND T2.V2 > ?;\n\nSELECT /*+ NO_INDEX */ T1.* FROM TBL1 T1 WHERE T1.V1 = T2.V1 AND T1.V2 > ?;\n\nSELECT /*+ NO_INDEX(TBL1_IDX2, TBL2_IDX1) */ T1.V1, T2.V1 FROM TBL1 T1, TBL2 T2 WHERE T1.V1 = T2.V1 AND T1.V2 > ? AND T2.V2 > ?;\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The query cannot have both ",(0,r.jsx)(n.code,{children:"FORCE_INDEX"})," and ",(0,r.jsx)(n.code,{children:"NO_INDEX"})," hints at the same time."]})}),"\n",(0,r.jsx)(n.h2,{id:"using-explain-statement",children:"Using EXPLAIN Statement"}),"\n",(0,r.jsx)(n.h3,{id:"explain-plan-for-statement",children:"EXPLAIN PLAN FOR Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Ignite supports the ",(0,r.jsx)(n.a,{href:"/3.1.0/sql/reference/data-types-and-functions/operational-commands",children:(0,r.jsx)(n.code,{children:"EXPLAIN PLAN FOR"})})," statement that can be used to read the execution plan of a query."]}),"\n",(0,r.jsx)(n.p,{children:"Use this command to analyse your queries for possible optimization, for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN PLAN FOR SELECT name FROM Person WHERE age = 26;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Here is how the results of the explanation may look like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 PLAN                          \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 Exchange                      \u2551\n\u2551     distribution: single      \u2551\n\u2551     est. row count: 333000    \u2551\n\u2551   TableScan                   \u2551\n\u2551       table: [PUBLIC, PERSON] \u2551\n\u2551       filters: =(AGE, 26)     \u2551\n\u2551       fields: [$f0]           \u2551\n\u2551       projects: [NAME]        \u2551\n\u2551       est. row count: 333000  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n"})}),"\n",(0,r.jsx)(n.h3,{id:"explain-mapping-for-statement",children:"EXPLAIN MAPPING FOR Statement"}),"\n",(0,r.jsxs)(n.p,{children:["Apache Ignite supports the ",(0,r.jsx)(n.a,{href:"/3.1.0/sql/reference/data-types-and-functions/operational-commands",children:(0,r.jsx)(n.code,{children:"EXPLAIN MAPPING FOR"})})," statement that can be used to track how the query is split and what nodes the subqueries are executed on."]}),"\n",(0,r.jsx)(n.p,{children:"Use this command if you need an insight into how the query is broken down and executed across multiple nodes in the distributed cluster."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"EXPLAIN MAPPING FOR SELECT name FROM Person WHERE age = 26;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Here is how the results of the query may look like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551 PLAN                                                                                                                                                                                              \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 Fragment#0 root                                                                                                                                                                                   \u2551\n\u2551   executionNodes: [defaultNode]                                                                                                                                                                   \u2551\n\u2551   remoteFragments: [1]                                                                                                                                                                            \u2551\n\u2551   exchangeSourceNodes: {1=[defaultNode]}                                                                                                                                                          \u2551\n\u2551   tree:                                                                                                                                                                                           \u2551\n\u2551     Receiver(sourceFragment=1, exchange=1, distribution=single)                                                                                                                                   \u2551\n\u2551                                                                                                                                                                                                   \u2551\n\u2551 Fragment#1                                                                                                                                                                                        \u2551\n\u2551   targetNodes: [defaultNode]                                                                                                                                                                      \u2551\n\u2551   executionNodes: [defaultNode]                                                                                                                                                                   \u2551\n\u2551   tables: [PERSON]                                                                                                                                                                                \u2551\n\u2551   partitions: {defaultNode=[0:12, 1:12, 2:12, 3:12, 4:12, 5:12, 6:12, 7:12, 8:12, 9:12, 10:12, 11:12, 12:12, 13:12, 14:12, 15:12, 16:12, 17:12, 18:12, 19:12, 20:12, 21:12, 22:12, 23:12, 24:12]} \u2551\n\u2551   tree:                                                                                                                                                                                           \u2551\n\u2551     Sender(targetFragment=0, exchange=1, distribution=single)                                                                                                                                     \u2551\n\u2551       TableScan(name=PUBLIC.PERSON, source=2, partitions=25, distribution=random)                                                                                                                 \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n"})}),"\n",(0,r.jsx)(n.h2,{id:"query-batching",children:"Query Batching"}),"\n",(0,r.jsx)(n.p,{children:"Apache Ignite handles batched requests faster than individual requests, so we recommend using multi-statement execution when possible."}),"\n",(0,r.jsx)(n.p,{children:"When executing multiple queries in a single call, similar requests are automatically batched together. When writing large scripts that perform multiple different kinds of operations, we recommend the following order:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["All required ",(0,r.jsx)(n.a,{href:"/3.1.0/sql/reference/language-definition/ddl",children:"DDL operations"}),";"]}),"\n",(0,r.jsxs)(n.li,{children:["Assigning ",(0,r.jsx)(n.a,{href:"/3.1.0/sql/reference/data-types-and-functions/operational-commands",children:"access permissions"}),";"]}),"\n",(0,r.jsx)(n.li,{children:"Loading data into the tables."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["As execution of each statement is considered complete when the first page is ready to be returned, when working with large data sets, ",(0,r.jsx)(n.code,{children:"SELECT"})," statements may be affected by later statements in the same script."]}),"\n",(0,r.jsx)(n.h2,{id:"performance-consideration-for-correlated-subqueries",children:"Performance Consideration For Correlated Subqueries"}),"\n",(0,r.jsx)(n.p,{children:"Apache Ignite supports correlated subqueries, but the performance of certain complex correlated subqueries may be insufficient, especially when used in high-volume transactional or analytical workloads."}),"\n",(0,r.jsx)(n.h3,{id:"what-are-correlated-subqueries",children:"What Are Correlated Subqueries"}),"\n",(0,r.jsx)(n.p,{children:"A correlated subquery is a subquery that depends on values from the outer query for execution. It is evaluated once for every row of the outer query."}),"\n",(0,r.jsx)(n.p,{children:"For example, for a schema that is defined in the following way:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE projects (id INT PRIMARY KEY, name VARCHAR);\nCREATE TABLE employees (id INT PRIMARY KEY, department_id INT, name VARCHAR, salary DECIMAl);\nCREATE TABLE departments (id INT PRIMARY KEY, name VARCHAR);\nCREATE TABLE assignments (project_id INT, employee_id INT, PRIMARY KEY (project_id, employee_id));\n"})}),"\n",(0,r.jsx)(n.p,{children:"The correlated subquery may look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT e.name,\n       (SELECT COUNT(*)\n          FROM assignments a\n         WHERE a.employee_id = e.id\n       ) AS project_count\nFROM employees e;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the subquery references ",(0,r.jsx)(n.code,{children:"e.id"})," from the outer query, meaning it's re-evaluated for every employee row, leading to N separate subquery executions for N employees."]}),"\n",(0,r.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,r.jsx)(n.p,{children:"In Apache Ignite 3, repeated subquery executions are not automatically optimized. As a result:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scalar subqueries may become bottlenecks."}),"\n",(0,r.jsx)(n.li,{children:"Even small tables can cause high CPU and memory consumption when repeatedly queried."}),"\n",(0,r.jsx)(n.li,{children:"Certain queries may perform slower than expected."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"improving-performance",children:"Improving Performance"}),"\n",(0,r.jsx)(n.p,{children:"In general, highly-selective outer queries with cheap scalar subqueries (like single-row index lookup) will perform just fine. Here is an example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- This query returns an employee along with the name of the department they belong to.\n-- It uses a correlated scalar subquery to resolve the department name.\n--\n-- Note the predicate `e.id = ?`, which filters by the employee's primary key.\n-- This makes the outer query highly selective -- typically returning only a single row.\n--\n-- Because the subquery is evaluated only once (or a very small number of times),\n-- using a correlated scalar subquery is safe and has negligible performance impact\n-- in this case. There's no need to rewrite it using a join.\nSELECT e.*,\n       (SELECT name\n          FROM departments\n         WHERE id = e.department_id\n       ) AS employees_department\n  FROM employees e\n WHERE e.id = ?;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Similar query but without predicate may result in lower performance. If the query with predicate finishes in ",(0,r.jsx)(n.code,{children:"0.007s"}),", similar query without predicate could take up to ",(0,r.jsx)(n.code,{children:"2.4s"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Here is another example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- This query returns all employees along with the name of the department they\n-- belong to.\nSELECT e.*,\n       (SELECT name\n          FROM departments\n         WHERE id = e.department_id\n       ) AS employees_department\n  FROM employees e;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Query like the one above may easily be rewritten with regular ",(0,r.jsx)(n.code,{children:"JOIN"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Equivalent query to the previous example, but uses a `LEFT JOIN` instead of a\n-- correlated subquery. This rewrite is valid as long as the subquery in the original\n-- version would return at most one row.\n--\n-- If multiple rows exist in the `departments` table for the same `id`, the original\n-- scalar subquery would result in a runtime error (due to a non-scalar result), while\n-- the join version would produce duplicated rows in the output.\n--\n-- In our case, `departments.id` is a primary key, so the join is safe and will return\n-- at most one matching department per employee.\n--\n-- A `LEFT JOIN` is used to ensure that employees with no matching department are still\n-- returned. If it's guaranteed that every employee has a valid department reference,\n-- an `INNER JOIN` may be used instead, which is slightly more efficient.\nSELECT e.*,\n       d.name AS employees_department\n  FROM employees e\n  LEFT JOIN departments d ON d.id = e.department_id;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Rewritten query on the same environment finishes significantly faster."}),"\n",(0,r.jsx)(n.h3,{id:"examples-of-improved-queries",children:"Examples of Improved Queries"}),"\n",(0,r.jsx)(n.p,{children:"The first example shows how you can correctly query the database without evaluating each row:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- This query returns all employees without assigned projects.\n--\n-- Finishes in 3.2s (assuming there is an index on `assignments(employee_id)`;\n-- without the index, execution time increases significantly -- up to 12s).\nSELECT e.id, e.name\nFROM employees e\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM assignments a\n    WHERE a.employee_id = e.id\n);\n\n-- Equivalent query without correlated subqueries.\n-- Instead of evaluating a subquery for each row, we join the tables and compute\n-- the number of assignments using aggregation. It is important to include all\n-- columns that form a unique key from the outer table in the `GROUP BY` clause.\n-- Otherwise, multiple rows may be grouped together incorrectly, potentially\n-- affecting the result. If you're unsure about the uniqueness of specific columns,\n-- include all columns from the table's `PRIMARY KEY`.\n--\n-- A `LEFT JOIN` is used because we want to retain employees even when there is\n-- no matching assignment. An `INNER JOIN` would exclude those employees.\n--\n-- The `HAVING COUNT(a.employee_id) = 0` clause checks for the absence of matches.\n-- You must count a column from the right-hand side of the join that is guaranteed\n-- to be non-null. In this case, `a.employee_id` is suitable because the `JOIN`\n-- condition (`a.employee_id = e.id`) ensures that only non-null `employee_id`s\n-- are matched; nulls are excluded during the join phase.\n--\n-- Finishes in 0.04s.\nSELECT e.id, e.name\n  FROM employees e\n  LEFT JOIN assignments a ON a.employee_id = e.id\n GROUP BY e.id, e.name\nHAVING COUNT(a.employee_id) = 0;\n\n-- Similar query, but returns only employees who have at least one project assigned.\n-- Note the use of `INNER JOIN`: since we are only interested in employees with a\n-- matching assignment, an inner join is both sufficient and more efficient in this case.\n--\n-- The `HAVING COUNT(a.employee_id) > 0` condition ensures that only employees\n-- with one or more matching rows in the `assignments` table are returned.\n-- As with the previous example, `a.employee_id` is safe to count because it cannot be null\n-- due to the join condition (`a.employee_id = e.id`) filtering out nulls.\n--\n-- Finishes in 0.03s.\nSELECT e.id, e.name\n  FROM employees e\n  JOIN assignments a ON a.employee_id = e.id\n GROUP BY e.id, e.name\nHAVING COUNT(a.employee_id) > 0;\n"})}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates drastic performance improvement you can gain by improving your queries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- This query returns all employees whose salary is the minimum within their department.\n--\n-- Finishes in 18s.\nSELECT e.*\n  FROM employees e\n WHERE e.salary = (SELECT MIN(salary) FROM employees WHERE department_id = e.department_id);\n\n-- Equivalent query without a correlated subquery.\n-- Instead of comparing each employee's salary with a scalar subquery result,\n-- we precompute the minimum salary per department using a grouped subquery,\n-- and then join it back to the employees table.\n--\n-- This rewrite is safe because:\n--   - For each department, we compute the minimum salary exactly once.\n--   - The join condition ensures we only return employees whose salary matches\n--     the minimum salary for their department.\n--   - No grouping is needed on the outer query because we're performing an equality match\n--     on both `department_id` and the computed minimum salary.\n--\n-- This approach avoids per-row subquery evaluation and leverages set-based operations,\n-- which are significantly faster.\n--\n-- Finishes in 0.02s.\nSELECT e.*\n  FROM employees e\n  JOIN (\n      SELECT department_id, MIN(salary) AS min_salary\n        FROM employees\n       GROUP BY department_id\n  ) AS min_salaries_by_department\n    ON e.department_id = min_salaries_by_department.department_id\n   AND e.salary = min_salaries_by_department.min_salary;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dropping-cached-plans",children:"Dropping Cached Plans"}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"This is an experimental API."})}),"\n",(0,r.jsxs)(n.p,{children:["As optimizing the query plan is a resource-intensive operation, Apache Ignite caches the plan and reuses it for subsequent related queries. As data is updated, the plan may be outdated and require recalculation. By default, the plans expire after the period specified in the  ",(0,r.jsx)(n.code,{children:"ignite.planner.planCacheExpiresAfterSeconds"})," parameter (1800 seconds by default)."]}),"\n",(0,r.jsxs)(n.p,{children:["To force the update earlier, you can use the ",(0,r.jsx)(n.code,{children:"sql planner invalidate-cache"})," CLI tool command."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"sql planner invalidate-cache --tables=PUBLIC.Person\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);