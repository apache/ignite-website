"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7076],{28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>i});var t=s(96540);const o={},r=t.createContext(o);function d(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),t.createElement(r.Provider,{value:n},e.children)}},38964:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-reference/native-clients/cpp/network-api","title":"Network API","description":"The Network API provides access to cluster topology information. It exposes cluster node metadata used for compute job targeting and cluster monitoring.","source":"@site/docs/api-reference/native-clients/cpp/network-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/network-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/network-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/cpp/network-api.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Network API","id":"network-api","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api"},"next":{"title":"SQL-Only APIs","permalink":"/docs/ignite3/3.1.0/api-reference/sql-only-apis/"}}');var o=s(74848),r=s(28453);const d={title:"Network API",id:"network-api",sidebar_position:6},i="Network API",a={},c=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Cluster Nodes",id:"cluster-nodes",level:3},{value:"Node Identity",id:"node-identity",level:3},{value:"Network Addresses",id:"network-addresses",level:3},{value:"Cluster Node",id:"cluster-node",level:2},{value:"Node Properties",id:"node-properties",level:3},{value:"Accessing Node Information",id:"accessing-node-information",level:3},{value:"Node Comparison",id:"node-comparison",level:3},{value:"Retrieving Cluster Nodes",id:"retrieving-cluster-nodes",level:2},{value:"Synchronous Retrieval",id:"synchronous-retrieval",level:3},{value:"Asynchronous Retrieval",id:"asynchronous-retrieval",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Node Selection for Compute",id:"node-selection-for-compute",level:3},{value:"Finding Specific Nodes",id:"finding-specific-nodes",level:3},{value:"Cluster Monitoring",id:"cluster-monitoring",level:3},{value:"Broadcasting to All Nodes",id:"broadcasting-to-all-nodes",level:3},{value:"Node Filtering",id:"node-filtering",level:3},{value:"Round-Robin Selection",id:"round-robin-selection",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:2},{value:"Node Restart Impact",id:"node-restart-impact",level:3},{value:"Topology Changes",id:"topology-changes",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Network Errors",id:"network-errors",level:3},{value:"Empty Topology",id:"empty-topology",level:3},{value:"Integration with Compute API",id:"integration-with-compute-api",level:2},{value:"Job Targeting",id:"job-targeting",level:3},{value:"Node Affinity",id:"node-affinity",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Cache Topology Information",id:"cache-topology-information",level:3},{value:"Use Stable References",id:"use-stable-references",level:3},{value:"Handle Dynamic Topology",id:"handle-dynamic-topology",level:3},{value:"Reference",id:"reference",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"network-api",children:"Network API"})}),"\n",(0,o.jsx)(n.p,{children:"The Network API provides access to cluster topology information. It exposes cluster node metadata used for compute job targeting and cluster monitoring."}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(n.h3,{id:"cluster-nodes",children:"Cluster Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Cluster nodes represent individual server instances in the Ignite cluster. Each node has a unique identifier, a stable name, and network address information."}),"\n",(0,o.jsx)(n.h3,{id:"node-identity",children:"Node Identity"}),"\n",(0,o.jsx)(n.p,{children:"Nodes have two forms of identification:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node ID"})," - A UUID that changes when the node restarts"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Node Name"})," - A stable string name that persists across restarts"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Use node names for stable references. Use node IDs for runtime identification."}),"\n",(0,o.jsx)(n.h3,{id:"network-addresses",children:"Network Addresses"}),"\n",(0,o.jsx)(n.p,{children:"Each node exposes a network endpoint containing host and port information. Clients use these addresses to establish connections for operations."}),"\n",(0,o.jsx)(n.h2,{id:"cluster-node",children:"Cluster Node"}),"\n",(0,o.jsx)(n.h3,{id:"node-properties",children:"Node Properties"}),"\n",(0,o.jsx)(n.p,{children:"Cluster nodes provide three key properties:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"using namespace ignite;\n\nauto nodes = client.get_cluster_nodes();\nfor (const auto& node : nodes) {\n    // Unique ID (changes on restart)\n    uuid id = node.get_id();\n\n    // Stable name (persists across restarts)\n    std::string name = node.get_name();\n\n    // Network address\n    end_point address = node.get_address();\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"accessing-node-information",children:"Accessing Node Information"}),"\n",(0,o.jsx)(n.p,{children:"Get the node ID:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'uuid node_id = node.get_id();\nstd::cout << "Node ID: " << node_id << std::endl;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Get the node name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'std::string node_name = node.get_name();\nstd::cout << "Node: " << node_name << std::endl;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Get the network address:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'end_point addr = node.get_address();\nstd::cout << "Host: " << addr.host << std::endl;\nstd::cout << "Port: " << addr.port << std::endl;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"node-comparison",children:"Node Comparison"}),"\n",(0,o.jsx)(n.p,{children:"Cluster nodes support full comparison:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'cluster_node node1 = nodes[0];\ncluster_node node2 = nodes[1];\n\nif (node1 == node2) {\n    std::cout << "Same node" << std::endl;\n}\n\nif (node1 < node2) {\n    std::cout << "node1 sorts before node2" << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Comparison enables sorting and set operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Sort nodes by name\nstd::sort(nodes.begin(), nodes.end(),\n    [](const auto& n1, const auto& n2) {\n        return n1.get_name() < n2.get_name();\n    });\n\n// Create a set of nodes\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\n"})}),"\n",(0,o.jsx)(n.h2,{id:"retrieving-cluster-nodes",children:"Retrieving Cluster Nodes"}),"\n",(0,o.jsx)(n.h3,{id:"synchronous-retrieval",children:"Synchronous Retrieval"}),"\n",(0,o.jsx)(n.p,{children:"Get all cluster nodes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\n\nstd::cout << "Cluster has " << nodes.size() << " nodes" << std::endl;\n\nfor (const auto& node : nodes) {\n    std::cout << node.get_name() << " at "\n              << node.get_address().host << ":"\n              << node.get_address().port << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"asynchronous-retrieval",children:"Asynchronous Retrieval"}),"\n",(0,o.jsx)(n.p,{children:"Get nodes without blocking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'client.get_cluster_nodes_async([](ignite_result<std::vector<cluster_node>> result) {\n    if (!result.has_error()) {\n        auto nodes = std::move(result).value();\n        std::cout << "Found " << nodes.size() << " nodes" << std::endl;\n    } else {\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\n    }\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsx)(n.h3,{id:"node-selection-for-compute",children:"Node Selection for Compute"}),"\n",(0,o.jsx)(n.p,{children:"Select specific nodes for job execution:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\n\n// Execute on first node\nif (!nodes.empty()) {\n    auto target = job_target::node(nodes[0]);\n    auto execution = client.get_compute().submit(target, descriptor, arg);\n}\n\n// Execute on any node\nauto target = job_target::any_node(nodes);\nauto execution = client.get_compute().submit(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"finding-specific-nodes",children:"Finding Specific Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Locate nodes by name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\n\nauto it = std::find_if(nodes.begin(), nodes.end(),\n    [](const auto& node) {\n        return node.get_name() == "my-node-01";\n    });\n\nif (it != nodes.end()) {\n    cluster_node target_node = *it;\n    // Use node\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"cluster-monitoring",children:"Cluster Monitoring"}),"\n",(0,o.jsx)(n.p,{children:"Monitor cluster size:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\nsize_t cluster_size = nodes.size();\n\nif (cluster_size < 3) {\n    std::cerr << "Warning: Cluster has only " << cluster_size << " nodes" << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Track node addresses:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'std::map<std::string, end_point> node_map;\n\nfor (const auto& node : nodes) {\n    node_map[node.get_name()] = node.get_address();\n}\n\n// Check if specific node is available\nif (node_map.find("my-node-01") != node_map.end()) {\n    std::cout << "Node my-node-01 is online" << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"broadcasting-to-all-nodes",children:"Broadcasting to All Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Execute jobs on all cluster nodes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\n\nauto target = broadcast_job_target::nodes(node_set);\nauto broadcast = client.get_compute().submit_broadcast(target, descriptor, arg);\n\nauto executions = broadcast.get_job_executions();\nstd::cout << "Broadcast to " << executions.size() << " nodes" << std::endl;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"node-filtering",children:"Node Filtering"}),"\n",(0,o.jsx)(n.p,{children:"Filter nodes by criteria:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\n\n// Get nodes on specific host\nstd::vector<cluster_node> local_nodes;\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(local_nodes),\n    [](const auto& node) {\n        return node.get_address().host == "192.168.1.100";\n    });\n\n// Get nodes in port range\nstd::vector<cluster_node> dev_nodes;\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(dev_nodes),\n    [](const auto& node) {\n        return node.get_address().port >= 10800 && node.get_address().port < 10900;\n    });\n'})}),"\n",(0,o.jsx)(n.h3,{id:"round-robin-selection",children:"Round-Robin Selection"}),"\n",(0,o.jsx)(n.p,{children:"Distribute work across nodes:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\nsize_t current_index = 0;\n\nfor (const auto& task : tasks) {\n    auto target = job_target::node(nodes[current_index]);\n    compute.submit(target, descriptor, task);\n\n    current_index = (current_index + 1) % nodes.size();\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,o.jsx)(n.h3,{id:"node-restart-impact",children:"Node Restart Impact"}),"\n",(0,o.jsx)(n.p,{children:"When a node restarts:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Node ID changes to a new UUID"}),"\n",(0,o.jsx)(n.li,{children:"Node name remains the same"}),"\n",(0,o.jsx)(n.li,{children:"Network address typically remains the same"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Use node names for stable node references across restarts."}),"\n",(0,o.jsx)(n.h3,{id:"topology-changes",children:"Topology Changes"}),"\n",(0,o.jsx)(n.p,{children:"The cluster topology may change between calls:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'// Initial topology\nauto nodes1 = client.get_cluster_nodes();\nsize_t size1 = nodes1.size();\n\n// Topology may change\nstd::this_thread::sleep_for(std::chrono::seconds(10));\n\n// Updated topology\nauto nodes2 = client.get_cluster_nodes();\nsize_t size2 = nodes2.size();\n\nif (size2 != size1) {\n    std::cout << "Topology changed: "\n              << size1 << " -> " << size2 << " nodes" << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Always retrieve fresh topology information before node-specific operations."}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.h3,{id:"network-errors",children:"Network Errors"}),"\n",(0,o.jsx)(n.p,{children:"Handle connection failures:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'try {\n    auto nodes = client.get_cluster_nodes();\n} catch (const ignite_error& e) {\n    std::cerr << "Failed to get cluster nodes: " << e.what_str() << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"With async operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'client.get_cluster_nodes_async([](ignite_result<std::vector<cluster_node>> result) {\n    if (result.has_error()) {\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\n    } else {\n        auto nodes = std::move(result).value();\n        // Use nodes\n    }\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"empty-topology",children:"Empty Topology"}),"\n",(0,o.jsx)(n.p,{children:"Check for empty clusters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\n\nif (nodes.empty()) {\n    std::cerr << "Warning: No nodes available in cluster" << std::endl;\n} else {\n    // Proceed with operations\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-compute-api",children:"Integration with Compute API"}),"\n",(0,o.jsx)(n.h3,{id:"job-targeting",children:"Job Targeting"}),"\n",(0,o.jsx)(n.p,{children:"Use topology information for compute targeting:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\n\n// Target specific node\nauto target = job_target::node(nodes[0]);\n\n// Target any node from set\nauto target = job_target::any_node(nodes);\n\n// Broadcast to all nodes\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\nauto broadcast_target = broadcast_job_target::nodes(node_set);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"node-affinity",children:"Node Affinity"}),"\n",(0,o.jsx)(n.p,{children:"Select nodes based on affinity:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto nodes = client.get_cluster_nodes();\n\n// Find preferred nodes (example: local datacenter)\nstd::vector<cluster_node> preferred_nodes;\nstd::copy_if(nodes.begin(), nodes.end(), std::back_inserter(preferred_nodes),\n    [](const auto& node) {\n        return node.get_address().host.find("dc1") != std::string::npos;\n    });\n\n// Use preferred nodes for execution\nif (!preferred_nodes.empty()) {\n    auto target = job_target::any_node(preferred_nodes);\n    compute.submit(target, descriptor, arg);\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"cache-topology-information",children:"Cache Topology Information"}),"\n",(0,o.jsx)(n.p,{children:"Cache node information for short-lived operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class compute_scheduler {\n    std::vector<cluster_node> nodes_;\n    std::chrono::steady_clock::time_point last_refresh_;\n    std::chrono::seconds refresh_interval_{30};\n\npublic:\n    void maybe_refresh_topology(ignite_client& client) {\n        auto now = std::chrono::steady_clock::now();\n        if (now - last_refresh_ > refresh_interval_) {\n            nodes_ = client.get_cluster_nodes();\n            last_refresh_ = now;\n        }\n    }\n\n    std::vector<cluster_node> get_nodes() const {\n        return nodes_;\n    }\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"use-stable-references",children:"Use Stable References"}),"\n",(0,o.jsx)(n.p,{children:"Prefer node names over IDs for persistent references:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'// Good: Use node name\nstd::string target_node_name = "my-node-01";\nauto nodes = client.get_cluster_nodes();\nauto it = std::find_if(nodes.begin(), nodes.end(),\n    [&](const auto& n) { return n.get_name() == target_node_name; });\n\n// Avoid: Using node ID (changes on restart)\nuuid target_node_id = saved_id;  // May be stale after restart\n'})}),"\n",(0,o.jsx)(n.h3,{id:"handle-dynamic-topology",children:"Handle Dynamic Topology"}),"\n",(0,o.jsx)(n.p,{children:"Account for nodes joining and leaving:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'void execute_with_fallback(ignite_client& client,\n                           std::shared_ptr<job_descriptor> descriptor,\n                           const binary_object& arg) {\n    auto nodes = client.get_cluster_nodes();\n\n    if (nodes.empty()) {\n        throw ignite_error("No nodes available");\n    }\n\n    // Try first node\n    try {\n        auto target = job_target::node(nodes[0]);\n        compute.submit(target, descriptor, arg);\n    } catch (const ignite_error& e) {\n        // Fallback to any available node\n        auto target = job_target::any_node(nodes);\n        compute.submit(target, descriptor, arg);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/latest/cpp-api/",children:"C++ API Documentation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"./compute-api",children:"Compute API"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);