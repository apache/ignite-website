"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6210],{26215:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"api-reference/native-clients/java/tables-api","title":"Tables API","description":"The Tables API provides structured access to data stored in Ignite tables. Applications interact with tables through views that offer different perspectives on the data: record views for full row operations and key-value views for key-based access patterns.","source":"@site/docs/api-reference/native-clients/java/tables-api.md","sourceDirName":"api-reference/native-clients/java","slug":"/api-reference/native-clients/java/tables-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/tables-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/java/tables-api.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Tables API","id":"tables-api","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Server API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/server-api"},"next":{"title":"Data Streamer API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/java/data-streamer-api"}}');var a=l(74848),t=l(28453);const s={title:"Tables API",id:"tables-api",sidebar_position:3},r="Tables API",c={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Table Discovery",id:"table-discovery",level:2},{value:"Record View",id:"record-view",level:2},{value:"Typed Record View",id:"typed-record-view",level:2},{value:"Key-Value View",id:"key-value-view",level:2},{value:"Typed Key-Value View",id:"typed-key-value-view",level:2},{value:"Batch Operations",id:"batch-operations",level:2},{value:"Key-Value Batch Operations",id:"key-value-batch-operations",level:2},{value:"Conditional Operations",id:"conditional-operations",level:2},{value:"Asynchronous Operations",id:"asynchronous-operations",level:2},{value:"Partition Information",id:"partition-information",level:2},{value:"Tuple Construction",id:"tuple-construction",level:2},{value:"Tuple Value Access",id:"tuple-value-access",level:2},{value:"Reference",id:"reference",level:2},{value:"IgniteTables Methods",id:"ignitetables-methods",level:3},{value:"Table View Methods",id:"table-view-methods",level:3},{value:"RecordView CRUD Methods",id:"recordview-crud-methods",level:3},{value:"KeyValueView Methods",id:"keyvalueview-methods",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"tables-api",children:"Tables API"})}),"\n",(0,a.jsx)(n.p,{children:"The Tables API provides structured access to data stored in Ignite tables. Applications interact with tables through views that offer different perspectives on the data: record views for full row operations and key-value views for key-based access patterns."}),"\n",(0,a.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,a.jsx)(n.p,{children:"Tables store data in rows with typed columns. The API provides three access patterns through views. RecordView treats each row as a complete record. KeyValueView separates rows into key and value portions. Both support binary Tuple access and typed object mapping."}),"\n",(0,a.jsx)(n.p,{children:"Operations execute within optional transaction contexts. Pass null for auto-commit behavior or provide a Transaction for multi-operation atomicity."}),"\n",(0,a.jsx)(n.h2,{id:"table-discovery",children:"Table Discovery"}),"\n",(0,a.jsx)(n.p,{children:"Access tables through the tables manager:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'Table users = ignite.tables().table("users");\nif (users == null) {\n    System.out.println("Table does not exist");\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"For qualified names with schemas:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'Table products = ignite.tables().table(QualifiedName.of("inventory", "products"));\n'})}),"\n",(0,a.jsx)(n.p,{children:"List all tables asynchronously:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"CompletableFuture<List<Table>> tablesFuture = ignite.tables().tablesAsync();\ntablesFuture.thenAccept(tables -> {\n    for (Table table : tables) {\n        System.out.println(table.name());\n    }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"record-view",children:"Record View"}),"\n",(0,a.jsx)(n.p,{children:"RecordView operations work with complete rows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\n\n// Insert or update\nTuple record = Tuple.create()\n    .set("id", 1)\n    .set("name", "Alice")\n    .set("age", 30);\nview.upsert(null, record);\n\n// Retrieve\nTuple key = Tuple.create().set("id", 1);\nTuple result = view.get(null, key);\nSystem.out.println(result.stringValue("name"));\n\n// Check existence\nboolean exists = view.contains(null, key);\n\n// Delete\nboolean deleted = view.delete(null, key);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Pass null as the transaction parameter for operations outside transactions."}),"\n",(0,a.jsx)(n.h2,{id:"typed-record-view",children:"Typed Record View"}),"\n",(0,a.jsx)(n.p,{children:"Map rows to Java objects using typed views:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class User {\n    public int id;\n    public String name;\n    public int age;\n}\n\nRecordView<User> view = table.recordView(User.class);\n\nUser user = new User();\nuser.id = 1;\nuser.name = "Alice";\nuser.age = 30;\n\nview.upsert(null, user);\n\nUser key = new User();\nkey.id = 1;\nUser retrieved = view.get(null, key);\n'})}),"\n",(0,a.jsx)(n.p,{children:"The view automatically maps between object fields and table columns."}),"\n",(0,a.jsx)(n.h2,{id:"key-value-view",children:"Key-Value View"}),"\n",(0,a.jsx)(n.p,{children:"KeyValueView separates key and value portions:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\n\nTuple key = Tuple.create().set("id", 1);\nTuple value = Tuple.create()\n    .set("name", "Alice")\n    .set("age", 30);\n\nview.put(null, key, value);\n\nTuple retrieved = view.get(null, key);\nSystem.out.println(retrieved.stringValue("name"));\n\n// Check for null vs missing\nNullableValue<Tuple> nullable = view.getNullable(null, key);\nif (nullable != null) {\n    System.out.println("Found: " + nullable.get());\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"NullableValue distinguishes between missing entries and entries with null values."}),"\n",(0,a.jsx)(n.h2,{id:"typed-key-value-view",children:"Typed Key-Value View"}),"\n",(0,a.jsx)(n.p,{children:"Map keys and values to separate types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'public class ProductKey {\n    public int id;\n}\n\npublic class ProductValue {\n    public String name;\n    public double price;\n}\n\nKeyValueView<ProductKey, ProductValue> view =\n    table.keyValueView(ProductKey.class, ProductValue.class);\n\nProductKey key = new ProductKey();\nkey.id = 100;\n\nProductValue value = new ProductValue();\nvalue.name = "Widget";\nvalue.price = 29.99;\n\nview.put(null, key, value);\n\nProductValue retrieved = view.get(null, key);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,a.jsx)(n.p,{children:"Process multiple records in single operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\n\nList<Tuple> records = Arrays.asList(\n    Tuple.create().set("id", 1).set("name", "Alice"),\n    Tuple.create().set("id", 2).set("name", "Bob"),\n    Tuple.create().set("id", 3).set("name", "Carol")\n);\n\nview.upsertAll(null, records);\n\nList<Tuple> keys = Arrays.asList(\n    Tuple.create().set("id", 1),\n    Tuple.create().set("id", 2)\n);\n\nList<Tuple> results = view.getAll(null, keys);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Batch operations reduce network overhead for multiple operations."}),"\n",(0,a.jsx)(n.h2,{id:"key-value-batch-operations",children:"Key-Value Batch Operations"}),"\n",(0,a.jsx)(n.p,{children:"Similar batch support for key-value views:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\n\nMap<Tuple, Tuple> entries = new HashMap<>();\nentries.put(\n    Tuple.create().set("id", 1),\n    Tuple.create().set("name", "Alice")\n);\nentries.put(\n    Tuple.create().set("id", 2),\n    Tuple.create().set("name", "Bob")\n);\n\nview.putAll(null, entries);\n\nCollection<Tuple> keys = Arrays.asList(\n    Tuple.create().set("id", 1),\n    Tuple.create().set("id", 2)\n);\n\nMap<Tuple, Tuple> results = view.getAll(null, keys);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conditional-operations",children:"Conditional Operations"}),"\n",(0,a.jsx)(n.p,{children:"Execute operations based on current values:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'KeyValueView<Tuple, Tuple> view = table.keyValueView();\n\nTuple key = Tuple.create().set("id", 1);\nTuple oldValue = Tuple.create().set("status", "pending");\nTuple newValue = Tuple.create().set("status", "active");\n\n// Replace only if current value matches\nboolean replaced = view.replace(null, key, oldValue, newValue);\n\nif (replaced) {\n    System.out.println("Value updated");\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Conditional operations provide atomic compare-and-set semantics."}),"\n",(0,a.jsx)(n.h2,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,a.jsx)(n.p,{children:"All operations support asynchronous execution:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'RecordView<Tuple> view = table.recordView();\n\nTuple record = Tuple.create()\n    .set("id", 1)\n    .set("name", "Alice");\n\nCompletableFuture<Void> upsertFuture = view.upsertAsync(null, record);\n\nTuple key = Tuple.create().set("id", 1);\nCompletableFuture<Tuple> getFuture = view.getAsync(null, key);\n\ngetFuture.thenAccept(result -> {\n    System.out.println(result.stringValue("name"));\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"Asynchronous operations return immediately without blocking the calling thread."}),"\n",(0,a.jsx)(n.h2,{id:"partition-information",children:"Partition Information"}),"\n",(0,a.jsx)(n.p,{children:"Access partition metadata through the partition manager:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'PartitionManager partitions = table.partitionManager();\nCompletableFuture<Partition> partition =\n    partitions.partitionAsync(Tuple.create().set("id", 1));\n\npartition.thenAccept(p -> {\n    System.out.println("Record belongs to partition: " + p.id());\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"Partition information enables colocated compute operations."}),"\n",(0,a.jsx)(n.h2,{id:"tuple-construction",children:"Tuple Construction"}),"\n",(0,a.jsx)(n.p,{children:"Create tuples with various approaches:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Empty tuple\nTuple tuple1 = Tuple.create();\n\n// With capacity hint\nTuple tuple2 = Tuple.create(10);\n\n// From map\nMap<String, Object> data = new HashMap<>();\ndata.put("id", 1);\ndata.put("name", "Alice");\nTuple tuple3 = Tuple.create(data);\n\n// Copy existing\nTuple tuple4 = Tuple.copy(tuple3);\n'})}),"\n",(0,a.jsx)(n.p,{children:"Set values by name:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'Tuple tuple = Tuple.create()\n    .set("id", 1)\n    .set("name", "Alice")\n    .set("age", 30)\n    .set("balance", 1000.50)\n    .set("created", LocalDateTime.now());\n'})}),"\n",(0,a.jsx)(n.h2,{id:"tuple-value-access",children:"Tuple Value Access"}),"\n",(0,a.jsx)(n.p,{children:"Retrieve values by column name with type-specific methods:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'int id = tuple.intValue("id");\nString name = tuple.stringValue("name");\nInteger age = tuple.value("age");\nLocalDateTime created = tuple.value("created");\n\n// Access by index\nObject value = tuple.value(0);\nString columnName = tuple.columnName(0);\nint columnIndex = tuple.columnIndex("name");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Type-specific accessors avoid boxing for primitive types."}),"\n",(0,a.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Table management: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.IgniteTables"})]}),"\n",(0,a.jsxs)(n.li,{children:["Table interface: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.Table"})]}),"\n",(0,a.jsxs)(n.li,{children:["Record access: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.RecordView<R>"})]}),"\n",(0,a.jsxs)(n.li,{children:["Key-value access: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.KeyValueView<K, V>"})]}),"\n",(0,a.jsxs)(n.li,{children:["Binary records: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.Tuple"})]}),"\n",(0,a.jsxs)(n.li,{children:["Partition info: ",(0,a.jsx)(n.code,{children:"org.apache.ignite.table.partition.PartitionManager"})]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"ignitetables-methods",children:"IgniteTables Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"List<Table> tables()"})," - Get all tables synchronously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<List<Table>> tablesAsync()"})," - Get all tables asynchronously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Table table(String name)"})," - Get table by simple name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Table table(QualifiedName name)"})," - Get table by qualified name"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<Table> tableAsync(String name)"})," - Get table asynchronously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<Table> tableAsync(QualifiedName name)"})," - Get table asynchronously with qualified name"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"table-view-methods",children:"Table View Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"RecordView<Tuple> recordView()"})," - Get binary record view"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"RecordView<R> recordView(Class<R>)"})," - Get typed record view"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"RecordView<R> recordView(Mapper<R>)"})," - Get record view with custom mapper"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"KeyValueView<Tuple, Tuple> keyValueView()"})," - Get binary key-value view"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"KeyValueView<K, V> keyValueView(Class<K>, Class<V>)"})," - Get typed key-value view"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"KeyValueView<K, V> keyValueView(Mapper<K>, Mapper<V>)"})," - Get key-value view with custom mappers"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"recordview-crud-methods",children:"RecordView CRUD Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"R get(Transaction, R keyRec)"})," - Get record by key"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<R> getAsync(Transaction, R keyRec)"})," - Async get"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"List<R> getAll(Transaction, Collection<R>)"})," - Get multiple records"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<List<R>> getAllAsync(Transaction, Collection<R>)"})," - Async get multiple"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"boolean contains(Transaction, R keyRec)"})," - Check existence"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void upsert(Transaction, R rec)"})," - Insert or update record"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<Void> upsertAsync(Transaction, R rec)"})," - Async upsert"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void upsertAll(Transaction, Collection<R>)"})," - Insert or update multiple"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"boolean delete(Transaction, R keyRec)"})," - Delete record"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<Boolean> deleteAsync(Transaction, R keyRec)"})," - Async delete"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"keyvalueview-methods",children:"KeyValueView Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"V get(Transaction, K key)"})," - Get value by key"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<V> getAsync(Transaction, K key)"})," - Async get"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NullableValue<V> getNullable(Transaction, K key)"})," - Get with null distinction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Map<K, V> getAll(Transaction, Collection<K>)"})," - Get multiple values"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void put(Transaction, K key, V value)"})," - Put key-value pair"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CompletableFuture<Void> putAsync(Transaction, K key, V value)"})," - Async put"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void putAll(Transaction, Map<K, V>)"})," - Put multiple pairs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"boolean replace(Transaction, K key, V old, V new)"})," - Conditional replace"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void remove(Transaction, K key)"})," - Remove by key"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"void removeAll(Transaction, Collection<K>)"})," - Remove multiple"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,l)=>{l.d(n,{R:()=>s,x:()=>r});var i=l(96540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);