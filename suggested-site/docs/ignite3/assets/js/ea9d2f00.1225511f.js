"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4690],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},41453:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"api-reference/native-clients/java/compute-api","title":"Compute API","description":"The Compute API executes custom code on cluster nodes. Applications submit jobs that run on selected nodes and return results. This enables data-local processing, distributed algorithms, and workload distribution across the cluster.","source":"@site/docs/api-reference/native-clients/java/compute-api.md","sourceDirName":"api-reference/native-clients/java","slug":"/api-reference/native-clients/java/compute-api","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/compute-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/java/compute-api.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Compute API","id":"compute-api","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Transactions API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/transactions-api"},"next":{"title":"Catalog API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/catalog-api"}}');var i=t(74848),r=t(28453);const s={title:"Compute API",id:"compute-api",sidebar_position:7},c="Compute API",l={},a=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Job Implementation",id:"job-implementation",level:2},{value:"Job Submission",id:"job-submission",level:2},{value:"Job Targets",id:"job-targets",level:2},{value:"Colocated Execution",id:"colocated-execution",level:2},{value:"Job Context",id:"job-context",level:2},{value:"Job Cancellation",id:"job-cancellation",level:2},{value:"Cancellation Tokens",id:"cancellation-tokens",level:2},{value:"Job Priority",id:"job-priority",level:2},{value:"Job Status",id:"job-status",level:2},{value:"Broadcast Execution",id:"broadcast-execution",level:2},{value:"Broadcast Results Collection",id:"broadcast-results-collection",level:2},{value:"Deployment Units",id:"deployment-units",level:2},{value:"Custom Serialization",id:"custom-serialization",level:2},{value:"Map-Reduce Tasks",id:"map-reduce-tasks",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Reference",id:"reference",level:2},{value:"IgniteCompute Methods",id:"ignitecompute-methods",level:3},{value:"JobExecution Methods",id:"jobexecution-methods",level:3},{value:"JobTarget Factory Methods",id:"jobtarget-factory-methods",level:3},{value:"BroadcastJobTarget Factory Methods",id:"broadcastjobtarget-factory-methods",level:3},{value:"JobExecutionContext Methods",id:"jobexecutioncontext-methods",level:3},{value:"BroadcastExecution Methods",id:"broadcastexecution-methods",level:3},{value:"ComputeJob Interface",id:"computejob-interface",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"compute-api",children:"Compute API"})}),"\n",(0,i.jsx)(n.p,{children:"The Compute API executes custom code on cluster nodes. Applications submit jobs that run on selected nodes and return results. This enables data-local processing, distributed algorithms, and workload distribution across the cluster."}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.p,{children:"Compute jobs implement the ComputeJob interface. Job descriptors identify which class to execute and where to find it. Job targets specify execution location using strategies like specific nodes, any available node, or colocated with table partitions."}),"\n",(0,i.jsx)(n.p,{children:"Jobs execute asynchronously and return JobExecution handles. Use these handles to retrieve results, monitor status, cancel execution, or adjust priority. Broadcast jobs execute on multiple nodes and aggregate results."}),"\n",(0,i.jsx)(n.h2,{id:"job-implementation",children:"Job Implementation"}),"\n",(0,i.jsx)(n.p,{children:"Implement ComputeJob for custom processing:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class WordCountJob implements ComputeJob<String, Integer> {\n    @Override\n    public CompletableFuture<Integer> executeAsync(\n        JobExecutionContext context,\n        String text\n    ) {\n        int count = text.split("\\\\s+").length;\n        return CompletableFuture.completedFuture(count);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Jobs receive execution context and arguments. Return CompletableFuture for asynchronous processing."}),"\n",(0,i.jsx)(n.h2,{id:"job-submission",children:"Job Submission"}),"\n",(0,i.jsx)(n.p,{children:"Submit jobs with descriptors and targets:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'JobDescriptor<String, Integer> descriptor =\n    JobDescriptor.builder("com.example.WordCountJob").build();\n\nCompletableFuture<JobExecution<Integer>> executionFuture =\n    ignite.compute().submitAsync(\n        JobTarget.anyNode(ignite.clusterNodes()),\n        descriptor,\n        "the quick brown fox"\n    );\n\nInteger result = executionFuture\n    .thenCompose(JobExecution::resultAsync)\n    .join();\n\nSystem.out.println("Word count: " + result);\n'})}),"\n",(0,i.jsx)(n.p,{children:"The submitAsync method returns immediately while the job executes on the target node."}),"\n",(0,i.jsx)(n.h2,{id:"job-targets",children:"Job Targets"}),"\n",(0,i.jsx)(n.p,{children:"Target specific execution locations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Execute on specific node\nClusterNode node = ignite.cluster().localNode();\nJobTarget target = JobTarget.node(node);\n\n// Execute on any node from set\nCollection<ClusterNode> nodes = ignite.clusterNodes();\nJobTarget target = JobTarget.anyNode(nodes);\n\n// Execute on all nodes (broadcast)\nBroadcastJobTarget target = BroadcastJobTarget.nodes(nodes);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Choose targets based on workload characteristics and data locality requirements."}),"\n",(0,i.jsx)(n.h2,{id:"colocated-execution",children:"Colocated Execution"}),"\n",(0,i.jsx)(n.p,{children:"Execute jobs colocated with data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'JobDescriptor<Integer, String> descriptor =\n    JobDescriptor.builder("com.example.DataProcessor").build();\n\nTuple key = Tuple.create().set("id", 100);\nQualifiedName tableName = QualifiedName.of("products");\n\nJobTarget target = JobTarget.colocated(tableName, key, Mapper.of(Tuple.class));\n\nCompletableFuture<JobExecution<String>> execution =\n    ignite.compute().submitAsync(target, descriptor, 100);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Colocated execution eliminates network overhead by running jobs on nodes that store the data."}),"\n",(0,i.jsx)(n.h2,{id:"job-context",children:"Job Context"}),"\n",(0,i.jsx)(n.p,{children:"Access cluster resources within jobs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class DataProcessorJob implements ComputeJob<Integer, String> {\n    @Override\n    public CompletableFuture<String> executeAsync(\n        JobExecutionContext context,\n        Integer productId\n    ) {\n        Ignite ignite = context.ignite();\n        Table table = ignite.tables().table("products");\n        RecordView<Tuple> view = table.recordView();\n\n        Tuple key = Tuple.create().set("id", productId);\n        Tuple record = view.get(null, key);\n\n        return CompletableFuture.completedFuture(\n            record.stringValue("name")\n        );\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"JobExecutionContext provides access to the Ignite instance, partition information, deployment units, and cancellation status."}),"\n",(0,i.jsx)(n.h2,{id:"job-cancellation",children:"Job Cancellation"}),"\n",(0,i.jsx)(n.p,{children:"Cancel running jobs using CancellationToken:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'CancelHandle cancelHandle = CancelHandle.create();\n\nCompletableFuture<JobExecution<Integer>> executionFuture =\n    ignite.compute().submitAsync(\n        target,\n        descriptor,\n        input,\n        cancelHandle.token()\n    );\n\n// Cancel the job\ncancelHandle.cancel();\nSystem.out.println("Cancellation requested");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Cancelled jobs stop execution and release resources. Check cancellation status within job implementation using context.isCancelled()."}),"\n",(0,i.jsx)(n.h2,{id:"cancellation-tokens",children:"Cancellation Tokens"}),"\n",(0,i.jsx)(n.p,{children:"Respond to cancellation within jobs:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class CancellableJob implements ComputeJob<String, Integer> {\n    @Override\n    public CompletableFuture<Integer> executeAsync(\n        JobExecutionContext context,\n        String input\n    ) {\n        return CompletableFuture.supplyAsync(() -> {\n            int count = 0;\n            for (String word : input.split("\\\\s+")) {\n                if (context.isCancelled()) {\n                    throw new CancellationException("Job cancelled");\n                }\n                count++;\n            }\n            return count;\n        });\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Check cancellation status periodically during long-running operations."}),"\n",(0,i.jsx)(n.h2,{id:"job-priority",children:"Job Priority"}),"\n",(0,i.jsx)(n.p,{children:"Adjust job priority dynamically:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'JobExecution<Integer> execution = executionFuture.join();\n\nexecution.changePriorityAsync(10).thenAccept(changed -> {\n    if (changed) {\n        System.out.println("Priority updated");\n    }\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Higher priority jobs execute before lower priority jobs in the queue."}),"\n",(0,i.jsx)(n.h2,{id:"job-status",children:"Job Status"}),"\n",(0,i.jsx)(n.p,{children:"Monitor job execution status:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'JobExecution<Integer> execution = executionFuture.join();\n\nexecution.stateAsync().thenAccept(state -> {\n    System.out.println("Job state: " + state);\n});\n\nexecution.idAsync().thenAccept(id -> {\n    System.out.println("Job ID: " + id);\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Job states include queued, executing, completed, cancelled, and failed."}),"\n",(0,i.jsx)(n.h2,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,i.jsx)(n.p,{children:"Execute jobs on multiple nodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'JobDescriptor<String, Integer> descriptor =\n    JobDescriptor.builder("com.example.MetricsCollector").build();\n\nCollection<ClusterNode> nodes = ignite.clusterNodes();\n\nCompletableFuture<BroadcastExecution<Integer>> broadcastFuture =\n    ignite.compute().submitAsync(\n        BroadcastJobTarget.nodes(nodes),\n        descriptor,\n        "collect"\n    );\n\nBroadcastExecution<Integer> broadcast = broadcastFuture.join();\n\n// Get individual job executions by node\nMap<ClusterNode, JobExecution<Integer>> executions = broadcast.executions();\n\nfor (Map.Entry<ClusterNode, JobExecution<Integer>> entry : executions.entrySet()) {\n    Integer result = entry.getValue().resultAsync().join();\n    System.out.println("Node " + entry.getKey().name() + ": " + result);\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Broadcast execution returns results from all target nodes."}),"\n",(0,i.jsx)(n.h2,{id:"broadcast-results-collection",children:"Broadcast Results Collection"}),"\n",(0,i.jsx)(n.p,{children:"Access all broadcast results asynchronously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'BroadcastExecution<Integer> broadcast = broadcastFuture.join();\n\nCompletableFuture<List<Integer>> allResults = broadcast.resultsAsync();\n\nList<Integer> values = allResults.join();\n\nint total = values.stream().mapToInt(Integer::intValue).sum();\nSystem.out.println("Total: " + total);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"deployment-units",children:"Deployment Units"}),"\n",(0,i.jsx)(n.p,{children:"Reference jobs from deployment units:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'DeploymentUnit unit = new DeploymentUnit("my-jobs", "1.0.0");\n\nJobDescriptor<String, Integer> descriptor =\n    JobDescriptor.builder("com.example.CustomJob")\n        .units(unit)\n        .build();\n\nCompletableFuture<JobExecution<Integer>> execution =\n    ignite.compute().submitAsync(target, descriptor, "input");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Deployment units enable versioned job deployment and isolation."}),"\n",(0,i.jsx)(n.h2,{id:"custom-serialization",children:"Custom Serialization"}),"\n",(0,i.jsx)(n.p,{children:"Implement custom marshallers for job arguments and results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class CustomJob implements ComputeJob<MyData, MyResult> {\n    @Override\n    public CompletableFuture<MyResult> executeAsync(\n        JobExecutionContext context,\n        MyData input\n    ) {\n        // Process input\n        return CompletableFuture.completedFuture(new MyResult());\n    }\n\n    @Override\n    public Marshaller<MyData, byte[]> inputMarshaller() {\n        return new MyDataMarshaller();\n    }\n\n    @Override\n    public Marshaller<MyResult, byte[]> resultMarshaller() {\n        return new MyResultMarshaller();\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Custom marshallers control serialization for non-standard types."}),"\n",(0,i.jsx)(n.h2,{id:"map-reduce-tasks",children:"Map-Reduce Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Execute map-reduce computations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class WordCountTask implements MapReduceTask<String, String, Map<String, Integer>, Map<String, Integer>> {\n    @Override\n    public String name() {\n        return "word-count";\n    }\n\n    @Override\n    public CompletableFuture<List<MapReduceJob<String, Map<String, Integer>>>>\n        splitAsync(TaskExecutionContext context, String input) {\n\n        List<MapReduceJob<String, Map<String, Integer>>> jobs = new ArrayList<>();\n        String[] lines = input.split("\\n");\n\n        for (String line : lines) {\n            jobs.add(new WordCountJob(line));\n        }\n\n        return CompletableFuture.completedFuture(jobs);\n    }\n\n    @Override\n    public CompletableFuture<Map<String, Integer>> reduceAsync(\n        TaskExecutionContext context,\n        List<Map<String, Integer>> results\n    ) {\n        Map<String, Integer> combined = new HashMap<>();\n        for (Map<String, Integer> result : results) {\n            result.forEach((word, count) ->\n                combined.merge(word, count, Integer::sum)\n            );\n        }\n        return CompletableFuture.completedFuture(combined);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Submit map-reduce tasks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'TaskDescriptor<String, Map<String, Integer>> taskDescriptor =\n    TaskDescriptor.builder(new WordCountTask()).build();\n\nCompletableFuture<JobExecution<Map<String, Integer>>> execution =\n    ignite.compute().executeMapReduceAsync(\n        taskDescriptor,\n        "line one\\nline two\\nline three"\n    );\n\nMap<String, Integer> wordCounts = execution\n    .thenCompose(JobExecution::resultAsync)\n    .join();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Handle compute exceptions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'try {\n    JobExecution<Integer> execution = executionFuture.join();\n    Integer result = execution.resultAsync().join();\n} catch (CompletionException e) {\n    if (e.getCause() instanceof ComputeException) {\n        System.err.println("Compute error: " + e.getCause().getMessage());\n    } else if (e.getCause() instanceof NodeNotFoundException) {\n        System.err.println("Target node not found");\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Compute facade: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.IgniteCompute"})]}),"\n",(0,i.jsxs)(n.li,{children:["Job interface: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.ComputeJob<T, R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Job execution: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.JobExecution<R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Job targeting: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.JobTarget"})]}),"\n",(0,i.jsxs)(n.li,{children:["Job descriptor: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.JobDescriptor<T, R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Job context: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.JobExecutionContext"})]}),"\n",(0,i.jsxs)(n.li,{children:["Broadcast execution: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.BroadcastExecution<R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Map-reduce: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.task.MapReduceTask<I, M, T, R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Task descriptor: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.compute.task.TaskDescriptor<I, R>"})]}),"\n",(0,i.jsxs)(n.li,{children:["Deployment: ",(0,i.jsx)(n.code,{children:"org.apache.ignite.deployment.DeploymentUnit"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"ignitecompute-methods",children:"IgniteCompute Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<T, R> CompletableFuture<JobExecution<R>> submitAsync(JobTarget, JobDescriptor<T, R>, T)"})," - Submit job"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<T, R> CompletableFuture<JobExecution<R>> submitAsync(JobTarget, JobDescriptor<T, R>, T, CancellationToken)"})," - Submit with cancellation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<T, R> CompletableFuture<BroadcastExecution<R>> submitAsync(BroadcastJobTarget, JobDescriptor<T, R>, T)"})," - Submit broadcast"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"<T, R> CompletableFuture<JobExecution<R>> executeMapReduceAsync(TaskDescriptor<T, R>, T)"})," - Execute map-reduce"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"jobexecution-methods",children:"JobExecution Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<R> resultAsync()"})," - Get job result"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<JobState> stateAsync()"})," - Get job state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<UUID> idAsync()"})," - Get job ID"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<Boolean> changePriorityAsync(int)"})," - Change priority"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"jobtarget-factory-methods",children:"JobTarget Factory Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"static JobTarget node(ClusterNode)"})," - Target specific node"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"static JobTarget anyNode(ClusterNode...)"})," - Target any from set"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"static JobTarget colocated(QualifiedName, Object, Mapper)"})," - Target colocated with data"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"broadcastjobtarget-factory-methods",children:"BroadcastJobTarget Factory Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"static BroadcastJobTarget nodes(Collection<ClusterNode>)"})," - Target all specified nodes"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"jobexecutioncontext-methods",children:"JobExecutionContext Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Ignite ignite()"})," - Get Ignite instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"boolean isCancelled()"})," - Check if job is cancelled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"int partition()"})," - Get partition number for colocated jobs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"List<DeploymentUnit> deploymentUnits()"})," - Get deployment units"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"broadcastexecution-methods",children:"BroadcastExecution Methods"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Map<ClusterNode, JobExecution<R>> executions()"})," - Get job executions by node"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<List<R>> resultsAsync()"})," - Get all results asynchronously"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"computejob-interface",children:"ComputeJob Interface"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CompletableFuture<R> executeAsync(JobExecutionContext, T)"})," - Execute job"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Marshaller<T, byte[]> inputMarshaller()"})," - Custom input serialization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Marshaller<R, byte[]> resultMarshaller()"})," - Custom result serialization"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);