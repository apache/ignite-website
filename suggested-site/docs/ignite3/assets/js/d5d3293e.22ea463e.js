"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9298],{16711:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"understand/core-concepts/distribution-and-colocation","title":"Distribution and Colocation","description":"Data distribution determines how Ignite spreads data across cluster nodes. Colocation ensures related data resides on the same nodes, enabling efficient joins and transactions without cross-node data movement.","source":"@site/docs/understand/core-concepts/distribution-and-colocation.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/distribution-and-colocation","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/distribution-and-colocation","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/understand/core-concepts/distribution-and-colocation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"distribution-and-colocation","title":"Distribution and Colocation","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Transactions and MVCC","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/transactions-and-mvcc"},"next":{"title":"Data Partitioning","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/data-partitioning"}}');var t=i(74848),r=i(28453);const o={id:"distribution-and-colocation",title:"Distribution and Colocation",sidebar_position:4},a=void 0,d={},l=[{value:"Distribution Zones",id:"distribution-zones",level:2},{value:"Partitioning",id:"partitioning",level:2},{value:"Rendezvous Hashing",id:"rendezvous-hashing",level:3},{value:"Partition Count Guidelines",id:"partition-count-guidelines",level:3},{value:"Replication",id:"replication",level:2},{value:"Consensus Groups",id:"consensus-groups",level:3},{value:"Quorum Requirements",id:"quorum-requirements",level:3},{value:"Primary Replicas and Leases",id:"primary-replicas-and-leases",level:2},{value:"Data Colocation",id:"data-colocation",level:2},{value:"Colocation Keys",id:"colocation-keys",level:3},{value:"Colocation Requirements",id:"colocation-requirements",level:3},{value:"Query Optimization",id:"query-optimization",level:3},{value:"Partition Rebalancing",id:"partition-rebalancing",level:2},{value:"Node Filtering",id:"node-filtering",level:2},{value:"Design Constraints",id:"design-constraints",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Data distribution determines how Ignite spreads data across cluster nodes. Colocation ensures related data resides on the same nodes, enabling efficient joins and transactions without cross-node data movement."}),"\n",(0,t.jsx)(n.h2,{id:"distribution-zones",children:"Distribution Zones"}),"\n",(0,t.jsx)(n.p,{children:"A distribution zone defines the rules for data placement across the cluster. Each table belongs to exactly one distribution zone that controls:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Number of partitions"}),"\n",(0,t.jsx)(n.li,{children:"Replication factor"}),"\n",(0,t.jsx)(n.li,{children:"Which nodes can store data"}),"\n",(0,t.jsx)(n.li,{children:"Scale-up and scale-down behavior"}),"\n"]}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Distribution Zone: zone1"\n        direction TB\n        Config["Configuration<br/>PARTITIONS: 25<br/>REPLICAS: 3"]\n\n        subgraph "Node Selection"\n            Filter["DATA_NODES_FILTER"]\n            Nodes["Eligible Nodes"]\n        end\n\n        subgraph "Tables"\n            T1[accounts]\n            T2[transactions]\n            T3[balances]\n        end\n    end\n\n    Config --\x3e Filter\n    Filter --\x3e Nodes\n    Nodes --\x3e T1 & T2 & T3'}),"\n",(0,t.jsx)(n.p,{children:"Create a distribution zone:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE ZONE my_zone WITH\n    PARTITIONS = 25,\n    REPLICAS = 3,\n    DATA_NODES_FILTER = '$[?(@.region == \"us-east\")]',\n    DATA_NODES_AUTO_ADJUST_SCALE_UP = 300,\n    DATA_NODES_AUTO_ADJUST_SCALE_DOWN = 600\n    STORAGE_PROFILES = 'default';\n"})}),"\n",(0,t.jsx)(n.h2,{id:"partitioning",children:"Partitioning"}),"\n",(0,t.jsxs)(n.p,{children:["When a table is created, its data is divided into partitions based on the zone configuration. Each partition is identified by a number from 0 to ",(0,t.jsx)(n.code,{children:"PARTITIONS - 1"}),"."]}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Table: accounts"\n        D[Data]\n    end\n\n    subgraph "Partitions"\n        P0[Partition 0]\n        P1[Partition 1]\n        P2[Partition 2]\n        PN[Partition N]\n    end\n\n    D --\x3e|"hash(key) mod N"| P0 & P1 & P2 & PN'}),"\n",(0,t.jsx)(n.h3,{id:"rendezvous-hashing",children:"Rendezvous Hashing"}),"\n",(0,t.jsx)(n.p,{children:"Ignite uses rendezvous hashing (Highest Random Weight) to assign partitions to nodes. For each partition, the algorithm:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Computes a hash combining each node's ID with the partition number"}),"\n",(0,t.jsx)(n.li,{children:"Sorts nodes by their hash value in descending order"}),"\n",(0,t.jsx)(n.li,{children:"Assigns the partition to nodes with the highest scores"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach provides:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deterministic placement"}),": The same partition always maps to the same nodes given the same cluster topology"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimal rebalancing"}),": Adding or removing nodes affects only partitions that must move"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stable ordering"}),": Consistent replica orderings across all nodes"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"partition-count-guidelines",children:"Partition Count Guidelines"}),"\n",(0,t.jsx)(n.p,{children:"Set partition count based on cluster size and available cores:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"recommended_partitions = (node_count * cores_per_node * 2) / replica_count\n"})}),"\n",(0,t.jsx)(n.p,{children:"Examples:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"3 nodes, 8 cores each, 3 replicas: 16 to 32 partitions"}),"\n",(0,t.jsx)(n.li,{children:"7 nodes, 16 cores each, 3 replicas: 75 to 150 partitions"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The maximum partition count is 65,000 per table. Using significantly more partitions than recommended creates overhead from partition management and distribution tracking."}),"\n",(0,t.jsx)(n.h2,{id:"replication",children:"Replication"}),"\n",(0,t.jsxs)(n.p,{children:["Each partition is replicated across multiple nodes for fault tolerance. The ",(0,t.jsx)(n.code,{children:"REPLICAS"})," parameter controls how many copies exist."]}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Partition 0 Replication"\n        subgraph "Node A"\n            R1["Replica 1<br/>(Primary)"]\n        end\n        subgraph "Node B"\n            R2["Replica 2<br/>(Peer)"]\n        end\n        subgraph "Node C"\n            R3["Replica 3<br/>(Peer)"]\n        end\n    end\n\n    R1 <--\x3e|"Raft<br/>Consensus"| R2\n    R1 <--\x3e|"Raft<br/>Consensus"| R3\n    R2 <--\x3e|"Raft<br/>Consensus"| R3'}),"\n",(0,t.jsx)(n.h3,{id:"consensus-groups",children:"Consensus Groups"}),"\n",(0,t.jsx)(n.p,{children:"Replicas form a Raft consensus group. The group has two member types:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Role"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Peers"})}),(0,t.jsx)(n.td,{children:"Vote on writes, contribute to quorum, can become primary"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Learners"})}),(0,t.jsx)(n.td,{children:"Receive data asynchronously, cannot vote, used for read scaling"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The consensus group size determines how many peers participate in voting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"consensus_group_size = (quorum_size * 2) - 1\n"})}),"\n",(0,t.jsx)(n.p,{children:"For 5 replicas with quorum size 2: 3 peers and 2 learners."}),"\n",(0,t.jsx)(n.h3,{id:"quorum-requirements",children:"Quorum Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Writes require acknowledgment from a quorum of peers before completion. Losing the majority of the consensus group puts the partition in read-only state."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Replicas"}),(0,t.jsx)(n.th,{children:"Default Quorum"}),(0,t.jsx)(n.th,{children:"Consensus Peers"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2-4"}),(0,t.jsx)(n.td,{children:"2"}),(0,t.jsx)(n.td,{children:"3"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"5+"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"5"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"For high availability, use an odd number of replicas (3 or 5) to handle node failures without losing quorum."}),"\n",(0,t.jsx)(n.h2,{id:"primary-replicas-and-leases",children:"Primary Replicas and Leases"}),"\n",(0,t.jsx)(n.p,{children:"Each partition has one primary replica that handles all read-write transactions. The primary is determined through a lease mechanism managed by the placement driver."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant PD as Placement Driver\n    participant N1 as Node A\n    participant N2 as Node B\n\n    PD->>N1: Grant lease (Partition 0)\n    N1--\x3e>PD: Accept lease\n    Note over N1: Primary for Partition 0\n\n    loop Every ~500ms\n        PD->>N1: Extend lease\n        N1--\x3e>PD: Acknowledge\n    end\n\n    Note over N1: Node A fails\n    PD->>N2: Grant lease (Partition 0)\n    N2--\x3e>PD: Accept lease\n    Note over N2: New Primary"}),"\n",(0,t.jsx)(n.p,{children:"Lease properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Short-lived"}),": Leases expire after a few seconds if not renewed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-revocable"}),": A lease cannot be revoked before expiration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single holder"}),": Only one node holds the lease for a partition at any time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Negotiated"}),": The candidate must accept the lease before becoming primary"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"data-colocation",children:"Data Colocation"}),"\n",(0,t.jsx)(n.p,{children:"Colocation ensures that related data from different tables is stored on the same partition. This enables:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Joins without cross-node data transfer"}),"\n",(0,t.jsx)(n.li,{children:"Transactions touching related data without distributed coordination"}),"\n",(0,t.jsx)(n.li,{children:"Colocated compute jobs that access all needed data locally"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"colocation-keys",children:"Colocation Keys"}),"\n",(0,t.jsx)(n.p,{children:"Tables colocate when they share the same:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Distribution zone"}),"\n",(0,t.jsx)(n.li,{children:"Colocation key column(s) with matching values"}),"\n"]}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Node A - Partition 0"\n        O1["orders<br/>customer_id=100"]\n        OI1["order_items<br/>customer_id=100"]\n    end\n\n    subgraph "Node B - Partition 1"\n        O2["orders<br/>customer_id=200"]\n        OI2["order_items<br/>customer_id=200"]\n    end\n\n    O1 <-.->|"Colocated"| OI1\n    O2 <-.->|"Colocated"| OI2'}),"\n",(0,t.jsx)(n.p,{children:"Define colocation when creating tables:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- Parent table\nCREATE TABLE customers (\n    customer_id INT PRIMARY KEY,\n    name VARCHAR(100)\n) WITH PRIMARY_ZONE = 'my_zone';\n\n-- Child table colocated by customer_id\nCREATE TABLE orders (\n    order_id INT,\n    customer_id INT,\n    total DECIMAL(10,2),\n    PRIMARY KEY (order_id, customer_id)\n) COLOCATE BY (customer_id)\n  WITH PRIMARY_ZONE = 'my_zone';\n\n-- Another colocated table\nCREATE TABLE order_items (\n    item_id INT,\n    order_id INT,\n    customer_id INT,\n    product_id INT,\n    quantity INT,\n    PRIMARY KEY (item_id, customer_id)\n) COLOCATE BY (customer_id)\n  WITH PRIMARY_ZONE = 'my_zone';\n"})}),"\n",(0,t.jsx)(n.h3,{id:"colocation-requirements",children:"Colocation Requirements"}),"\n",(0,t.jsx)(n.p,{children:"For colocation to work:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Same zone"}),": Tables must use the same distribution zone"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Matching columns"}),": Colocation key columns must have compatible types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Primary key inclusion"}),": Colocation columns must be part of the primary key"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent hashing"}),": All colocated tables use the same hash function on colocation keys"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"query-optimization",children:"Query Optimization"}),"\n",(0,t.jsx)(n.p,{children:"The SQL engine detects colocated tables and optimizes join execution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- This join executes locally on each node without data shuffling\nSELECT o.order_id, c.name, o.total\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE o.customer_id = 100;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Without colocation, the same query would require transferring data between nodes."}),"\n",(0,t.jsx)(n.h2,{id:"partition-rebalancing",children:"Partition Rebalancing"}),"\n",(0,t.jsx)(n.p,{children:"When cluster topology changes, Ignite redistributes partitions to maintain balanced data distribution."}),"\n",(0,t.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Before: 3 Nodes"\n        A1[Node A<br/>P0, P1, P2]\n        B1[Node B<br/>P3, P4, P5]\n        C1[Node C<br/>P6, P7, P8]\n    end\n\n    subgraph "After: 4 Nodes"\n        A2[Node A<br/>P0, P1]\n        B2[Node B<br/>P3, P4]\n        C2[Node C<br/>P6, P7]\n        D2[Node D<br/>P2, P5, P8]\n    end\n\n    A1 --\x3e|"Rebalance"| A2\n    B1 --\x3e|"Rebalance"| B2\n    C1 --\x3e|"Rebalance"| C2'}),"\n",(0,t.jsx)(n.p,{children:"Rebalancing is controlled by scale timers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DATA_NODES_AUTO_ADJUST_SCALE_UP"}),": Delay before adding new node to data distribution (default: immediate)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DATA_NODES_AUTO_ADJUST_SCALE_DOWN"}),": Delay before removing departed node from distribution (default: immediate)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Setting delays prevents unnecessary rebalancing during rolling restarts or brief network issues."}),"\n",(0,t.jsx)(n.h2,{id:"node-filtering",children:"Node Filtering"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"DATA_NODES_FILTER"})," parameter selects which nodes participate in the zone using JSONPath expressions against node attributes:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"-- Only nodes in us-east region\nCREATE ZONE us_east_zone WITH\n    DATA_NODES_FILTER = '$[?(@.region == \"us-east\")]',\n    STORAGE_PROFILES = 'default';\n\n-- Nodes with SSD storage and at least 32GB RAM\nCREATE ZONE high_performance WITH\n    DATA_NODES_FILTER = '$[?(@.storage == \"ssd\" && @.memory >= 32)]',\n    STORAGE_PROFILES = 'default';\n"})}),"\n",(0,t.jsx)(n.p,{children:"Node attributes are configured in each node's configuration file."}),"\n",(0,t.jsx)(n.h2,{id:"design-constraints",children:"Design Constraints"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zone immutability"}),": Once a table is assigned to a zone, it cannot be moved to a different zone"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Partition count fixed"}),": The number of partitions cannot be changed after zone creation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Colocation at creation"}),": Colocation must be specified when creating the table"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single leaseholder"}),": Only one node can be the primary for a partition at any time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consensus majority"}),": Losing the majority of consensus peers makes the partition read-only"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/3.1.0/sql/reference/language-definition/distribution-zones",children:"Distribution Zones SQL Reference"})," for zone DDL syntax"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/3.1.0/understand/core-concepts/data-partitioning",children:"Data Partitioning"})," for partition internals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/3.1.0/configure-and-operate/operations/disaster-recovery-partitions",children:"Disaster Recovery"})," for handling partition failures"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);