"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1926],{28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(96540);const a={},s=i.createContext(a);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(s.Provider,{value:n},e.children)}},38169:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"sql-reference/operational-commands","title":"Operational Commands","description":"{/*","source":"@site/versioned_docs/version-3.0.0/sql-reference/operational-commands.md","sourceDirName":"sql-reference","slug":"/sql-reference/operational-commands","permalink":"/docs/ignite3/3.0.0/sql-reference/operational-commands","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/versioned_docs/version-3.0.0/sql-reference/operational-commands.md","tags":[],"version":"3.0.0","frontMatter":{"title":"Operational Commands","sidebar_label":"Operational Commands"},"sidebar":"tutorialSidebar","previous":{"title":"Operators and Functions","permalink":"/docs/ignite3/3.0.0/sql-reference/operators-and-functions"},"next":{"title":"Grammar Reference","permalink":"/docs/ignite3/3.0.0/sql-reference/grammar-reference"}}');var a=r(74848),s=r(28453);const t={title:"Operational Commands",sidebar_label:"Operational Commands"},l=void 0,o={},c=[{value:"SELECT",id:"select",level:2},{value:"Parameters",id:"parameters",level:3},{value:"JOINs",id:"joins",level:3},{value:"COPY INTO",id:"copy-into",level:2},{value:"Description",id:"description",level:3},{value:"Parameters",id:"parameters-1",level:3},{value:"Examples",id:"examples",level:3},{value:"KILL QUERY",id:"kill-query",level:2},{value:"Parameters",id:"parameters-2",level:3},{value:"KILL TRANSACTION",id:"kill-transaction",level:2},{value:"Parameters",id:"parameters-3",level:3},{value:"KILL COMPUTE",id:"kill-compute",level:2},{value:"Parameters",id:"parameters-4",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:["\n",(0,a.jsx)(n.h2,{id:"select",children:"SELECT"}),"\n",(0,a.jsx)(n.p,{children:"Retrieves data from a table or multiple tables."}),"\n","\n","\n",(0,a.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"hint_comment"})," - an sql ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/sql-tuning/#optimizer-hints",children:"optimizer hint"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"where_boolean_expression"})," - an SQL expression that is run against table records and returns a boolean value. Only the records for which ",(0,a.jsx)(n.code,{children:"TRUE"})," was returned will be returned. If not specified, all matching records are returned."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"having_boolean_expression"})," - an SQL expression that is run against groups and returns a boolean value. Can use ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/sql-reference/operators-and-functions#aggregate-functions",children:"aggregate functions"}),". Only the groups for which ",(0,a.jsx)(n.code,{children:"TRUE"})," was returned will be returned. If not specified, all matching groups are returned."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"joins",children:"JOINs"}),"\n",(0,a.jsx)(n.p,{children:"Apache Ignite supports colocated and non-colocated distributed SQL joins. Furthermore, if the data resides in different tables, Apache Ignite allows for cross-table joins as well."}),"\n",(0,a.jsx)(n.h2,{id:"copy-into",children:"COPY INTO"}),"\n",(0,a.jsx)(n.h3,{id:"description",children:"Description"}),"\n",(0,a.jsx)(n.p,{children:"Imports data from an external source into a table or exports data to a file from the table. The table the data is imported into must exist."}),"\n","\n",(0,a.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"source"})," - the full path to the file to import the data data from (if ",(0,a.jsx)(n.code,{children:"target"})," is a table). Then name of the table and the list of columns to export the data from (if ",(0,a.jsx)(n.code,{children:"target"})," is a file). If the source is a table, you can further narrow down the selection by using a query."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"target"})," - the table and table columns when importing data to the table. The path to the file when exporting data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"formatType"})," - the format of the file to work with:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"CSV"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"PARQUET"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"ICEBERG"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"WITH"})," - accepts additional parameters. All properties are case-sensitive:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"delimiter"})," -  for CSV files only; default delimiter is ",(0,a.jsx)(n.code,{children:","}),". Delimiter syntax is ",(0,a.jsx)(n.code,{children:"'char'"}),". Any alphanumeric character can be a delimiter."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pattern"})," - the file pattern used when importing partitioned Parquet tables in the regular expression format. The regular expression must be enclosed in ",(0,a.jsx)(n.code,{children:"'"})," signs. For example, ",(0,a.jsx)(n.code,{children:"'.*'"})," imports all files. Partitioned column will not be imported."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"header"})," - for CSV files only; if set to ",(0,a.jsx)(n.code,{children:"true"}),", specifies that the created file should contain a header line with column names. Column names of the table are used to create the header line."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"quoteChar"})," - for CSV files only; the character to use for quoted elements. Default quote character is ",(0,a.jsx)(n.code,{children:'"'}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"escapeChar"})," - for CSV files only; the character to use for escaping a separator or quote. Default escape character is ",(0,a.jsx)(n.code,{children:"\\"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ignoreLeadingWhiteSpace"})," - for CSV files only; if ",(0,a.jsx)(n.code,{children:"true"}),", ignore leading whitespace, keep them otherwise. Default value is ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ignoreQuotations"})," - for CSV files only; if ",(0,a.jsx)(n.code,{children:"true"}),", quoted elements are ignored, otherwise they are kept. Default value is ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"strictQuotes"})," - for CSV files only; if ",(0,a.jsx)(n.code,{children:"true"}),", characters outside the quoted elements are ignored, otherwise they are kept. Default value is ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"batchSize"})," - the number of entries loaded in each batch. Default value is ",(0,a.jsx)(n.code,{children:"1024"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"null"})," - what value empty values are mapped to on import, and ",(0,a.jsx)(n.code,{children:"null"})," values are mapped to on export. By default, empty values are mapped to ",(0,a.jsx)(n.code,{children:"null"})," on import, and ",(0,a.jsx)(n.code,{children:"null"})," values are mapped to an empty string (",(0,a.jsx)(n.code,{children:'""'}),") on export."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"S3"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"s3.client-region"})," - when using S3 storage, the region to store the data in."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"s3.access-key-id"})," - when using S3 storage, the AWS access key."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"s3.secret-access-key"})," - when using S3 storage,  the AWS secret key."]}),"\n",(0,a.jsxs)(n.li,{children:["Iceberg-specific:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.a,{href:"https://iceberg.apache.org/docs/latest/configuration/#catalog-properties",children:"catalog properties"})," are supported."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"table-identifier"})," property describes Apache Iceberg TableIdentifier names. The names can be dot-separated. For example, ",(0,a.jsx)(n.code,{children:"db_name.table_name"})," or ",(0,a.jsx)(n.code,{children:"table"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"warehouse"})," path can be defined explicitly as a ",(0,a.jsx)(n.code,{children:"'warehouse'='path'"})," property, or implicitly as a source or target ",(0,a.jsx)(n.code,{children:"COPY FROM source INTO target"}),". If both ways are defined, the explicit property is used."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["Imports data from columns ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"})," of a CSV file with header into Table1 columns ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import data from CSV with column headers */\nCOPY FROM '/path/to/dir/data.csv'\nINTO Table1 (name, age)\nFORMAT CSV\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Imports data from the first two columns of a CSV file without header into Table1 columns ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import data from CSV without column headers  */\nCOPY FROM '/path/to/dir/data.csv'\nINTO Table1 (name, age)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Imports data from columns ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"})," of a CSV file that uses the ",(0,a.jsx)(n.code,{children:"~"})," symbol as quotation character:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import data from CSV with custom quotation character */\nCOPY FROM '/path/to/dir/data.csv'\nINTO Table1 (name, age)\nFORMAT CSV\nWITH 'quoteChar'='~'\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Imports data from columns ",(0,a.jsx)(n.code,{children:"name"}),", ",(0,a.jsx)(n.code,{children:"age"})," and ",(0,a.jsx)(n.code,{children:"empty"})," of a CSV file and maps all empty values to ",(0,a.jsx)(n.code,{children:"no data"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import data from CSV with custom quotation character */\nCOPY FROM '/path/to/dir/data.csv'\nINTO Table1 (name, age, empty)\nFORMAT CSV\nWITH 'null'='no data'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Imports data from CSV table in batches of 2048 entries:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import data from CSV without column headers  */\nCOPY FROM '/path/to/dir/data.csv'\nINTO Table1 (name, age)\nWITH 'batchSize'='2048'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Exports data from Table1 to a CSV file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Export data to CSV */\nCOPY FROM (SELECT name, age FROM Table1)\nINTO  '/path/to/dir/data.csv'\nFORMAT CSV\n"})}),"\n",(0,a.jsx)(n.p,{children:"Imports CSV file from AWS S3 into Table1:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"/* Import CSV file from s3 */\nCOPY FROM 's3://mybucket/data.csv'\nINTO Table1 (name, age)\nFORMAT CSV\nWITH 'delimiter'= '|', 's3.access-key-id' = 'keyid', 's3.secret-access-key' = 'secretkey'\n"})}),"\n",(0,a.jsx)(n.p,{children:"A simple example of exporting data to Iceberg. For working with local file system you can use HadoopCatalog that does not need to connect to a Hive MetaStore."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"COPY FROM Table1 (id,name,height)\nINTO '/tmp/person.i/'\nFORMAT ICEBERG\nWITH 'table-identifier'='person', 'catalog-impl'='org.apache.iceberg.hadoop.HadoopCatalog'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Exports data into Iceberg on AWS S3:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"COPY FROM person (id,name,height)\nINTO 's3://iceberg-warehouse/glue-catalog'\nFORMAT ICEBERG\nWITH\n    'table-identifier'='iceberg_db_1.person',\n    'io-impl'='org.apache.iceberg.aws.s3.S3FileIO',\n    'catalog-impl'='org.apache.iceberg.aws.glue.GlueCatalog',\n    's3.client-region'='eu-central-1',\n    's3.access-key-id'='YOUR_KEY',\n    's3.secret-access-key'='YOUR_SECRET'\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["Glue catalog requires the table identifier pattern ",(0,a.jsx)(n.code,{children:"db_name.table_name - [a-z0-9_]"})," (all letters must be in low case with underscores and no spaces). It can be disabled by setting the ",(0,a.jsx)(n.code,{children:"glue.skip-name-validation"})," property to ",(0,a.jsx)(n.code,{children:"true"})," to skip validation. When database name and table name validation are skipped, there is no guarantee that downstream systems would all support the names."]})}),"\n",(0,a.jsx)(n.p,{children:"Imports data from partitioned Parquet database:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"COPY FROM '/tmp/partitioned_table_dir'\nINTO city (id, name, population)\nFORMAT PARQUET\nWITH 'pattern' = '.*'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Where the Parquet table looks like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"partitioned_table_dir/\n\u251c\u2500 CountryCode=USA/\n\u2502  \u251c\u2500 000000_0.parquet\n\u251c\u2500 CountryCode=FR/\n\u2502  \u251c\u2500 000000_0.parquet\n"})}),"\n",(0,a.jsx)(n.h2,{id:"kill-query",children:"KILL QUERY"}),"\n",(0,a.jsxs)(n.p,{children:["Cancels a running query. When a query is canceled with the ",(0,a.jsx)(n.code,{children:"KILL"})," command, all parts of the query running on all other nodes are canceled too."]}),"\n","\n",(0,a.jsx)(n.h3,{id:"parameters-2",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"query_id"})," - query identifier that can be retrieved via the ",(0,a.jsx)(n.code,{children:"SQL_QUERIES"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NO WAIT"})," - if specified, the command will return control immediately, without waiting for the query to be cancelled. You can monitor query status through the ",(0,a.jsx)(n.code,{children:"SQL_QUERIES"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"})," to make sure it was cancelled."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"kill-transaction",children:"KILL TRANSACTION"}),"\n",(0,a.jsx)(n.p,{children:"Cancels an active transaction."}),"\n","\n",(0,a.jsx)(n.h3,{id:"parameters-3",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"transaction_id"})," - transaction identifier that can be retrieved via the ",(0,a.jsx)(n.code,{children:"TRANSACTIONS"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NO WAIT"})," - if specified, the command will return control immediately, without waiting for the transaction to be cancelled. You can monitor transaction status through the ",(0,a.jsx)(n.code,{children:"TRANSACTIONS"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"})," to make sure it was cancelled."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"kill-compute",children:"KILL COMPUTE"}),"\n",(0,a.jsxs)(n.p,{children:["Cancels a running compute job. When a job is canceled with the ",(0,a.jsx)(n.code,{children:"KILL"})," command, all parts of the job running on all other nodes are canceled too."]}),"\n","\n",(0,a.jsx)(n.h3,{id:"parameters-4",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"job_id"})," - job identifier that can be retrieved via the ",(0,a.jsx)(n.code,{children:"COMPUTE_JOBS"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NO WAIT"})," - if specified, the command will return control immediately, without waiting for the job to be cancelled. You can monitor job status through the ",(0,a.jsx)(n.code,{children:"COMPUTE_JOBS"})," ",(0,a.jsx)(n.a,{href:"/docs/ignite3/3.0.0/administrators-guide/metrics/system-views",children:"system view"})," to make sure it was cancelled."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);