"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3144],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(96540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}},78827:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"develop/integrate/spring-data","title":"Spring Data Integration","description":"Apache Ignite 3 provides a Spring Data JDBC dialect that enables repository-based data access. Combined with Spring Boot\'s JDBC starter, this allows standard Spring Data repositories to work with Ignite tables through familiar patterns like CrudRepository and derived query methods.","source":"@site/docs/develop/integrate/spring-data.md","sourceDirName":"develop/integrate","slug":"/develop/integrate/spring-data","permalink":"/suggested-site/docs/ignite3/3.1.0/develop/integrate/spring-data","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"spring-data","title":"Spring Data Integration"},"sidebar":"tutorialSidebar","previous":{"title":"Spring Boot Integration","permalink":"/suggested-site/docs/ignite3/3.1.0/develop/integrate/spring-boot"},"next":{"title":"SQL","permalink":"/suggested-site/docs/ignite3/3.1.0/sql/"}}');var t=i(74848),a=i(28453);const s={id:"spring-data",title:"Spring Data Integration"},o=void 0,d={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation",id:"installation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Datasource Properties",id:"datasource-properties",level:3},{value:"SQL Dialect Registration",id:"sql-dialect-registration",level:3},{value:"Application Setup",id:"application-setup",level:2},{value:"Defining Entities",id:"defining-entities",level:2},{value:"Repository Definition",id:"repository-definition",level:2},{value:"CRUD Operations",id:"crud-operations",level:2},{value:"Derived Query Methods",id:"derived-query-methods",level:2},{value:"Custom Queries",id:"custom-queries",level:2},{value:"Pagination",id:"pagination",level:2},{value:"Query by Example",id:"query-by-example",level:2},{value:"Handling Entity State",id:"handling-entity-state",level:2},{value:"Supported Features",id:"supported-features",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Apache Ignite 3 provides a Spring Data JDBC dialect that enables repository-based data access. Combined with Spring Boot's JDBC starter, this allows standard Spring Data repositories to work with Ignite tables through familiar patterns like ",(0,t.jsx)(n.code,{children:"CrudRepository"})," and derived query methods."]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Java 17 or later"}),"\n",(0,t.jsx)(n.li,{children:"Spring Boot 3.x with Spring Data JDBC"}),"\n",(0,t.jsx)(n.li,{children:"Running Ignite 3 cluster"}),"\n",(0,t.jsx)(n.li,{children:"Tables created in Ignite before repository operations"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,t.jsx)(n.p,{children:"Spring Data integration requires three dependencies:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spring-boot-starter-data-jdbc"})," (from Spring) provides the Spring Data JDBC framework"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spring-data-ignite"})," (from Apache Ignite) provides the SQL dialect for Ignite-compatible query generation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ignite-jdbc"})," (from Apache Ignite) provides the JDBC driver for database connectivity"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The Ignite artifact versions must match your Apache Ignite cluster version."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Maven:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<properties>\n    <ignite.version>3.1.0</ignite.version>\n</properties>\n\n\x3c!-- Spring Data JDBC framework --\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jdbc</artifactId>\n</dependency>\n\n\x3c!-- Ignite SQL dialect for Spring Data --\x3e\n<dependency>\n    <groupId>org.apache.ignite</groupId>\n    <artifactId>spring-data-ignite</artifactId>\n    <version>${ignite.version}</version>\n</dependency>\n\n\x3c!-- Ignite JDBC driver --\x3e\n<dependency>\n    <groupId>org.apache.ignite</groupId>\n    <artifactId>ignite-jdbc</artifactId>\n    <version>${ignite.version}</version>\n</dependency>\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Gradle:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-groovy",children:"ext {\n    igniteVersion = '3.1.0'\n}\n\n// Spring Data JDBC framework\nimplementation 'org.springframework.boot:spring-boot-starter-data-jdbc'\n\n// Ignite SQL dialect for Spring Data\nimplementation \"org.apache.ignite:spring-data-ignite:${igniteVersion}\"\n\n// Ignite JDBC driver\nimplementation \"org.apache.ignite:ignite-jdbc:${igniteVersion}\"\n"})}),"\n",(0,t.jsx)(n.admonition,{title:"Version Matching",type:"note",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"spring-data-ignite"})," and ",(0,t.jsx)(n.code,{children:"ignite-jdbc"})," artifacts are released as part of Apache Ignite, so their versions match the Ignite release version. For Ignite 3.1.0, use version ",(0,t.jsx)(n.code,{children:"3.1.0"})," for both artifacts."]})}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"datasource-properties",children:"Datasource Properties"}),"\n",(0,t.jsxs)(n.p,{children:["Configure the JDBC datasource in ",(0,t.jsx)(n.code,{children:"application.properties"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"spring.datasource.url=jdbc:ignite:thin://localhost:10800\nspring.datasource.driver-class-name=org.apache.ignite.jdbc.IgniteJdbcDriver\n"})}),"\n",(0,t.jsx)(n.p,{children:"For multiple nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"spring.datasource.url=jdbc:ignite:thin://node1:10800,node2:10800,node3:10800\n"})}),"\n",(0,t.jsx)(n.h3,{id:"sql-dialect-registration",children:"SQL Dialect Registration"}),"\n",(0,t.jsxs)(n.p,{children:["Spring Data JDBC needs to generate database-specific SQL for operations like pagination, identity columns, and certain functions. The ",(0,t.jsx)(n.code,{children:"spring-data-ignite"})," artifact includes an ",(0,t.jsx)(n.code,{children:"IgniteDialectProvider"})," that teaches Spring Data how to generate Ignite-compatible SQL."]}),"\n",(0,t.jsxs)(n.p,{children:["The dialect provider is registered via Spring's SPI mechanism. Create the file ",(0,t.jsx)(n.code,{children:"src/main/resources/META-INF/spring.factories"})," with the following content:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-properties",children:"org.springframework.data.jdbc.repository.config.DialectResolver$JdbcDialectProvider=org.apache.ignite.data.IgniteDialectProvider\n"})}),"\n",(0,t.jsx)(n.p,{children:"Without this configuration, Spring Data falls back to generic ANSI SQL, which works for basic queries but may fail for database-specific operations."}),"\n",(0,t.jsx)(n.h2,{id:"application-setup",children:"Application Setup"}),"\n",(0,t.jsx)(n.p,{children:"Enable JDBC repositories in your Spring Boot application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"@EnableJdbcRepositories\n@SpringBootApplication\npublic class MyApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"defining-entities",children:"Defining Entities"}),"\n",(0,t.jsx)(n.p,{children:"Entities map to Ignite tables. Use Spring Data annotations to define the mapping:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.springframework.data.annotation.Id;\nimport org.springframework.data.relational.core.mapping.Column;\nimport org.springframework.data.relational.core.mapping.Table;\n\n@Table("PERSON")\npublic class Person {\n\n    @Id\n    private Long id;\n    private String name;\n    private String email;\n\n    @Column("COUNTRYCODE")\n    private String countryCode;  // Maps to COUNTRYCODE column\n\n    public Person() {}\n\n    public Person(Long id, String name, String email, String countryCode) {\n        this.id = id;\n        this.name = name;\n        this.email = email;\n        this.countryCode = countryCode;\n    }\n\n    // Getters and setters\n    public Long getId() { return id; }\n    public void setId(Long id) { this.id = id; }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n    public String getCountryCode() { return countryCode; }\n    public void setCountryCode(String countryCode) { this.countryCode = countryCode; }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Create the corresponding table in Ignite before using the repository:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE PERSON (\n    id BIGINT PRIMARY KEY,\n    name VARCHAR,\n    email VARCHAR,\n    COUNTRYCODE VARCHAR\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Key annotations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"@Table"})," maps the class to a specific table name"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"@Id"})," marks the primary key field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"@Column"})," maps a field to a column when names differ (Java's ",(0,t.jsx)(n.code,{children:"countryCode"})," to SQL's ",(0,t.jsx)(n.code,{children:"COUNTRYCODE"}),"). Fields without ",(0,t.jsx)(n.code,{children:"@Column"})," map by convention based on field name."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"repository-definition",children:"Repository Definition"}),"\n",(0,t.jsxs)(n.p,{children:["Define a repository interface extending ",(0,t.jsx)(n.code,{children:"CrudRepository"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import org.springframework.data.repository.CrudRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface PersonRepository extends CrudRepository<Person, Long> {\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"crud-operations",children:"CRUD Operations"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CrudRepository"})," interface provides standard data access methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"@Service\npublic class PersonService {\n\n    private final PersonRepository repository;\n\n    public PersonService(PersonRepository repository) {\n        this.repository = repository;\n    }\n\n    public Person save(Person person) {\n        return repository.save(person);\n    }\n\n    public Optional<Person> findById(Long id) {\n        return repository.findById(id);\n    }\n\n    public Iterable<Person> findAll() {\n        return repository.findAll();\n    }\n\n    public void deleteById(Long id) {\n        repository.deleteById(id);\n    }\n\n    public long count() {\n        return repository.count();\n    }\n\n    public boolean existsById(Long id) {\n        return repository.existsById(id);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"derived-query-methods",children:"Derived Query Methods"}),"\n",(0,t.jsx)(n.p,{children:"Spring Data generates queries from method names:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"@Repository\npublic interface PersonRepository extends CrudRepository<Person, Long> {\n\n    // SELECT * FROM PERSON WHERE name = ?\n    List<Person> findByName(String name);\n\n    // SELECT * FROM PERSON WHERE name LIKE '%value%'\n    List<Person> findByNameContains(String namePart);\n\n    // SELECT * FROM PERSON WHERE email = ?\n    Optional<Person> findByEmail(String email);\n\n    // SELECT COUNT(*) FROM PERSON WHERE name = ?\n    int countByName(String name);\n\n    // SELECT CASE WHEN COUNT(*) > 0 THEN true ELSE false END FROM PERSON WHERE name = ?\n    boolean existsByName(String name);\n\n    // SELECT * FROM PERSON WHERE name IN (?, ?, ...)\n    List<Person> findByNameIn(Collection<String> names);\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"custom-queries",children:"Custom Queries"}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"@Query"})," for explicit SQL:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.springframework.data.jdbc.repository.query.Query;\nimport org.springframework.data.repository.query.Param;\n\n@Repository\npublic interface PersonRepository extends CrudRepository<Person, Long> {\n\n    @Query("SELECT * FROM PERSON WHERE name = :name AND email = :email")\n    Optional<Person> findByNameAndEmail(@Param("name") String name, @Param("email") String email);\n\n    @Query("SELECT * FROM PERSON WHERE name IN (:names)")\n    List<Person> findByNames(@Param("names") Set<String> names);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"pagination",children:"Pagination"}),"\n",(0,t.jsx)(n.p,{children:"Spring Data supports paginated queries:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Slice;\n\n@Repository\npublic interface PersonRepository extends CrudRepository<Person, Long> {\n\n    // Returns Page with total count\n    Page<Person> findByNameContains(String namePart, Pageable pageable);\n\n    // Returns Slice without total count (more efficient for large datasets)\n    Slice<Person> findSliceByNameContains(String namePart, Pageable pageable);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Service\npublic class PersonService {\n\n    private final PersonRepository repository;\n\n    public PersonService(PersonRepository repository) {\n        this.repository = repository;\n    }\n\n    public Page<Person> getPage(String namePart, int page, int size) {\n        PageRequest pageRequest = PageRequest.of(page, size, Sort.by("name"));\n        return repository.findByNameContains(namePart, pageRequest);\n    }\n\n    public void processAllPersons(String namePart) {\n        Pageable pageable = PageRequest.of(0, 100);\n        Slice<Person> slice;\n\n        do {\n            slice = repository.findSliceByNameContains(namePart, pageable);\n            slice.getContent().forEach(this::process);\n            pageable = slice.nextPageable();\n        } while (slice.hasNext());\n    }\n\n    private void process(Person person) {\n        // Process person\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"query-by-example",children:"Query by Example"}),"\n",(0,t.jsxs)(n.p,{children:["For dynamic queries based on entity instances, extend ",(0,t.jsx)(n.code,{children:"QueryByExampleExecutor"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import org.springframework.data.repository.query.QueryByExampleExecutor;\n\n@Repository\npublic interface PersonRepository extends CrudRepository<Person, Long>, QueryByExampleExecutor<Person> {\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.springframework.data.domain.Example;\nimport org.springframework.data.domain.ExampleMatcher;\n\n@Service\npublic class PersonService {\n\n    private final PersonRepository repository;\n\n    public PersonService(PersonRepository repository) {\n        this.repository = repository;\n    }\n\n    public List<Person> findByExample(String name, String email) {\n        Person probe = new Person();\n        probe.setName(name);\n        probe.setEmail(email);\n\n        // Match non-null properties\n        Example<Person> example = Example.of(probe);\n        return (List<Person>) repository.findAll(example);\n    }\n\n    public List<Person> findByNameStartsWith(String prefix) {\n        Person probe = new Person();\n        probe.setName(prefix);\n\n        ExampleMatcher matcher = ExampleMatcher.matching()\n            .withMatcher("name", ExampleMatcher.GenericPropertyMatchers.startsWith())\n            .withIgnorePaths("id", "email");\n\n        Example<Person> example = Example.of(probe, matcher);\n        return (List<Person>) repository.findAll(example);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"handling-entity-state",children:"Handling Entity State"}),"\n",(0,t.jsxs)(n.p,{children:["Ignite tables do not auto-generate IDs. Implement ",(0,t.jsx)(n.code,{children:"Persistable"})," to control insert vs update behavior:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import org.springframework.data.annotation.Id;\nimport org.springframework.data.annotation.Transient;\nimport org.springframework.data.domain.Persistable;\n\npublic class Person implements Persistable<Long> {\n\n    @Id\n    private Long id;\n    private String name;\n\n    @Transient\n    private boolean isNew = true;\n\n    @Override\n    public Long getId() {\n        return id;\n    }\n\n    @Override\n    public boolean isNew() {\n        return isNew;\n    }\n\n    public void setNew(boolean newValue) {\n        this.isNew = newValue;\n    }\n\n    // After loading from database, mark as not new\n    public void markNotNew() {\n        this.isNew = false;\n    }\n\n    // Other getters and setters\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"When updating an existing entity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'Person person = repository.findById(1L).orElseThrow();\nperson.setName("Updated Name");\nperson.setNew(false);  // Prevents INSERT, performs UPDATE\nrepository.save(person);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"supported-features",children:"Supported Features"}),"\n",(0,t.jsx)(n.p,{children:"The Ignite dialect supports:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Status"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"CrudRepository"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"PagingAndSortingRepository"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"QueryByExampleExecutor"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Derived query methods"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"@Query annotations"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Page and Slice"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Sort"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Limit"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Enum types"}),(0,t.jsx)(n.td,{children:"Supported"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Array columns"}),(0,t.jsx)(n.td,{children:"Supported"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ignite does not auto-generate primary keys. Provide ID values explicitly."}),"\n",(0,t.jsxs)(n.li,{children:["Locking clauses (",(0,t.jsx)(n.code,{children:"@Lock"}),") are not supported. The dialect returns empty lock clauses."]}),"\n",(0,t.jsx)(n.li,{children:"Single query loading for related entities is not supported. Related entities require separate queries."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./spring-boot",children:"Spring Boot Integration"})," - Auto-configured IgniteClient"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../connect-to-ignite/jdbc",children:"JDBC Driver"})," - JDBC connection details"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../../sql/",children:"SQL Reference"})," - SQL syntax for table creation"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);