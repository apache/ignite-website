"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6647],{7705:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-reference/native-clients/dotnet/transactions-api","title":"Transactions API","description":"The Transactions API provides ACID transaction support for coordinating multiple operations across tables. Transactions ensure atomicity, consistency, isolation, and durability for distributed data modifications.","source":"@site/docs/api-reference/native-clients/dotnet/transactions-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/transactions-api","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/transactions-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/dotnet/transactions-api.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Transactions API","id":"transactions-api","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"ADO.NET API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/ado-net-api"},"next":{"title":"Compute API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/compute-api"}}');var i=a(74848),s=a(28453);const c={title:"Transactions API",id:"transactions-api",sidebar_position:5},r="Transactions API",o={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:3},{value:"Auto-Commit Mode",id:"auto-commit-mode",level:3},{value:"Transaction Scope",id:"transaction-scope",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Transaction",id:"basic-transaction",level:3},{value:"Using Statement Pattern",id:"using-statement-pattern",level:3},{value:"Transaction with Exception Handling",id:"transaction-with-exception-handling",level:3},{value:"RunInTransactionAsync Pattern",id:"runintransactionasync-pattern",level:3},{value:"Mixing Key-Value and SQL Operations",id:"mixing-key-value-and-sql-operations",level:3},{value:"Cross-Table Transaction",id:"cross-table-transaction",level:3},{value:"Read-Only Transaction",id:"read-only-transaction",level:3},{value:"Transaction Timeout",id:"transaction-timeout",level:3},{value:"Reference",id:"reference",level:2},{value:"ITransactions Interface",id:"itransactions-interface",level:3},{value:"ITransaction Interface",id:"itransaction-interface",level:3},{value:"TransactionOptions Record Struct",id:"transactionoptions-record-struct",level:3},{value:"Best Practices",id:"best-practices",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"transactions-api",children:"Transactions API"})}),"\n",(0,i.jsx)(e.p,{children:"The Transactions API provides ACID transaction support for coordinating multiple operations across tables. Transactions ensure atomicity, consistency, isolation, and durability for distributed data modifications."}),"\n",(0,i.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(e.p,{children:"Transactions group multiple operations into a single atomic unit. Either all operations succeed and commit together, or all operations fail and roll back together."}),"\n",(0,i.jsx)(e.h3,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,i.jsx)(e.p,{children:"Begin a transaction using the Transactions API, pass the transaction object to data operations, and explicitly commit or roll back when done. The transaction must be disposed after use."}),"\n",(0,i.jsx)(e.h3,{id:"auto-commit-mode",children:"Auto-Commit Mode"}),"\n",(0,i.jsx)(e.p,{children:"Operations that receive null for the transaction parameter execute in auto-commit mode. Each operation commits immediately after completion. Use this for single operations that do not require coordination."}),"\n",(0,i.jsx)(e.h3,{id:"transaction-scope",children:"Transaction Scope"}),"\n",(0,i.jsx)(e.p,{children:"Pass the same transaction object to multiple operations to include them in the transaction scope. Operations can span different tables and mix key-value and SQL operations."}),"\n",(0,i.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(e.h3,{id:"basic-transaction",children:"Basic Transaction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\nvar tx = await transactions.BeginAsync();\n\ntry\n{\n    var table = await client.Tables.GetTableAsync("accounts");\n    var view = table.GetRecordView<Account>();\n\n    // Multiple operations in transaction\n    var account1 = new Account { Id = 1 };\n    var account1Data = await view.GetAsync(tx, account1);\n\n    var account2 = new Account { Id = 2 };\n    var account2Data = await view.GetAsync(tx, account2);\n\n    // Update balances\n    account1Data.Value.Balance -= 100;\n    account2Data.Value.Balance += 100;\n\n    await view.UpsertAsync(tx, account1Data.Value);\n    await view.UpsertAsync(tx, account2Data.Value);\n\n    // Commit transaction\n    await tx.CommitAsync();\n}\ncatch\n{\n    await tx.RollbackAsync();\n    throw;\n}\nfinally\n{\n    await tx.DisposeAsync();\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"using-statement-pattern",children:"Using Statement Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\n\nawait using (var tx = await transactions.BeginAsync())\n{\n    var table = await client.Tables.GetTableAsync("orders");\n    var view = table.GetRecordView<Order>();\n\n    var order = new Order\n    {\n        OrderId = 1000,\n        CustomerId = 5,\n        Amount = 99.99m,\n        Status = "pending"\n    };\n\n    await view.UpsertAsync(tx, order);\n    await tx.CommitAsync();\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"transaction-with-exception-handling",children:"Transaction with Exception Handling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'try\n{\n    await using var tx = await client.Transactions.BeginAsync();\n\n    var table = await client.Tables.GetTableAsync("inventory");\n    var view = table.GetRecordView<Product>();\n\n    var product = new Product { Id = 100 };\n    var productData = await view.GetAsync(tx, product);\n\n    if (!productData.HasValue)\n    {\n        throw new Exception("Product not found");\n    }\n\n    if (productData.Value.Stock < 10)\n    {\n        throw new Exception("Insufficient stock");\n    }\n\n    productData.Value.Stock -= 10;\n    await view.UpsertAsync(tx, productData.Value);\n\n    await tx.CommitAsync();\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($"Transaction failed: {ex.Message}");\n    // Transaction automatically rolls back on exception\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"runintransactionasync-pattern",children:"RunInTransactionAsync Pattern"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'var transactions = client.Transactions;\n\n// With return value\nvar newBalance = await transactions.RunInTransactionAsync(async tx =>\n{\n    var table = await client.Tables.GetTableAsync("accounts");\n    var view = table.GetRecordView<Account>();\n\n    var account = new Account { Id = 1 };\n    var accountData = await view.GetAsync(tx, account);\n\n    accountData.Value.Balance += 50;\n    await view.UpsertAsync(tx, accountData.Value);\n\n    return accountData.Value.Balance;\n});\n\nConsole.WriteLine($"New balance: {newBalance}");\n\n// Without return value\nawait transactions.RunInTransactionAsync(async tx =>\n{\n    var table = await client.Tables.GetTableAsync("logs");\n    var view = table.GetRecordView<LogEntry>();\n\n    var entry = new LogEntry\n    {\n        Id = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),\n        Message = "Transaction completed",\n        Timestamp = DateTime.UtcNow\n    };\n\n    await view.UpsertAsync(tx, entry);\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"The RunInTransactionAsync method automatically commits on success and rolls back on exception. It also handles disposal automatically."}),"\n",(0,i.jsx)(e.h3,{id:"mixing-key-value-and-sql-operations",children:"Mixing Key-Value and SQL Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'await using var tx = await client.Transactions.BeginAsync();\n\n// Key-value operation\nvar accountsTable = await client.Tables.GetTableAsync("accounts");\nvar accountsView = accountsTable.GetRecordView<Account>();\n\nvar account = new Account { Id = 1 };\nvar accountData = await accountsView.GetAsync(tx, account);\naccountData.Value.Balance -= 100;\nawait accountsView.UpsertAsync(tx, accountData.Value);\n\n// SQL operation in same transaction\nvar sql = client.Sql;\nvar insertStmt = new SqlStatement(\n    "INSERT INTO transactions (account_id, amount, timestamp) VALUES (?, ?, ?)");\nawait sql.ExecuteAsync(tx, insertStmt, 1L, -100.0m, DateTime.UtcNow);\n\nawait tx.CommitAsync();\n'})}),"\n",(0,i.jsx)(e.h3,{id:"cross-table-transaction",children:"Cross-Table Transaction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'await using var tx = await client.Transactions.BeginAsync();\n\n// Update orders table\nvar ordersTable = await client.Tables.GetTableAsync("orders");\nvar ordersView = ordersTable.GetRecordView<Order>();\n\nvar order = new Order\n{\n    OrderId = 2000,\n    CustomerId = 10,\n    Amount = 199.99m,\n    Status = "confirmed"\n};\nawait ordersView.UpsertAsync(tx, order);\n\n// Update inventory table\nvar inventoryTable = await client.Tables.GetTableAsync("inventory");\nvar inventoryView = inventoryTable.GetRecordView<Product>();\n\nvar product = new Product { Id = 500 };\nvar productData = await inventoryView.GetAsync(tx, product);\nproductData.Value.Stock -= 1;\nawait inventoryView.UpsertAsync(tx, productData.Value);\n\nawait tx.CommitAsync();\n'})}),"\n",(0,i.jsx)(e.h3,{id:"read-only-transaction",children:"Read-Only Transaction"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'var options = new TransactionOptions(ReadOnly: true);\nawait using var tx = await client.Transactions.BeginAsync(options);\n\nvar table = await client.Tables.GetTableAsync("products");\nvar view = table.GetRecordView<Product>();\n\n// Read operations only\nvar product1 = await view.GetAsync(tx, new Product { Id = 1 });\nvar product2 = await view.GetAsync(tx, new Product { Id = 2 });\n\n// No commit needed for read-only transactions\n// Transaction automatically closes on dispose\n'})}),"\n",(0,i.jsx)(e.p,{children:"Read-only transactions can provide performance benefits and prevent accidental modifications."}),"\n",(0,i.jsx)(e.h3,{id:"transaction-timeout",children:"Transaction Timeout"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:'var options = new TransactionOptions(ReadOnly: false, TimeoutMillis: 30000);\n\nawait using var tx = await client.Transactions.BeginAsync(options);\n\ntry\n{\n    // Perform operations\n    var table = await client.Tables.GetTableAsync("data");\n    var view = table.GetRecordView<DataRecord>();\n\n    // ... operations ...\n\n    await tx.CommitAsync();\n}\ncatch (IgniteException ex)\n{\n    Console.WriteLine($"Transaction timeout or conflict: {ex.Message}");\n    throw;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsx)(e.h3,{id:"itransactions-interface",children:"ITransactions Interface"}),"\n",(0,i.jsx)(e.p,{children:"Methods:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ValueTask<ITransaction> BeginAsync()"})," - Begin new transaction with default options"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ValueTask<ITransaction> BeginAsync(TransactionOptions options)"})," - Begin new transaction with specified options"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task<T> RunInTransactionAsync<T>(Func<ITransaction, Task<T>> func, TransactionOptions options = default)"})," - Execute function within transaction and return result"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task RunInTransactionAsync(Func<ITransaction, Task> func, TransactionOptions options = default)"})," - Execute function within transaction (no return value)"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The RunInTransactionAsync methods handle transaction lifecycle automatically. They commit on successful completion and roll back on exceptions. The transaction is disposed after the function completes."}),"\n",(0,i.jsx)(e.h3,{id:"itransaction-interface",children:"ITransaction Interface"}),"\n",(0,i.jsx)(e.p,{children:"Properties:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"bool IsReadOnly"})," - Whether transaction is read-only"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Methods:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task CommitAsync()"})," - Commit the transaction, making all changes permanent"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Task RollbackAsync()"})," - Roll back the transaction, discarding all changes"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Resource management:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Implements ",(0,i.jsx)(e.strong,{children:"IAsyncDisposable"})," and ",(0,i.jsx)(e.strong,{children:"IDisposable"})]}),"\n",(0,i.jsx)(e.li,{children:"Must be disposed after use"}),"\n",(0,i.jsx)(e.li,{children:"Automatic rollback occurs if disposed without explicit commit"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"transactionoptions-record-struct",children:"TransactionOptions Record Struct"}),"\n",(0,i.jsx)(e.p,{children:"A readonly record struct that configures transaction behavior. Construct using named parameters:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-csharp",children:"new TransactionOptions(ReadOnly: true)\nnew TransactionOptions(ReadOnly: false, TimeoutMillis: 30000)\n"})}),"\n",(0,i.jsx)(e.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ReadOnly"})," (bool) - Mark transaction as read-only (default: false). Read-only transactions provide a snapshot view of data at a certain point in time. They are lock-free and perform better than normal transactions, but do not permit data modifications."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"TimeoutMillis"})," (long) - Transaction timeout in milliseconds (default: 0). A value of 0 means use the default timeout configured via ignite.transaction.timeout configuration property."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"The timeout controls how long the transaction can remain active before automatic rollback."}),"\n",(0,i.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Always dispose transactions"})," using using statements or explicit disposal. Undisposed transactions hold cluster resources."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Commit explicitly"})," before disposal. Implicit rollback on disposal can hide logic errors."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Keep transactions short"})," to reduce lock contention and improve throughput. Long-running transactions impact cluster performance."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Handle exceptions properly"})," to ensure rollback occurs when operations fail. Use try-catch blocks around transaction logic."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Use RunInTransactionAsync"})," for simple cases where automatic lifecycle management is sufficient. This reduces boilerplate code and ensures proper cleanup."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Pass transaction to all operations"})," that should be coordinated. Mixing null and transaction parameters within related operations breaks atomicity."]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},28453:(n,e,a)=>{a.d(e,{R:()=>c,x:()=>r});var t=a(96540);const i={},s=t.createContext(i);function c(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:c(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);