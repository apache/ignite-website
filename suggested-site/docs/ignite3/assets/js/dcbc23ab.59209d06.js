"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[797],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>c});var i=t(96540);const o={},s=i.createContext(o);function r(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(s.Provider,{value:e},n.children)}},58922:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"api-reference/native-clients/dotnet/network-api","title":"Network API","description":"The Network API provides information about cluster topology and active client connections. Use this API to discover cluster nodes, inspect connection status, and understand cluster composition.","source":"@site/docs/api-reference/native-clients/dotnet/network-api.md","sourceDirName":"api-reference/native-clients/dotnet","slug":"/api-reference/native-clients/dotnet/network-api","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/network-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/dotnet/network-api.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Network API","id":"network-api","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Compute API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/dotnet/compute-api"},"next":{"title":"C++ API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/cpp/"}}');var o=t(74848),s=t(28453);const r={title:"Network API",id:"network-api",sidebar_position:7},c="Network API",l={},a=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Node Identity",id:"node-identity",level:3},{value:"Connection Management",id:"connection-management",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Getting Cluster Nodes",id:"getting-cluster-nodes",level:3},{value:"Inspecting Active Connections",id:"inspecting-active-connections",level:3},{value:"Finding Specific Nodes",id:"finding-specific-nodes",level:3},{value:"Monitoring Connection Health",id:"monitoring-connection-health",level:3},{value:"Using Node Information for Job Targeting",id:"using-node-information-for-job-targeting",level:3},{value:"Connection Status Check",id:"connection-status-check",level:3},{value:"SSL Connection Information",id:"ssl-connection-information",level:3},{value:"Cluster Size Monitoring",id:"cluster-size-monitoring",level:3},{value:"Node Address Parsing",id:"node-address-parsing",level:3},{value:"Reference",id:"reference",level:2},{value:"IClusterNode Interface",id:"iclusternode-interface",level:3},{value:"IConnectionInfo Interface",id:"iconnectioninfo-interface",level:3},{value:"ISslInfo Interface",id:"isslinfo-interface",level:3},{value:"IIgniteClient Methods",id:"iigniteclient-methods",level:3},{value:"Best Practices",id:"best-practices",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"network-api",children:"Network API"})}),"\n",(0,o.jsx)(e.p,{children:"The Network API provides information about cluster topology and active client connections. Use this API to discover cluster nodes, inspect connection status, and understand cluster composition."}),"\n",(0,o.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(e.p,{children:"Cluster nodes represent individual server instances in the Ignite cluster. Each node has a unique identifier and network address. The client maintains connections to cluster nodes and distributes operations across them."}),"\n",(0,o.jsx)(e.h3,{id:"node-identity",children:"Node Identity"}),"\n",(0,o.jsx)(e.p,{children:"Nodes have two identifiers. The node ID changes after restart and uniquely identifies the current node instance. The node name (consistent ID) persists across restarts and identifies the node permanently."}),"\n",(0,o.jsx)(e.h3,{id:"connection-management",children:"Connection Management"}),"\n",(0,o.jsx)(e.p,{children:"The client automatically manages connections to cluster nodes. Query active connections to understand which nodes the client is currently connected to and inspect connection properties like SSL configuration."}),"\n",(0,o.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(e.h3,{id:"getting-cluster-nodes",children:"Getting Cluster Nodes"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var client = await IgniteClient.StartAsync(configuration);\n\n// Get all cluster nodes\nvar nodes = await client.GetClusterNodesAsync();\n\nforeach (var node in nodes)\n{\n    Console.WriteLine($"Node: {node.Name}");\n    Console.WriteLine($"  ID: {node.Id}");\n    Console.WriteLine($"  Address: {node.Address}");\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inspecting-active-connections",children:"Inspecting Active Connections"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var connections = client.GetConnections();\n\nConsole.WriteLine($"Active connections: {connections.Count}");\n\nforeach (var conn in connections)\n{\n    Console.WriteLine($"Connected to: {conn.Node.Name}");\n    Console.WriteLine($"  Node ID: {conn.Node.Id}");\n    Console.WriteLine($"  Address: {conn.Node.Address}");\n\n    if (conn.SslInfo != null)\n    {\n        Console.WriteLine($"  SSL: Enabled");\n        Console.WriteLine($"  Protocol: {conn.SslInfo.SslProtocol}");\n        Console.WriteLine($"  Cipher: {conn.SslInfo.NegotiatedCipherSuiteName}");\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"finding-specific-nodes",children:"Finding Specific Nodes"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\n\n// Find by name\nvar targetNode = nodes.FirstOrDefault(n => n.Name == "node-01");\nif (targetNode != null)\n{\n    Console.WriteLine($"Found node: {targetNode.Name} at {targetNode.Address}");\n}\n\n// Find by ID\nvar nodeId = Guid.Parse("550e8400-e29b-41d4-a716-446655440000");\nvar nodeById = nodes.FirstOrDefault(n => n.Id == nodeId);\n'})}),"\n",(0,o.jsx)(e.h3,{id:"monitoring-connection-health",children:"Monitoring Connection Health"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var checkInterval = TimeSpan.FromSeconds(30);\n\nwhile (true)\n{\n    var connections = client.GetConnections();\n\n    if (connections.Count == 0)\n    {\n        Console.WriteLine("WARNING: No active connections!");\n    }\n    else\n    {\n        Console.WriteLine($"Connected to {connections.Count} nodes:");\n        foreach (var conn in connections)\n        {\n            Console.WriteLine($"  - {conn.Node.Name}");\n        }\n    }\n\n    await Task.Delay(checkInterval);\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"using-node-information-for-job-targeting",children:"Using Node Information for Job Targeting"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\nvar compute = client.Compute;\n\n// Target specific node by name\nvar targetNode = nodes.FirstOrDefault(n => n.Name.StartsWith("compute"));\nif (targetNode != null)\n{\n    var jobTarget = JobTarget.Node(targetNode);\n    var execution = await compute.SubmitAsync(\n        jobTarget, jobDescriptor, "input");\n    var result = await execution.GetResultAsync();\n}\n\n// Target node by index (round-robin)\nvar nodeIndex = DateTime.UtcNow.Ticks % nodes.Count;\nvar selectedNode = nodes[(int)nodeIndex];\n'})}),"\n",(0,o.jsx)(e.h3,{id:"connection-status-check",children:"Connection Status Check"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:"public async Task<bool> IsConnectedToCluster(IIgniteClient client)\n{\n    try\n    {\n        var connections = client.GetConnections();\n        var nodes = await client.GetClusterNodesAsync();\n\n        return connections.Count > 0 && nodes.Count > 0;\n    }\n    catch (Exception)\n    {\n        return false;\n    }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"ssl-connection-information",children:"SSL Connection Information"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var connections = client.GetConnections();\n\nforeach (var conn in connections)\n{\n    if (conn.SslInfo != null)\n    {\n        Console.WriteLine($"Node: {conn.Node.Name}");\n        Console.WriteLine($"  SSL Protocol: {conn.SslInfo.SslProtocol}");\n        Console.WriteLine($"  Cipher Suite: {conn.SslInfo.NegotiatedCipherSuiteName}");\n        Console.WriteLine($"  Target Host: {conn.SslInfo.TargetHostName}");\n        Console.WriteLine($"  Mutually Authenticated: {conn.SslInfo.IsMutuallyAuthenticated}");\n\n        var localCert = conn.SslInfo.LocalCertificate;\n        var remoteCert = conn.SslInfo.RemoteCertificate;\n\n        if (localCert != null)\n        {\n            Console.WriteLine($"  Local Certificate: {localCert.Subject}");\n        }\n\n        if (remoteCert != null)\n        {\n            Console.WriteLine($"  Remote Certificate: {remoteCert.Subject}");\n            Console.WriteLine($"  Valid Until: {remoteCert.GetExpirationDateString()}");\n        }\n    }\n    else\n    {\n        Console.WriteLine($"Node: {conn.Node.Name} (unencrypted)");\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"cluster-size-monitoring",children:"Cluster Size Monitoring"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'public class ClusterMonitor\n{\n    private readonly IIgniteClient _client;\n    private int _lastKnownSize;\n\n    public ClusterMonitor(IIgniteClient client)\n    {\n        _client = client;\n    }\n\n    public async Task MonitorAsync(CancellationToken cancellationToken)\n    {\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            var nodes = await _client.GetClusterNodesAsync();\n            var currentSize = nodes.Count;\n\n            if (currentSize != _lastKnownSize)\n            {\n                if (_lastKnownSize > 0)\n                {\n                    if (currentSize > _lastKnownSize)\n                    {\n                        Console.WriteLine($"Cluster grew: {_lastKnownSize} -> {currentSize} nodes");\n                    }\n                    else\n                    {\n                        Console.WriteLine($"Cluster shrunk: {_lastKnownSize} -> {currentSize} nodes");\n                    }\n                }\n\n                _lastKnownSize = currentSize;\n            }\n\n            await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken);\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h3,{id:"node-address-parsing",children:"Node Address Parsing"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-csharp",children:'var nodes = await client.GetClusterNodesAsync();\n\nforeach (var node in nodes)\n{\n    var address = node.Address;\n\n    if (address is IPEndPoint ipEndPoint)\n    {\n        Console.WriteLine($"Node: {node.Name}");\n        Console.WriteLine($"  IP: {ipEndPoint.Address}");\n        Console.WriteLine($"  Port: {ipEndPoint.Port}");\n    }\n    else if (address is DnsEndPoint dnsEndPoint)\n    {\n        Console.WriteLine($"Node: {node.Name}");\n        Console.WriteLine($"  Host: {dnsEndPoint.Host}");\n        Console.WriteLine($"  Port: {dnsEndPoint.Port}");\n    }\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsx)(e.h3,{id:"iclusternode-interface",children:"IClusterNode Interface"}),"\n",(0,o.jsx)(e.p,{children:"Properties:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Id"})," - Unique node identifier (Guid) that changes after node restart"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Name"})," - Consistent node name that persists across restarts"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Address"})," - Network endpoint (IPEndPoint or DnsEndPoint)"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"The node ID is unique to the current node instance and changes when the node restarts. The node name remains consistent across restarts and serves as a stable identifier for the node."}),"\n",(0,o.jsx)(e.h3,{id:"iconnectioninfo-interface",children:"IConnectionInfo Interface"}),"\n",(0,o.jsx)(e.p,{children:"Properties:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Node"})," - The cluster node this connection targets"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"SslInfo"})," - SSL connection details (null if SSL not enabled)"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Connection info describes an active client connection to a cluster node. The client may maintain multiple connections to different nodes simultaneously."}),"\n",(0,o.jsx)(e.h3,{id:"isslinfo-interface",children:"ISslInfo Interface"}),"\n",(0,o.jsx)(e.p,{children:"Properties:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"SslProtocol"})," - SSL/TLS protocol version (e.g., Tls12, Tls13)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"NegotiatedCipherSuiteName"})," - Cipher suite negotiated for the connection"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"TargetHostName"})," - Server hostname used for certificate validation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"IsMutuallyAuthenticated"})," - Whether both client and server are authenticated"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"LocalCertificate"})," - Client certificate (if provided)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"RemoteCertificate"})," - Server certificate"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"SSL information is only available when SSL is configured through IgniteClientConfiguration.SslStreamFactory. When SSL is not enabled, IConnectionInfo.SslInfo returns null."}),"\n",(0,o.jsx)(e.h3,{id:"iigniteclient-methods",children:"IIgniteClient Methods"}),"\n",(0,o.jsx)(e.p,{children:"Node discovery:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GetClusterNodesAsync()"})," - Get all cluster nodes"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Connection inspection:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GetConnections()"})," - Get active client connections to cluster nodes"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Cache node lists"})," when possible. Cluster topology changes infrequently, so repeated calls to GetClusterNodesAsync may be unnecessary."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Use node names for stable targeting"}),". Node IDs change on restart, but node names persist. Use names when you need consistent targeting across node restarts."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Monitor connection count"})," to detect connectivity issues. A sudden drop in active connections may indicate network problems or node failures."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Check SSL configuration"})," in production. Verify SSL is properly configured by inspecting ISslInfo properties to ensure connections are encrypted."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Handle node changes gracefully"}),". Cluster topology can change as nodes join or leave. Design applications to adapt to topology changes without manual intervention."]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Use connection info for diagnostics"}),". Connection details help troubleshoot network issues, SSL problems, and load distribution across nodes."]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);