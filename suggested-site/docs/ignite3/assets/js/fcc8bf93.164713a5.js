"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[675],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),i.createElement(a.Provider,{value:e},n.children)}},57337:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api-reference/native-clients/cpp/transactions-api","title":"Transactions API","description":"The Transactions API provides explicit transaction control for operations across tables and SQL statements. Transactions ensure atomic, consistent, isolated, and durable data modifications.","source":"@site/docs/api-reference/native-clients/cpp/transactions-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/transactions-api","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/transactions-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/cpp/transactions-api.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Transactions API","id":"transactions-api","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"SQL API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/sql-api"},"next":{"title":"Compute API","permalink":"/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api"}}');var s=t(74848),a=t(28453);const r={title:"Transactions API",id:"transactions-api",sidebar_position:4},o="Transactions API",c={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:3},{value:"Explicit vs Implicit Transactions",id:"explicit-vs-implicit-transactions",level:3},{value:"Transaction Isolation",id:"transaction-isolation",level:3},{value:"Transaction Options",id:"transaction-options",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Beginning Transactions",id:"beginning-transactions",level:3},{value:"Committing Transactions",id:"committing-transactions",level:3},{value:"Rolling Back Transactions",id:"rolling-back-transactions",level:3},{value:"Table Operations",id:"table-operations",level:2},{value:"Using Transactions with Record Views",id:"using-transactions-with-record-views",level:3},{value:"Using Transactions with Key-Value Views",id:"using-transactions-with-key-value-views",level:3},{value:"Batch Operations",id:"batch-operations",level:3},{value:"SQL Operations",id:"sql-operations",level:2},{value:"Executing SQL in Transactions",id:"executing-sql-in-transactions",level:3},{value:"Cross-Table Transactions",id:"cross-table-transactions",level:3},{value:"Transaction Options",id:"transaction-options-1",level:2},{value:"Configuring Timeout",id:"configuring-timeout",level:3},{value:"Read-Only Transactions",id:"read-only-transactions",level:3},{value:"Chaining Options",id:"chaining-options",level:3},{value:"Transaction Visibility",id:"transaction-visibility",level:2},{value:"Uncommitted Changes",id:"uncommitted-changes",level:3},{value:"Isolation from Other Transactions",id:"isolation-from-other-transactions",level:3},{value:"Asynchronous Transactions",id:"asynchronous-transactions",level:2},{value:"Async Begin",id:"async-begin",level:3},{value:"Async Begin with Options",id:"async-begin-with-options",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Handling Commit Failures",id:"handling-commit-failures",level:3},{value:"Handling Operation Failures",id:"handling-operation-failures",level:3},{value:"Timeout Handling",id:"timeout-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Keep Transactions Short",id:"keep-transactions-short",level:3},{value:"Use Read-Only for Queries",id:"use-read-only-for-queries",level:3},{value:"Handle Errors Properly",id:"handle-errors-properly",level:3},{value:"Use RAII for Automatic Cleanup",id:"use-raii-for-automatic-cleanup",level:3},{value:"Reference",id:"reference",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"transactions-api",children:"Transactions API"})}),"\n",(0,s.jsx)(e.p,{children:"The Transactions API provides explicit transaction control for operations across tables and SQL statements. Transactions ensure atomic, consistent, isolated, and durable data modifications."}),"\n",(0,s.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(e.h3,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,s.jsx)(e.p,{children:"Transactions begin through the transactions factory. They remain active until committed or rolled back. Operations within a transaction see uncommitted changes from that transaction. Other transactions see data as it existed before the transaction started."}),"\n",(0,s.jsx)(e.h3,{id:"explicit-vs-implicit-transactions",children:"Explicit vs Implicit Transactions"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Explicit transactions"})," require manual commit or rollback. Pass the transaction pointer to operations. This provides control over transaction boundaries."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Implicit transactions"})," commit automatically after each operation. Pass ",(0,s.jsx)(e.code,{children:"nullptr"})," to operations for implicit transactions."]}),"\n",(0,s.jsx)(e.h3,{id:"transaction-isolation",children:"Transaction Isolation"}),"\n",(0,s.jsx)(e.p,{children:"Transactions use snapshot isolation. Each transaction sees a consistent snapshot of data from transaction start time. Changes within a transaction are visible to that transaction but not to others until commit."}),"\n",(0,s.jsx)(e.h3,{id:"transaction-options",children:"Transaction Options"}),"\n",(0,s.jsx)(e.p,{children:"Configure transaction behavior through options:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"timeout"})," - Maximum transaction duration"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"read_only"})," - Optimize for read-only workloads"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(e.h3,{id:"beginning-transactions",children:"Beginning Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Start a transaction with default options:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"using namespace ignite;\n\nauto transactions = client.get_transactions();\nauto tx = transactions.begin();\n"})}),"\n",(0,s.jsx)(e.p,{children:"Start with options:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_timeout_millis(30000);  // 30 seconds\nopts.set_read_only(false);\n\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,s.jsx)(e.p,{children:"Use async begin:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transactions.begin_async([](ignite_result<transaction> result) {\n    if (!result.has_error()) {\n        auto tx = std::move(result).value();\n        // Use transaction\n    }\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"committing-transactions",children:"Committing Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Commit to persist changes:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\n\n// Perform operations\ntx.commit();\n"})}),"\n",(0,s.jsx)(e.p,{children:"Use async commit:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'tx.commit_async([](ignite_result<void> result) {\n    if (!result.has_error()) {\n        std::cout << "Transaction committed" << std::endl;\n    }\n});\n'})}),"\n",(0,s.jsx)(e.h3,{id:"rolling-back-transactions",children:"Rolling Back Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Rollback to discard changes:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\n\ntry {\n    // Perform operations\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Use async rollback:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'tx.rollback_async([](ignite_result<void> result) {\n    if (!result.has_error()) {\n        std::cout << "Transaction rolled back" << std::endl;\n    }\n});\n'})}),"\n",(0,s.jsx)(e.h2,{id:"table-operations",children:"Table Operations"}),"\n",(0,s.jsx)(e.h3,{id:"using-transactions-with-record-views",children:"Using Transactions with Record Views"}),"\n",(0,s.jsx)(e.p,{children:"Pass transaction pointer to record view operations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\n\nauto table = client.get_tables().get_table("accounts").value();\nauto view = table.get_record_binary_view();\n\ntry {\n    ignite_tuple record{\n        {"id", 42},\n        {"name", "John Doe"},\n        {"balance", 1000.0}\n    };\n\n    view.upsert(&tx, record);\n\n    auto retrieved = view.get(&tx, ignite_tuple{{"id", 42}});\n\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"using-transactions-with-key-value-views",children:"Using Transactions with Key-Value Views"}),"\n",(0,s.jsx)(e.p,{children:"Pass transaction to key-value operations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\n\nauto table = client.get_tables().get_table("accounts").value();\nauto view = table.get_key_value_binary_view();\n\ntry {\n    ignite_tuple key{{"id", 42}};\n    ignite_tuple value{{"name", "John Doe"}, {"balance", 1000.0}};\n\n    view.put(&tx, key, value);\n    auto retrieved = view.get(&tx, key);\n\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,s.jsx)(e.p,{children:"Batch operations execute within a transaction:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\n\nstd::vector<ignite_tuple> records{\n    {{"id", 1}, {"name", "Alice"}, {"balance", 1000.0}},\n    {{"id", 2}, {"name", "Bob"}, {"balance", 2000.0}},\n    {{"id", 3}, {"name", "Charlie"}, {"balance", 3000.0}}\n};\n\ntry {\n    view.upsert_all(&tx, records);\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"sql-operations",children:"SQL Operations"}),"\n",(0,s.jsx)(e.h3,{id:"executing-sql-in-transactions",children:"Executing SQL in Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Pass transaction to SQL operations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\n\ntry {\n    auto sql = client.get_sql();\n\n    sql.execute(&tx, nullptr,\n        sql_statement("INSERT INTO accounts VALUES (?, ?, ?)"),\n        {42, std::string("John Doe"), 1000.0});\n\n    sql.execute(&tx, nullptr,\n        sql_statement("UPDATE accounts SET balance = ? WHERE id = ?"),\n        {1500.0, 42});\n\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"cross-table-transactions",children:"Cross-Table Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Execute operations across multiple tables:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = client.get_transactions().begin();\n\ntry {\n    auto sql = client.get_sql();\n\n    // Debit from one account\n    sql.execute(&tx, nullptr,\n        sql_statement("UPDATE accounts SET balance = balance - ? WHERE id = ?"),\n        {100.0, 1});\n\n    // Credit to another account\n    sql.execute(&tx, nullptr,\n        sql_statement("UPDATE accounts SET balance = balance + ? WHERE id = ?"),\n        {100.0, 2});\n\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"transaction-options-1",children:"Transaction Options"}),"\n",(0,s.jsx)(e.h3,{id:"configuring-timeout",children:"Configuring Timeout"}),"\n",(0,s.jsx)(e.p,{children:"Set maximum transaction duration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_timeout_millis(60000);  // 60 seconds\n\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,s.jsx)(e.p,{children:"Timeout of 0 means no timeout:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"opts.set_timeout_millis(0);  // No timeout\n"})}),"\n",(0,s.jsx)(e.h3,{id:"read-only-transactions",children:"Read-Only Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Optimize for read operations:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_read_only(true);\n\nauto tx = transactions.begin(opts);\n\n// Only read operations allowed\nauto result = view.get(&tx, key);\n\ntx.commit();  // Lightweight commit for read-only\n"})}),"\n",(0,s.jsx)(e.p,{children:"Read-only transactions provide better performance by avoiding write locks and conflict detection."}),"\n",(0,s.jsx)(e.h3,{id:"chaining-options",children:"Chaining Options"}),"\n",(0,s.jsx)(e.p,{children:"Use fluent API to chain option setters:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_timeout_millis(30000)\n    .set_read_only(false);\n\nauto tx = transactions.begin(opts);\n"})}),"\n",(0,s.jsx)(e.h2,{id:"transaction-visibility",children:"Transaction Visibility"}),"\n",(0,s.jsx)(e.h3,{id:"uncommitted-changes",children:"Uncommitted Changes"}),"\n",(0,s.jsx)(e.p,{children:"Changes are visible within the transaction:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\n\nview.upsert(&tx, record);\n\n// This sees the upserted record\nauto result = view.get(&tx, key);\n\n// Other transactions do not see it yet\n"})}),"\n",(0,s.jsx)(e.h3,{id:"isolation-from-other-transactions",children:"Isolation from Other Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Each transaction sees a consistent snapshot:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"// Transaction 1\nauto tx1 = transactions.begin();\nview.upsert(&tx1, record1);\n\n// Transaction 2 (concurrent)\nauto tx2 = transactions.begin();\nauto result = view.get(&tx2, key);  // Does not see record1\n\ntx1.commit();\n\n// Transaction 2 still does not see record1 (snapshot isolation)\nauto result2 = view.get(&tx2, key);  // Still does not see record1\n"})}),"\n",(0,s.jsx)(e.h2,{id:"asynchronous-transactions",children:"Asynchronous Transactions"}),"\n",(0,s.jsx)(e.h3,{id:"async-begin",children:"Async Begin"}),"\n",(0,s.jsx)(e.p,{children:"Start transactions asynchronously:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transactions.begin_async([&](ignite_result<transaction> result) {\n    if (!result.has_error()) {\n        auto tx = std::move(result).value();\n\n        view.upsert_async(&tx, record, [&](ignite_result<void> upsert_result) {\n            if (!upsert_result.has_error()) {\n                tx.commit_async([](ignite_result<void> commit_result) {\n                    // Transaction committed\n                });\n            }\n        });\n    }\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"async-begin-with-options",children:"Async Begin with Options"}),"\n",(0,s.jsx)(e.p,{children:"Pass options to async begin:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_timeout_millis(30000);\n\ntransactions.begin_async(opts, [](ignite_result<transaction> result) {\n    // Use transaction\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(e.h3,{id:"handling-commit-failures",children:"Handling Commit Failures"}),"\n",(0,s.jsx)(e.p,{children:"Commit failures indicate conflicts or constraints:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = transactions.begin();\n\ntry {\n    view.upsert(&tx, record);\n    tx.commit();\n} catch (const ignite_error& e) {\n    std::cerr << "Commit failed: " << e.what_str() << std::endl;\n    // Transaction already rolled back on commit failure\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"handling-operation-failures",children:"Handling Operation Failures"}),"\n",(0,s.jsx)(e.p,{children:"Roll back on operation errors:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'auto tx = transactions.begin();\n\ntry {\n    view.upsert(&tx, record1);\n    view.upsert(&tx, record2);  // May throw\n    tx.commit();\n} catch (const ignite_error& e) {\n    tx.rollback();\n    std::cerr << "Operation failed: " << e.what_str() << std::endl;\n    throw;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"timeout-handling",children:"Timeout Handling"}),"\n",(0,s.jsx)(e.p,{children:"Transactions time out after configured duration:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_timeout_millis(1000);  // 1 second\n\nauto tx = transactions.begin(opts);\n\ntry {\n    // Long-running operation\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    tx.commit();  // Will fail due to timeout\n} catch (const ignite_error& e) {\n    // Handle timeout error\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(e.h3,{id:"keep-transactions-short",children:"Keep Transactions Short"}),"\n",(0,s.jsx)(e.p,{children:"Minimize transaction duration to reduce conflicts:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"// Good: Short transaction\nauto tx = transactions.begin();\nview.upsert(&tx, record);\ntx.commit();\n\n// Avoid: Long-running transaction\nauto tx2 = transactions.begin();\nperform_expensive_calculation();  // Do outside transaction\nview.upsert(&tx2, result);\ntx2.commit();\n"})}),"\n",(0,s.jsx)(e.h3,{id:"use-read-only-for-queries",children:"Use Read-Only for Queries"}),"\n",(0,s.jsx)(e.p,{children:"Enable read-only optimization:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"transaction_options opts;\nopts.set_read_only(true);\n\nauto tx = transactions.begin(opts);\nauto results = view.get_all(&tx, keys);\ntx.commit();\n"})}),"\n",(0,s.jsx)(e.h3,{id:"handle-errors-properly",children:"Handle Errors Properly"}),"\n",(0,s.jsx)(e.p,{children:"Always rollback on errors:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"auto tx = transactions.begin();\nbool committed = false;\n\ntry {\n    // Operations\n    tx.commit();\n    committed = true;\n} catch (const ignite_error& e) {\n    if (!committed) {\n        tx.rollback();\n    }\n    throw;\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"use-raii-for-automatic-cleanup",children:"Use RAII for Automatic Cleanup"}),"\n",(0,s.jsx)(e.p,{children:"Wrap transactions in RAII helpers:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"class transaction_guard {\n    transaction& tx_;\n    bool committed_ = false;\n\npublic:\n    explicit transaction_guard(transaction& tx) : tx_(tx) {}\n\n    ~transaction_guard() {\n        if (!committed_) {\n            try {\n                tx_.rollback();\n            } catch (...) {\n                // Log error\n            }\n        }\n    }\n\n    void commit() {\n        tx_.commit();\n        committed_ = true;\n    }\n};\n\n// Usage\nauto tx = transactions.begin();\ntransaction_guard guard(tx);\n\nview.upsert(&tx, record);\nguard.commit();  // Automatic rollback if not committed\n"})}),"\n",(0,s.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://ignite.apache.org/releases/ignite3/latest/cpp-api/",children:"C++ API Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"../../../develop/work-with-data/transactions",children:"Transactions Concept"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"./client-api",children:"Client API"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"./tables-api",children:"Tables API"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"./sql-api",children:"SQL API"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}}}]);