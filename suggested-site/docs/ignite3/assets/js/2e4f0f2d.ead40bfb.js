"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5606],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(96540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},58754:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"understand/architecture/architecture-overview","title":"Architecture Overview","description":"Apache Ignite 3 is a distributed database built on a modular component architecture. Each node runs the same set of services, enabling any node to handle client requests and participate in data storage. This document provides a deeper look at the system architecture introduced in What is Apache Ignite 3?.","source":"@site/docs/understand/architecture/architecture-overview.md","sourceDirName":"understand/architecture","slug":"/understand/architecture/architecture-overview","permalink":"/docs/ignite3/3.1.0/understand/architecture/architecture-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/understand/architecture/architecture-overview.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"architecture-overview","title":"Architecture Overview","sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/docs/ignite3/3.1.0/understand/architecture/"},"next":{"title":"Storage Architecture","permalink":"/docs/ignite3/3.1.0/understand/architecture/storage-architecture"}}');var i=r(74848),s=r(28453);const a={id:"architecture-overview",title:"Architecture Overview",sidebar_position:0},o="Architecture Overview",d={},c=[{value:"System Architecture",id:"system-architecture",level:2},{value:"Node Components",id:"node-components",level:2},{value:"Core Services",id:"core-services",level:3},{value:"Cluster Coordination",id:"cluster-coordination",level:3},{value:"Data Management",id:"data-management",level:3},{value:"Query and Transaction Processing",id:"query-and-transaction-processing",level:3},{value:"Cluster Coordination",id:"cluster-coordination-1",level:2},{value:"Cluster Management Group (CMG)",id:"cluster-management-group-cmg",level:3},{value:"MetaStorage",id:"metastorage",level:3},{value:"Placement Driver",id:"placement-driver",level:3},{value:"RAFT Replication",id:"raft-replication",level:2},{value:"Partition RAFT Groups",id:"partition-raft-groups",level:3},{value:"Transaction Processing",id:"transaction-processing",level:2},{value:"Transaction Coordination",id:"transaction-coordination",level:3},{value:"Concurrency Control",id:"concurrency-control",level:3},{value:"Query Execution",id:"query-execution",level:2},{value:"SQL Processing Pipeline",id:"sql-processing-pipeline",level:3},{value:"Fragment Distribution",id:"fragment-distribution",level:3},{value:"Request Flow",id:"request-flow",level:2},{value:"Component Initialization Order",id:"component-initialization-order",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"architecture-overview",children:"Architecture Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["Apache Ignite 3 is a distributed database built on a modular component architecture. Each node runs the same set of services, enabling any node to handle client requests and participate in data storage. This document provides a deeper look at the system architecture introduced in ",(0,i.jsx)(n.a,{href:"../core-concepts/what-is-ignite",children:"What is Apache Ignite 3?"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Client Layer"\n        TC[Thin Clients<br/>Java, .NET, C++]\n        JDBC[JDBC/ODBC]\n        REST[REST API]\n    end\n\n    subgraph "Node Architecture"\n        subgraph "Request Processing"\n            CH[Client Handler]\n            SQL[SQL Query Processor<br/>Calcite-based]\n            TXM[Transaction Manager]\n        end\n\n        subgraph "Cluster Coordination"\n            CMG[Cluster Management Group]\n            MS[MetaStorage]\n            PD[Placement Driver]\n        end\n\n        subgraph "Data Management"\n            RM[Replica Manager]\n            TM[Table Manager]\n            DZM[Distribution Zone Manager]\n        end\n\n        subgraph "Storage"\n            SE[Storage Engines<br/>aimem, aipersist, rocksdb]\n            RAFT[RAFT Groups<br/>per partition]\n        end\n    end\n\n    TC & JDBC & REST --\x3e CH\n    CH --\x3e SQL\n    SQL --\x3e TXM\n    TXM --\x3e PD\n    PD --\x3e RM\n    RM --\x3e RAFT\n    RAFT --\x3e SE\n    CMG --\x3e MS\n    MS --\x3e PD'}),"\n",(0,i.jsx)(n.h2,{id:"node-components",children:"Node Components"}),"\n",(0,i.jsx)(n.p,{children:'Every Ignite node runs the same component set. There is no distinction between "server" and "coordinator" nodes at the software level. Node roles emerge from RAFT group membership and placement driver lease assignments.'}),"\n",(0,i.jsx)(n.h3,{id:"core-services",children:"Core Services"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Responsibility"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Cluster Service"})}),(0,i.jsx)(n.td,{children:"Network communication, node discovery, message routing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Vault Manager"})}),(0,i.jsx)(n.td,{children:"Local persistent storage for node-specific data"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Hybrid Clock"})}),(0,i.jsx)(n.td,{children:"Distributed timestamp generation for MVCC"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Failure Manager"})}),(0,i.jsx)(n.td,{children:"Node failure detection and handling"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"cluster-coordination",children:"Cluster Coordination"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Responsibility"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Cluster Management Group (CMG)"})}),(0,i.jsx)(n.td,{children:"Cluster initialization, node admission, logical topology"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"MetaStorage"})}),(0,i.jsx)(n.td,{children:"Distributed metadata (schemas, configurations, leases)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Placement Driver"})}),(0,i.jsx)(n.td,{children:"Primary replica selection via time-bounded leases"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"data-management",children:"Data Management"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Responsibility"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Table Manager"})}),(0,i.jsx)(n.td,{children:"Table lifecycle and distributed operations"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Replica Manager"})}),(0,i.jsx)(n.td,{children:"Partition replica lifecycle and request routing"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Distribution Zone Manager"})}),(0,i.jsx)(n.td,{children:"Data placement policies and partition assignments"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Index Manager"})}),(0,i.jsx)(n.td,{children:"Index creation, maintenance, and async building"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"query-and-transaction-processing",children:"Query and Transaction Processing"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Responsibility"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"SQL Query Processor"})}),(0,i.jsx)(n.td,{children:"Query parsing, optimization, distributed execution"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Transaction Manager"})}),(0,i.jsx)(n.td,{children:"ACID transaction coordination, 2PC protocol"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Compute Component"})}),(0,i.jsx)(n.td,{children:"Distributed job execution"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"cluster-coordination-1",children:"Cluster Coordination"}),"\n",(0,i.jsx)(n.h3,{id:"cluster-management-group-cmg",children:"Cluster Management Group (CMG)"}),"\n",(0,i.jsx)(n.p,{children:"The CMG is a dedicated RAFT group responsible for cluster-wide coordination:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "CMG RAFT Group"\n        L[Leader Node]\n        V1[Voting Node]\n        V2[Voting Node]\n        LN1[Learner Node]\n        LN2[Learner Node]\n    end\n\n    subgraph "Responsibilities"\n        INIT[Cluster Initialization]\n        JOIN[Node Join Validation]\n        TOPO[Logical Topology]\n        STATE[Cluster State Storage]\n    end\n\n    L <--\x3e V1 & V2\n    L --\x3e LN1 & LN2\n    L --\x3e INIT & JOIN & TOPO & STATE'}),"\n",(0,i.jsx)(n.p,{children:"CMG membership is established during cluster initialization. Typically 3 to 5 nodes are selected as voting members; remaining nodes participate as learners. The CMG validates new nodes before admitting them to the cluster."}),"\n",(0,i.jsx)(n.h3,{id:"metastorage",children:"MetaStorage"}),"\n",(0,i.jsx)(n.p,{children:"MetaStorage is a distributed key-value store replicated across all nodes via RAFT:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "MetaStorage Contents"\n        CAT[System Catalog<br/>tables, indexes]\n        CFG[Configuration<br/>zones, profiles]\n        LEASE[Placement Leases<br/>primary assignments]\n        DEPLOY[Deployment Units<br/>compute code]\n    end\n\n    subgraph "Replication"\n        LEAD[Leader<br/>handles writes]\n        VOTE[Voting Nodes<br/>3-5 nodes]\n        LEARN[Learner Nodes<br/>remaining nodes]\n    end\n\n    CAT & CFG & LEASE & DEPLOY --\x3e LEAD\n    LEAD --\x3e VOTE --\x3e LEARN'}),"\n",(0,i.jsx)(n.p,{children:"All cluster metadata changes flow through MetaStorage. Nodes maintain local replicas and receive updates via RAFT log replication. The watch mechanism enables real-time notification of metadata changes."}),"\n",(0,i.jsx)(n.h3,{id:"placement-driver",children:"Placement Driver"}),"\n",(0,i.jsx)(n.p,{children:"The Placement Driver manages primary replica selection through time-bounded leases:"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant PD as Placement Driver\n    participant MS as MetaStorage\n    participant P1 as Primary Replica\n    participant P2 as Backup Replica\n\n    Note over PD: Lease Negotiation\n    PD->>MS: Store Lease (partition, node, expiry)\n    MS--\x3e>P1: Lease Notification\n    P1->>P1: Accept Primary Role\n\n    Note over PD: Lease Renewal (every 2.5s for 5s lease)\n    loop Every renewal interval\n        PD->>MS: Extend Lease\n        MS--\x3e>P1: Renewed\n    end\n\n    Note over PD: Failover (lease expires)\n    PD->>MS: Grant New Lease to P2\n    MS--\x3e>P2: Lease Notification\n    P2->>P2: Accept Primary Role"}),"\n",(0,i.jsx)(n.p,{children:"Lease properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Duration"}),": Configurable, default 5 seconds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Renewal"}),": Automatic, every half of expiration interval"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Selection priority"}),": Current holder, then RAFT leader, then stable assignments"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Persistence"}),": Stored in MetaStorage for cluster-wide visibility"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"raft-replication",children:"RAFT Replication"}),"\n",(0,i.jsx)(n.p,{children:"Apache Ignite 3 uses multiple RAFT groups for different purposes:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"RAFT Group"}),(0,i.jsx)(n.th,{children:"Purpose"}),(0,i.jsx)(n.th,{children:"Members"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"CMG"})}),(0,i.jsx)(n.td,{children:"Cluster management"}),(0,i.jsx)(n.td,{children:"3-5 voting nodes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"MetaStorage"})}),(0,i.jsx)(n.td,{children:"Cluster metadata"}),(0,i.jsx)(n.td,{children:"3-5 voting + learner nodes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Placement Driver"})}),(0,i.jsx)(n.td,{children:"Lease management"}),(0,i.jsx)(n.td,{children:"Placement driver nodes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Partition Groups"})}),(0,i.jsx)(n.td,{children:"Data replication"}),(0,i.jsx)(n.td,{children:"Nodes in partition assignments"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"partition-raft-groups",children:"Partition RAFT Groups"}),"\n",(0,i.jsx)(n.p,{children:"Each table partition forms its own RAFT group:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Table: orders (Zone: financial, 25 partitions)"\n        subgraph "Partition 0"\n            P0L[Leader<br/>Node 1]\n            P0F1[Follower<br/>Node 2]\n            P0F2[Follower<br/>Node 3]\n        end\n        subgraph "Partition 1"\n            P1L[Leader<br/>Node 2]\n            P1F1[Follower<br/>Node 1]\n            P1F2[Follower<br/>Node 3]\n        end\n        subgraph "Partition N..."\n            PNL[Leader]\n            PNF1[Follower]\n            PNF2[Follower]\n        end\n    end\n\n    P0L <--\x3e P0F1 & P0F2\n    P1L <--\x3e P1F1 & P1F2'}),"\n",(0,i.jsx)(n.p,{children:"Partition RAFT groups provide:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Write linearization"}),": All writes go through the leader"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Replication"}),": Log entries replicated to followers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic failover"}),": New leader elected on failure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State machine"}),": Multi-version storage with B+ trees"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"transaction-processing",children:"Transaction Processing"}),"\n",(0,i.jsx)(n.h3,{id:"transaction-coordination",children:"Transaction Coordination"}),"\n",(0,i.jsx)(n.p,{children:"The Transaction Manager coordinates distributed transactions using two-phase commit:"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant C as Client\n    participant TM as Transaction Manager\n    participant PD as Placement Driver\n    participant P1 as Partition 1 Primary\n    participant P2 as Partition 2 Primary\n\n    C->>TM: BEGIN TRANSACTION\n    TM->>TM: Create TX Context\n\n    C->>TM: UPDATE table1 SET ...\n    TM->>PD: Locate Primary (partition 1)\n    PD--\x3e>TM: Node 1\n    TM->>P1: Enlist + Execute\n    P1--\x3e>TM: Enlisted\n\n    C->>TM: UPDATE table2 SET ...\n    TM->>PD: Locate Primary (partition 2)\n    PD--\x3e>TM: Node 2\n    TM->>P2: Enlist + Execute\n    P2--\x3e>TM: Enlisted\n\n    C->>TM: COMMIT\n    TM->>P1: PREPARE\n    TM->>P2: PREPARE\n    P1--\x3e>TM: PREPARED\n    P2--\x3e>TM: PREPARED\n    TM->>P1: COMMIT\n    TM->>P2: COMMIT\n    P1--\x3e>TM: COMMITTED\n    P2--\x3e>TM: COMMITTED\n    TM--\x3e>C: COMMIT SUCCESS"}),"\n",(0,i.jsx)(n.h3,{id:"concurrency-control",children:"Concurrency Control"}),"\n",(0,i.jsx)(n.p,{children:"Apache Ignite 3 uses a hybrid concurrency control model:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Transaction Type"}),(0,i.jsx)(n.th,{children:"Concurrency Control"}),(0,i.jsx)(n.th,{children:"Isolation"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Read-Write"})}),(0,i.jsx)(n.td,{children:"Lock-based with MVCC"}),(0,i.jsx)(n.td,{children:"Serializable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Read-Only"})}),(0,i.jsx)(n.td,{children:"Timestamp-based snapshot"}),(0,i.jsx)(n.td,{children:"Snapshot"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Read-write transactions acquire locks through the primary replica. Read-only transactions use timestamp-based reads against MVCC version chains without acquiring locks."}),"\n",(0,i.jsx)(n.h2,{id:"query-execution",children:"Query Execution"}),"\n",(0,i.jsx)(n.h3,{id:"sql-processing-pipeline",children:"SQL Processing Pipeline"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Query Processing"\n        SQL[SQL Text] --\x3e PARSE[Parser]\n        PARSE --\x3e AST[AST]\n        AST --\x3e VAL[Validator]\n        VAL --\x3e OPT[Optimizer<br/>Calcite]\n        OPT --\x3e PHYS[Physical Plan]\n        PHYS --\x3e MAP[Mapper]\n        MAP --\x3e FRAG[Fragments]\n    end\n\n    subgraph "Distributed Execution"\n        FRAG --\x3e N1[Node 1<br/>Fragment A]\n        FRAG --\x3e N2[Node 2<br/>Fragment B]\n        FRAG --\x3e N3[Node 3<br/>Fragment C]\n        N1 & N2 & N3 --\x3e AGG[Aggregation]\n        AGG --\x3e RES[Result]\n    end'}),"\n",(0,i.jsx)(n.p,{children:"The SQL engine is built on Apache Calcite and executes queries in stages:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parsing"}),": SQL text converted to abstract syntax tree"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Semantic validation against the system catalog"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimization"}),": Cost-based optimization using Calcite rules"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physical Planning"}),": Conversion to physical operators (IgniteRel)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mapping"}),": Plan fragments assigned to cluster nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution"}),": Distributed execution with inter-node data exchange"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"fragment-distribution",children:"Fragment Distribution"}),"\n",(0,i.jsx)(n.p,{children:"Query plans are split into fragments that execute on different nodes:"}),"\n",(0,i.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Fragment 0 (Coordinator)"\n        ROOT[Project]\n        JOIN[HashJoin]\n        R1[Receiver]\n        R2[Receiver]\n    end\n\n    subgraph "Fragment 1 (Node 1, 2, 3)"\n        S1[Sender]\n        TS1[TableScan: orders]\n    end\n\n    subgraph "Fragment 2 (Node 1, 2, 3)"\n        S2[Sender]\n        TS2[TableScan: customers]\n    end\n\n    ROOT --\x3e JOIN\n    JOIN --\x3e R1 --\x3e S1 --\x3e TS1\n    JOIN --\x3e R2 --\x3e S2 --\x3e TS2'}),"\n",(0,i.jsx)(n.p,{children:"Exchange operators (Sender/Receiver) handle data movement between fragments. Colocation optimization reduces exchanges when joined data resides on the same nodes."}),"\n",(0,i.jsx)(n.h2,{id:"request-flow",children:"Request Flow"}),"\n",(0,i.jsx)(n.p,{children:"A typical SQL query flows through these components:"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant C as Client\n    participant CH as Client Handler\n    participant SQL as SQL Processor\n    participant TM as TX Manager\n    participant PD as Placement Driver\n    participant RM as Replica Manager\n    participant SE as Storage Engine\n\n    C->>CH: SQL Query\n    CH->>SQL: Parse + Plan\n    SQL->>TM: Create TX Context\n    TM->>PD: Locate Primaries\n    PD--\x3e>TM: Lease Info\n\n    loop For each partition\n        TM->>RM: Route to Primary\n        RM->>SE: Execute on Storage\n        SE--\x3e>RM: Results\n        RM--\x3e>TM: Partition Results\n    end\n\n    TM--\x3e>SQL: Aggregated Results\n    SQL--\x3e>CH: Query Response\n    CH--\x3e>C: Response"}),"\n",(0,i.jsx)(n.h2,{id:"component-initialization-order",children:"Component Initialization Order"}),"\n",(0,i.jsx)(n.p,{children:"Components start in dependency order:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"VaultManager \u2192 ClusterService \u2192 CMG \u2192 MetaStorage \u2192 PlacementDriver \u2192\nReplicaManager \u2192 TxManager \u2192 TableManager \u2192 SqlQueryProcessor\n"})}),"\n",(0,i.jsx)(n.p,{children:"This ordering ensures each component's dependencies are available before it starts."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"./storage-architecture",children:"Storage Architecture"})," for storage layer details"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../core-concepts/data-partitioning",children:"Data Partitioning"})," for partition distribution and replication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../core-concepts/transactions-and-mvcc",children:"Transactions and MVCC"})," for transaction processing details"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);