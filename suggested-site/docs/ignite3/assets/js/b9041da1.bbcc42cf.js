"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6861],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},99603:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"sql-reference/explain-statement","title":"EXPLAIN Command","description":"{/*","source":"@site/versioned_docs/version-3.0.0/sql-reference/explain-statement.md","sourceDirName":"sql-reference","slug":"/sql-reference/explain-statement","permalink":"/suggested-site/docs/ignite3/3.0.0/sql-reference/explain-statement","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/versioned_docs/version-3.0.0/sql-reference/explain-statement.md","tags":[],"version":"3.0.0","frontMatter":{"title":"EXPLAIN Command","sidebar_label":"EXPLAIN"},"sidebar":"tutorialSidebar","previous":{"title":"SQL Conformance","permalink":"/suggested-site/docs/ignite3/3.0.0/sql-reference/sql-conformance"},"next":{"title":"EXPLAIN","permalink":"/suggested-site/docs/ignite3/3.0.0/sql-reference/explain-statement"}}');var i=s(74848),r=s(28453);const o={title:"EXPLAIN Command",sidebar_label:"EXPLAIN"},l=void 0,a={},d=[{value:"Syntax",id:"syntax",level:2},{value:"Understanding The Output",id:"understanding-the-output",level:2},{value:"Operator Naming",id:"operator-naming",level:3},{value:"Hierarchical Plan Structure",id:"hierarchical-plan-structure",level:3},{value:"Examples",id:"examples",level:2},{value:"Example: Complex Join",id:"example-complex-join",level:3},{value:"Example: Query Mapping",id:"example-query-mapping",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"EXPLAIN"})," command is used to display the execution plan of an SQL query, showing how the query will be processed by the SQL engine.\nIt provides insights into the relational operators used, their configuration, and the estimated number of rows processed at each step.\nThis information is essential for diagnosing performance bottlenecks and understanding query optimization decisions."]}),"\n",(0,i.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n","\n",(0,i.jsxs)(n.p,{children:["If neither ",(0,i.jsx)(n.code,{children:"PLAN"})," nor ",(0,i.jsx)(n.code,{children:"MAPPING"})," is specified, then ",(0,i.jsx)(n.code,{children:"PLAN"})," is implicit."]}),"\n",(0,i.jsx)(n.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PLAN"})," - explains query in terms of relational operators tree.\nThis representation is suitable for investigation of performance issues related to the optimizer."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MAPPING"})," - explains query in terms of mapping of query fragment to a particular node of the cluster.\nThis representation is suitable for investigation of performance issues related to the data colocation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN SELECT * FROM lineitem;\nEXPLAIN PLAN FOR SELECT * FROM lineitem;\nEXPLAIN MAPPING FOR SELECT * FROM lineitem;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-output",children:"Understanding The Output"}),"\n",(0,i.jsxs)(n.p,{children:["Each query plan is represented as a tree-like structure composed of ",(0,i.jsx)(n.a,{href:"/suggested-site/docs/ignite3/3.0.0/sql-reference/explain-operators-list",children:(0,i.jsx)(n.strong,{children:"relational operators"})}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A node in the plan includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"name"}),", indicating the relational operator (e.g., ",(0,i.jsx)(n.code,{children:"TableScan"}),", ",(0,i.jsx)(n.code,{children:"IndexScan"}),", ",(0,i.jsx)(n.code,{children:"Sort"}),", ",(0,i.jsx)(n.code,{children:"Join"})," types)"]}),"\n",(0,i.jsxs)(n.li,{children:["A set of ",(0,i.jsx)(n.strong,{children:"attributes"}),", relevant to that specific operator"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"OperatorName\n    attribute1: value1\n    attribute2: value2\n"})}),"\n",(0,i.jsx)(n.p,{children:"Examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"TableScan                        // Full table access\n    table: PUBLIC.EMP\n    fieldNames: [NAME, SALARY]\n    est: (rows=1)\n\nIndexScan                        // Index-based access\n    table: PUBLIC.EMP\n    index: EMP_NAME_DESC_IDX\n    type: SORTED\n    fields: [NAME]\n    collation: [NAME DESC]\n    est: (rows=1)\n\nSort                             // Sort rows\n    collation: [NAME DESC NULLS LAST]\n    est: (rows=1)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"operator-naming",children:"Operator Naming"}),"\n",(0,i.jsx)(n.p,{children:"The operator name reflects the specific algorithm or strategy used.\nFor example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TableScan"})," \u2013 Full scan of a base table."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"IndexScan"})," \u2013 Access via index, possibly sorted."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Sort"})," \u2013 Explicit sorting step."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"HashJoin"}),", ",(0,i.jsx)(n.code,{children:"MergeJoin"}),", ",(0,i.jsx)(n.code,{children:"NestedLoopJoin"})," \u2013 Types of join algorithms."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Limit"}),", ",(0,i.jsx)(n.code,{children:"Project"}),", ",(0,i.jsx)(n.code,{children:"Exchange"})," \u2013 Execution-related transformations and controls."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"hierarchical-plan-structure",children:"Hierarchical Plan Structure"}),"\n",(0,i.jsxs)(n.p,{children:["The plan is structured as a ",(0,i.jsx)(n.strong,{children:"tree"}),", where:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leaf nodes"})," represent data sources (e.g., ",(0,i.jsx)(n.code,{children:"TableScan"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Internal nodes"})," represent data transformations (e.g., ",(0,i.jsx)(n.code,{children:"Join"}),", ",(0,i.jsx)(n.code,{children:"Sort"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The root node"})," (topmost) is the final operator that produces the result"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-complex-join",children:"Example: Complex Join"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN PLAN FOR\n SELECT\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\n   FROM Users U, Reviews R, Products P\n  WHERE U.UserID = R.UserID\n    AND R.ProductID = P.ProductID\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Project\n    fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n    projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n    est: (rows=16650)\n  HashJoin\n      predicate: =(USERID$0, USERID)\n      fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\n      type: inner\n      est: (rows=16650)\n    HashJoin\n        predicate: =(PRODUCTID, PRODUCTID$0)\n        fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\n        type: inner\n        est: (rows=16650)\n      Exchange\n          distribution: single\n          est: (rows=50000)\n        TableScan\n            table: PUBLIC.REVIEWS\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n            est: (rows=50000)\n      Exchange\n          distribution: single\n          est: (rows=1665)\n        TableScan\n            table: PUBLIC.PRODUCTS\n            predicate: =(PRODUCTNAME, ||(_UTF-8'Product_', CAST(?0):VARCHAR CHARACTER SET \"UTF-8\"))\n            fieldNames: [PRODUCTID, PRODUCTNAME]\n            est: (rows=1665)\n    Exchange\n        distribution: single\n        est: (rows=10000)\n      TableScan\n          table: PUBLIC.USERS\n          fieldNames: [USERID, USERNAME]\n          est: (rows=10000)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This execution plan represents a query that joins three tables: ",(0,i.jsx)(n.code,{children:"USERS"}),", ",(0,i.jsx)(n.code,{children:"REVIEWS"}),", and ",(0,i.jsx)(n.code,{children:"PRODUCTS"}),", and selects four fields after filtering by product name."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Project"})," (root node):\nOutputs the final selected fields \u2014 ",(0,i.jsx)(n.code,{children:"USERNAME"}),", ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),", ",(0,i.jsx)(n.code,{children:"REVIEWTEXT"}),", and ",(0,i.jsx)(n.code,{children:"RATING"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"HashJoins"})," (two levels):\nPerform the inner joins."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The first (bottom-most) joins ",(0,i.jsx)(n.code,{children:"REVIEWS"})," with ",(0,i.jsx)(n.code,{children:"PRODUCTS"})," on ",(0,i.jsx)(n.code,{children:"PRODUCTID"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The second joins the result with ",(0,i.jsx)(n.code,{children:"USERS"})," on ",(0,i.jsx)(n.code,{children:"USERID"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TableScans"}),":\nEach table is scanned:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"REVIEWS"})," is fully scanned."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"PRODUCTS"})," is scanned with a filter on ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"USERS"})," is fully scanned."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exchange"})," nodes:\nIndicate data redistribution between operators."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each node includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fieldNames"}),": Output columns at that stage."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"predicate"}),": Join or filter condition."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"est"}),": Estimated number of rows at that point in the plan."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-query-mapping",children:"Example: Query Mapping"}),"\n",(0,i.jsx)(n.p,{children:"A result of the EXPLAIN MAPPING command includes additional metadata providing insight into how the query is mapped on cluster topology.\nSo, for the command like below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXPLAIN MAPPING FOR\n SELECT\n      U.UserName, P.ProductName, R.ReviewText, R.Rating\n   FROM Users U, Reviews R, Products P\n  WHERE U.UserID = R.UserID\n    AND R.ProductID = P.ProductID\n    AND P.ProductName = 'Product_' || ?::varchar\n"})}),"\n",(0,i.jsx)(n.p,{children:"The resulting output is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Fragment#0 root\n  distribution: single\n  executionNodes: [node_1]\n  tree:\n    Project\n        fieldNames: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n        projection: [USERNAME, PRODUCTNAME, REVIEWTEXT, RATING]\n        est: (rows=1)\n      HashJoin\n          predicate: =(USERID$0, USERID)\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME, USERID$0, USERNAME]\n          type: inner\n          est: (rows=1)\n        HashJoin\n            predicate: =(PRODUCTID, PRODUCTID$0)\n            fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING, PRODUCTID$0, PRODUCTNAME]\n            type: inner\n            est: (rows=1)\n          Receiver\n              fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n              sourceFragmentId: 1\n              est: (rows=1)\n          Receiver\n              fieldNames: [PRODUCTID, PRODUCTNAME]\n              sourceFragmentId: 2\n              est: (rows=1)\n        Receiver\n            fieldNames: [USERID, USERNAME]\n            sourceFragmentId: 3\n            est: (rows=1)\n\nFragment#1\n  distribution: random\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [REVIEWS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=50000)\n      TableScan\n          table: PUBLIC.REVIEWS\n          fieldNames: [PRODUCTID, USERID, REVIEWTEXT, RATING]\n          est: (rows=50000)\n\nFragment#2\n  distribution: table PUBLIC.PRODUCTS in zone "Default"\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [PRODUCTS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=1665)\n      TableScan\n          table: PUBLIC.PRODUCTS\n          predicate: =(PRODUCTNAME, ||(_UTF-8\'Product_\', CAST(?0):VARCHAR CHARACTER SET "UTF-8"))\n          fieldNames: [PRODUCTID, PRODUCTNAME]\n          est: (rows=1665)\n\nFragment#3\n  distribution: table PUBLIC.USERS in zone "Default"\n  executionNodes: [node_1, node_2, node_3]\n  partitions: [USERS=[node_1={0, 2, 5, 6, 7, 8, 9, 10, 12, 13, 20}, node_2={1, 3, 11, 19, 21, 22, 23, 24}, node_3={4, 14, 15, 16, 17, 18}]]\n  tree:\n    Sender\n        distribution: single\n        targetFragmentId: 0\n        est: (rows=10000)\n      TableScan\n          table: PUBLIC.USERS\n          fieldNames: [USERID, USERNAME]\n          est: (rows=10000)\n'})}),"\n",(0,i.jsx)(n.p,{children:"where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fragment#0"})," means fragment with id=0"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"root"})," marks a fragment which is considered as root fragment, i.e. a fragment which represents user's cursor"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"distribution"})," attribute provides an insight into which mapping strategy was applied to this particular fragment"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"executionNodes"})," attribute provides a list of nodes this fragment will be executed on"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"partitions"})," attribute provides an insight into which partitions of which tables will be read from which nodes"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.strong,{children:"tree"})," attribute specifies which part of the relational tree corresponds to this fragment"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The output above shows how the query is broken into multiple execution fragments and distributed across the cluster. It gives insight into both the logical execution plan and how it maps to the physical topology."}),"\n",(0,i.jsxs)(n.p,{children:["The query starts execution in ",(0,i.jsx)(n.em,{children:"Fragment#0"}),", which serves as the root of the plan \u2014 this is where the final result is produced. It runs on a single node (",(0,i.jsx)(n.code,{children:"node_1"}),") and contains the main logic of the query, including the projection and two nested hash joins. Instead of scanning tables directly, it receives data from other fragments through ",(0,i.jsx)(n.code,{children:"Receiver"})," operators. These incoming streams correspond to the ",(0,i.jsx)(n.code,{children:"REVIEWS"}),", ",(0,i.jsx)(n.code,{children:"PRODUCTS"}),", and ",(0,i.jsx)(n.code,{children:"USERS"})," tables."]}),"\n",(0,i.jsxs)(n.p,{children:["The actual table scans happen in ",(0,i.jsx)(n.em,{children:"Fragments 1 through 3"}),", each responsible for one of the involved tables. These fragments operate in parallel across the cluster. Each performs a scan on its respective table and then sends the results back to Fragment#0."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#1"})," handles the ",(0,i.jsx)(n.code,{children:"REVIEWS"})," table. It runs on all nodes and uses a random distribution strategy. Data is partitioned across nodes, and after scanning the table, results are sent upstream."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#2"})," is in charge of the ",(0,i.jsx)(n.code,{children:"PRODUCTS"})," table. It also spans all nodes but follows a zone-based distribution linked to the table's partitioning. There's a filter applied to ",(0,i.jsx)(n.code,{children:"PRODUCTNAME"}),", which limits the amount of data sent to the root."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Fragment#3"})," covers the ",(0,i.jsx)(n.code,{children:"USERS"})," table. Like the others, it's distributed and reads from table partitions spread across the cluster."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Each fragment includes metadata such as the nodes it's executed on, how data is partitioned, and how results are sent between fragments. This layout provides a clear view of not only how the query is logically processed, but also how the workload is split and coordinated in a distributed environment."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);