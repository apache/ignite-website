"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9883],{28453:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function c(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:c(n.components),a.createElement(s.Provider,{value:e},n.children)}},46513:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"api-reference/native-clients/java/transactions-api","title":"Transactions API","description":"The Transactions API provides ACID guarantees for operations spanning multiple tables or operations. Applications use transactions to ensure data consistency when executing related updates that must succeed or fail as a unit.","source":"@site/docs/api-reference/native-clients/java/transactions-api.md","sourceDirName":"api-reference/native-clients/java","slug":"/api-reference/native-clients/java/transactions-api","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/transactions-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/java/transactions-api.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Transactions API","id":"transactions-api","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"SQL API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/sql-api"},"next":{"title":"Compute API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/java/compute-api"}}');var i=t(74848),s=t(28453);const c={title:"Transactions API",id:"transactions-api",sidebar_position:6},r="Transactions API",o={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Implicit Transactions",id:"implicit-transactions",level:2},{value:"Return Values from Transactions",id:"return-values-from-transactions",level:2},{value:"Explicit Transactions",id:"explicit-transactions",level:2},{value:"Read-Only Transactions",id:"read-only-transactions",level:2},{value:"Transaction Timeouts",id:"transaction-timeouts",level:2},{value:"Multi-Table Transactions",id:"multi-table-transactions",level:2},{value:"Asynchronous Transactions",id:"asynchronous-transactions",level:2},{value:"Async Transaction Closures",id:"async-transaction-closures",level:2},{value:"SQL and Transactions",id:"sql-and-transactions",level:2},{value:"Transaction Status",id:"transaction-status",level:2},{value:"Idempotent Operations",id:"idempotent-operations",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Exception Types",id:"exception-types",level:2},{value:"Reference",id:"reference",level:2},{value:"IgniteTransactions Methods",id:"ignitetransactions-methods",level:3},{value:"Transaction Methods",id:"transaction-methods",level:3},{value:"TransactionOptions Configuration",id:"transactionoptions-configuration",level:3},{value:"Transaction Isolation",id:"transaction-isolation",level:3},{value:"Transaction Best Practices",id:"transaction-best-practices",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"transactions-api",children:"Transactions API"})}),"\n",(0,i.jsx)(e.p,{children:"The Transactions API provides ACID guarantees for operations spanning multiple tables or operations. Applications use transactions to ensure data consistency when executing related updates that must succeed or fail as a unit."}),"\n",(0,i.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(e.p,{children:"Read-write transactions execute with SERIALIZABLE isolation. Operations within a transaction see a consistent view of data as it existed when the transaction started. Changes remain invisible to other transactions until commit."}),"\n",(0,i.jsx)(e.p,{children:"The API supports explicit transaction management and closure-based implicit transactions. Closure-based transactions automatically commit on normal completion and rollback on exceptions, reducing boilerplate code."}),"\n",(0,i.jsx)(e.p,{children:"Transactions have configurable timeouts. Read-write transactions default to 30 seconds. Read-only transactions optimize for read operations by eliminating write overhead."}),"\n",(0,i.jsx)(e.h2,{id:"implicit-transactions",children:"Implicit Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Use runInTransaction for automatic lifecycle management:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'ignite.transactions().runInTransaction(tx -> {\n    RecordView<Tuple> view = ignite.tables().table("accounts").recordView();\n\n    Tuple key = Tuple.create().set("id", 1);\n    Tuple record = view.get(tx, key);\n\n    int balance = record.intValue("balance");\n    record.set("balance", balance + 100);\n\n    view.put(tx, record);\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"The transaction commits automatically when the closure completes normally. Exceptions trigger automatic rollback."}),"\n",(0,i.jsx)(e.h2,{id:"return-values-from-transactions",children:"Return Values from Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Return values from transaction closures:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'int newBalance = ignite.transactions().runInTransaction(tx -> {\n    RecordView<Tuple> view = ignite.tables().table("accounts").recordView();\n\n    Tuple key = Tuple.create().set("id", 1);\n    Tuple record = view.get(tx, key);\n\n    int balance = record.intValue("balance") + 100;\n    record.set("balance", balance);\n    view.put(tx, record);\n\n    return balance;\n});\n\nSystem.out.println("New balance: " + newBalance);\n'})}),"\n",(0,i.jsx)(e.h2,{id:"explicit-transactions",children:"Explicit Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Manage transaction lifecycle explicitly:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'Transaction tx = ignite.transactions().begin();\ntry {\n    RecordView<Tuple> view = ignite.tables().table("accounts").recordView();\n\n    Tuple key = Tuple.create().set("id", 1);\n    Tuple record = view.get(tx, key);\n\n    record.set("balance", record.intValue("balance") + 100);\n    view.put(tx, record);\n\n    tx.commit();\n} catch (Exception e) {\n    tx.rollback();\n    throw e;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Explicit management provides control over commit timing and error handling."}),"\n",(0,i.jsx)(e.h2,{id:"read-only-transactions",children:"Read-Only Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Optimize read operations with read-only transactions:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'TransactionOptions options = new TransactionOptions().readOnly(true);\n\nignite.transactions().runInTransaction(options, tx -> {\n    RecordView<Tuple> view = ignite.tables().table("users").recordView();\n\n    Tuple key = Tuple.create().set("id", 1);\n    Tuple record = view.get(tx, key);\n\n    System.out.println("User: " + record.stringValue("name"));\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"Read-only transactions eliminate write coordination overhead, improving performance for read operations."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-timeouts",children:"Transaction Timeouts"}),"\n",(0,i.jsx)(e.p,{children:"Configure transaction timeouts:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"TransactionOptions options = new TransactionOptions().timeoutMillis(60000);\n\nTransaction tx = ignite.transactions().begin(options);\n"})}),"\n",(0,i.jsx)(e.p,{children:"Transactions that exceed the timeout automatically rollback. This prevents long-running transactions from blocking other operations."}),"\n",(0,i.jsx)(e.h2,{id:"multi-table-transactions",children:"Multi-Table Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Execute operations across multiple tables:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'ignite.transactions().runInTransaction(tx -> {\n    RecordView<Tuple> accounts = ignite.tables().table("accounts").recordView();\n    RecordView<Tuple> history = ignite.tables().table("history").recordView();\n\n    Tuple accountKey = Tuple.create().set("id", 1);\n    Tuple account = accounts.get(tx, accountKey);\n\n    int balance = account.intValue("balance");\n    account.set("balance", balance - 50);\n    accounts.put(tx, account);\n\n    Tuple historyRecord = Tuple.create()\n        .set("account_id", 1)\n        .set("amount", -50)\n        .set("timestamp", LocalDateTime.now());\n    history.put(tx, historyRecord);\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"Both operations commit or rollback together."}),"\n",(0,i.jsx)(e.h2,{id:"asynchronous-transactions",children:"Asynchronous Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Create transactions asynchronously:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'ignite.transactions().beginAsync().thenCompose(tx ->\n    ignite.tables().tableAsync("accounts")\n        .thenCompose(table -> {\n            RecordView<Tuple> view = table.recordView();\n            Tuple key = Tuple.create().set("id", 1);\n            return view.getAsync(tx, key)\n                .thenCompose(record -> {\n                    record.set("balance", record.intValue("balance") + 100);\n                    return view.putAsync(tx, record);\n                })\n                .thenCompose(v -> tx.commitAsync());\n        })\n).exceptionally(ex -> {\n    return null;\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"Asynchronous transactions enable non-blocking transaction processing."}),"\n",(0,i.jsx)(e.h2,{id:"async-transaction-closures",children:"Async Transaction Closures"}),"\n",(0,i.jsx)(e.p,{children:"Use async closures for non-blocking transaction execution:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'CompletableFuture<Integer> resultFuture =\n    ignite.transactions().runInTransactionAsync(tx ->\n        ignite.tables().tableAsync("accounts")\n            .thenCompose(table -> {\n                RecordView<Tuple> view = table.recordView();\n                Tuple key = Tuple.create().set("id", 1);\n                return view.getAsync(tx, key);\n            })\n            .thenApply(record -> {\n                int balance = record.intValue("balance") + 100;\n                record.set("balance", balance);\n                return balance;\n            })\n    );\n\nresultFuture.thenAccept(balance ->\n    System.out.println("New balance: " + balance)\n);\n'})}),"\n",(0,i.jsx)(e.h2,{id:"sql-and-transactions",children:"SQL and Transactions"}),"\n",(0,i.jsx)(e.p,{children:"Execute SQL within transactions:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'ignite.transactions().runInTransaction(tx -> {\n    try (ResultSet<SqlRow> rs = ignite.sql().execute(\n        tx,\n        "SELECT balance FROM accounts WHERE id = ?",\n        1\n    )) {\n        SqlRow row = rs.next();\n        int balance = row.intValue("balance");\n\n        ignite.sql().execute(\n            tx,\n            "UPDATE accounts SET balance = ? WHERE id = ?",\n            balance + 100,\n            1\n        ).close();\n    }\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"SQL statements and table operations within the same transaction see consistent data."}),"\n",(0,i.jsx)(e.h2,{id:"transaction-status",children:"Transaction Status"}),"\n",(0,i.jsx)(e.p,{children:"Check transaction properties:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'Transaction tx = ignite.transactions().begin();\n\nboolean readOnly = tx.isReadOnly();\nSystem.out.println("Read-only: " + readOnly);\n\n// Use transaction\ntx.commit();\n'})}),"\n",(0,i.jsx)(e.h2,{id:"idempotent-operations",children:"Idempotent Operations"}),"\n",(0,i.jsx)(e.p,{children:"Commit and rollback operations are idempotent:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Transaction tx = ignite.transactions().begin();\ntry {\n    // Operations\n    tx.commit();\n} finally {\n    tx.rollback(); // Safe even if already committed\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"Calling commit or rollback on completed transactions has no effect."}),"\n",(0,i.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(e.p,{children:"Handle transaction-specific exceptions:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'try {\n    ignite.transactions().runInTransaction(tx -> {\n        // Operations\n    });\n} catch (RetriableTransactionException e) {\n    // Transaction can be retried\n    System.err.println("Retry transaction: " + e.getMessage());\n} catch (TransactionException e) {\n    // Transaction error\n    System.err.println("Transaction failed: " + e.getMessage());\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"RetriableTransactionException indicates conflicts that may succeed on retry. Other TransactionException subtypes indicate non-retriable errors."}),"\n",(0,i.jsx)(e.h2,{id:"exception-types",children:"Exception Types"}),"\n",(0,i.jsx)(e.p,{children:"Common transaction exceptions:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'try {\n    ignite.transactions().runInTransaction(tx -> {\n        // Operations\n    });\n} catch (IncompatibleSchemaException e) {\n    // Schema changed during transaction\n    System.err.println("Schema incompatible: " + e.getMessage());\n} catch (MismatchingTransactionOutcomeException e) {\n    // Inconsistent commit/rollback across replicas\n    System.err.println("Outcome mismatch: " + e.getMessage());\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"IncompatibleSchemaException occurs when table schemas change during transaction execution. MismatchingTransactionOutcomeException indicates inconsistent transaction outcomes."}),"\n",(0,i.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Transaction manager: ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.IgniteTransactions"})]}),"\n",(0,i.jsxs)(e.li,{children:["Transaction handle: ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.Transaction"})]}),"\n",(0,i.jsxs)(e.li,{children:["Configuration: ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.TransactionOptions"})]}),"\n",(0,i.jsxs)(e.li,{children:["Exceptions: ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.TransactionException"}),", ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.RetriableTransactionException"}),", ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.IncompatibleSchemaException"}),", ",(0,i.jsx)(e.code,{children:"org.apache.ignite.tx.MismatchingTransactionOutcomeException"})]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"ignitetransactions-methods",children:"IgniteTransactions Methods"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Transaction begin()"})," - Start transaction with defaults"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"Transaction begin(TransactionOptions)"})," - Start with configuration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"CompletableFuture<Transaction> beginAsync()"})," - Async start"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"CompletableFuture<Transaction> beginAsync(TransactionOptions)"})," - Async start with configuration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"void runInTransaction(Consumer<Transaction>)"})," - Execute in transaction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<T> T runInTransaction(Function<Transaction, T>)"})," - Execute with return value"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"void runInTransaction(TransactionOptions, Consumer<Transaction>)"})," - Execute with options"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<T> T runInTransaction(TransactionOptions, Function<Transaction, T>)"})," - Execute with options and return"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<T> CompletableFuture<T> runInTransactionAsync(Function<Transaction, CompletableFuture<T>>)"})," - Async execution"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"transaction-methods",children:"Transaction Methods"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"void commit()"})," - Commit transaction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"CompletableFuture<Void> commitAsync()"})," - Async commit"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"void rollback()"})," - Rollback transaction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"CompletableFuture<Void> rollbackAsync()"})," - Async rollback"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"boolean isReadOnly()"})," - Check read-only status"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"transactionoptions-configuration",children:"TransactionOptions Configuration"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"readOnly(boolean)"})," - Set read-only mode"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"timeoutMillis(long)"})," - Set transaction timeout in milliseconds"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"transaction-isolation",children:"Transaction Isolation"}),"\n",(0,i.jsx)(e.p,{children:"Read-write transactions use SERIALIZABLE isolation. Each transaction acquires locks during the first read or write access and holds the lock until the transaction is committed or rolled back. Changes remain invisible to concurrent transactions until commit. Read-only transactions provide a snapshot view of data without acquiring locks."}),"\n",(0,i.jsx)(e.h3,{id:"transaction-best-practices",children:"Transaction Best Practices"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Use implicit transactions (runInTransaction) for automatic lifecycle management"}),"\n",(0,i.jsx)(e.li,{children:"Configure appropriate timeouts to prevent blocking operations"}),"\n",(0,i.jsx)(e.li,{children:"Use read-only transactions for operations that only read data"}),"\n",(0,i.jsx)(e.li,{children:"Handle RetriableTransactionException by retrying operations"}),"\n",(0,i.jsx)(e.li,{children:"Keep transactions short to minimize lock contention"}),"\n",(0,i.jsx)(e.li,{children:"Avoid user interaction or slow operations within transactions"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);