"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2355],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(96540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},98415:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api-reference/native-clients/cpp/compute-api","title":"Compute API","description":"The Compute API executes distributed compute jobs across cluster nodes. It supports single-node execution, multi-node execution, colocated execution, and broadcast patterns.","source":"@site/docs/api-reference/native-clients/cpp/compute-api.md","sourceDirName":"api-reference/native-clients/cpp","slug":"/api-reference/native-clients/cpp/compute-api","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/cpp/compute-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/api-reference/native-clients/cpp/compute-api.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Compute API","id":"compute-api","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Transactions API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/cpp/transactions-api"},"next":{"title":"Network API","permalink":"/suggested-site/docs/ignite3/3.1.0/api-reference/native-clients/cpp/network-api"}}');var o=t(74848),i=t(28453);const r={title:"Compute API",id:"compute-api",sidebar_position:5},a="Compute API",c={},l=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"Job Execution Model",id:"job-execution-model",level:3},{value:"Job Targeting",id:"job-targeting",level:3},{value:"Job Descriptors",id:"job-descriptors",level:3},{value:"Execution Handles",id:"execution-handles",level:3},{value:"Broadcast Execution",id:"broadcast-execution",level:3},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Getting Cluster Nodes",id:"getting-cluster-nodes",level:3},{value:"Submitting Jobs",id:"submitting-jobs",level:3},{value:"Async Submission",id:"async-submission",level:3},{value:"Job Targets",id:"job-targets",level:2},{value:"Single Node Target",id:"single-node-target",level:3},{value:"Any Node Target",id:"any-node-target",level:3},{value:"Colocated Target",id:"colocated-target",level:3},{value:"Job Descriptors",id:"job-descriptors-1",level:2},{value:"Building Descriptors",id:"building-descriptors",level:3},{value:"Descriptor Components",id:"descriptor-components",level:3},{value:"Job Execution",id:"job-execution",level:2},{value:"Monitoring Execution",id:"monitoring-execution",level:3},{value:"Retrieving Results",id:"retrieving-results",level:3},{value:"Execution Information",id:"execution-information",level:3},{value:"Job Control",id:"job-control",level:2},{value:"Cancelling Jobs",id:"cancelling-jobs",level:3},{value:"Changing Priority",id:"changing-priority",level:3},{value:"Broadcast Execution",id:"broadcast-execution-1",level:2},{value:"Broadcasting to Multiple Nodes",id:"broadcasting-to-multiple-nodes",level:3},{value:"Async Broadcast",id:"async-broadcast",level:3},{value:"Processing Broadcast Results",id:"processing-broadcast-results",level:3},{value:"Binary Arguments",id:"binary-arguments",level:2},{value:"Passing Primitive Arguments",id:"passing-primitive-arguments",level:3},{value:"Passing Complex Arguments",id:"passing-complex-arguments",level:3},{value:"No Argument Jobs",id:"no-argument-jobs",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Handling Job Errors",id:"handling-job-errors",level:3},{value:"Handling Submission Errors",id:"handling-submission-errors",level:3},{value:"Use Cases",id:"use-cases",level:2},{value:"Map-Reduce Pattern",id:"map-reduce-pattern",level:3},{value:"Colocated Processing",id:"colocated-processing",level:3},{value:"Batch Job Submission",id:"batch-job-submission",level:3},{value:"Reference",id:"reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"compute-api",children:"Compute API"})}),"\n",(0,o.jsx)(n.p,{children:"The Compute API executes distributed compute jobs across cluster nodes. It supports single-node execution, multi-node execution, colocated execution, and broadcast patterns."}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(n.h3,{id:"job-execution-model",children:"Job Execution Model"}),"\n",(0,o.jsx)(n.p,{children:"Jobs are Java classes deployed on cluster nodes. The C++ client submits job execution requests with binary arguments. The server executes the job and returns results as binary objects."}),"\n",(0,o.jsx)(n.h3,{id:"job-targeting",children:"Job Targeting"}),"\n",(0,o.jsx)(n.p,{children:"Jobs execute on specific nodes based on targeting strategies:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Single Node"})," - Execute on one specific node"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Any Node"})," - Execute on any node from a set"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Colocated"})," - Execute on the node containing table partition data"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Broadcast"})," - Execute on all nodes in a set"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"job-descriptors",children:"Job Descriptors"}),"\n",(0,o.jsx)(n.p,{children:"Job descriptors specify the job class name, deployment units, and execution options. Deployment units identify code locations on the cluster. Execution options configure priority and other runtime parameters."}),"\n",(0,o.jsx)(n.h3,{id:"execution-handles",children:"Execution Handles"}),"\n",(0,o.jsx)(n.p,{children:"Submit operations return execution handles. Handles provide job monitoring, result retrieval, priority changes, and cancellation. Results become available after job completion."}),"\n",(0,o.jsx)(n.h3,{id:"broadcast-execution",children:"Broadcast Execution"}),"\n",(0,o.jsx)(n.p,{children:"Broadcast submits a single job to multiple nodes. It returns a broadcast execution handle containing individual execution handles for each node."}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,o.jsx)(n.h3,{id:"getting-cluster-nodes",children:"Getting Cluster Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Retrieve cluster topology:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'using namespace ignite;\n\nauto nodes = client.get_cluster_nodes();\n\nfor (const auto& node : nodes) {\n    std::cout << "Node: " << node.get_name() << std::endl;\n    std::cout << "ID: " << node.get_id() << std::endl;\n    std::cout << "Address: " << node.get_address().host\n              << ":" << node.get_address().port << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"submitting-jobs",children:"Submitting Jobs"}),"\n",(0,o.jsx)(n.p,{children:"Submit a job to any node:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto compute = client.get_compute();\nauto nodes = client.get_cluster_nodes();\n\nauto descriptor = job_descriptor::builder("com.example.MyJob").build();\nauto target = job_target::any_node(nodes);\n\nbinary_object arg;  // Job argument\nauto execution = compute.submit(target, descriptor, arg);\n\nauto result = execution.get_result();\nif (result.has_value()) {\n    // Process result\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"async-submission",children:"Async Submission"}),"\n",(0,o.jsx)(n.p,{children:"Submit without blocking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"compute.submit_async(target, descriptor, arg,\n    [](ignite_result<job_execution> result) {\n        if (!result.has_error()) {\n            auto execution = std::move(result).value();\n            // Use execution handle\n        }\n    });\n"})}),"\n",(0,o.jsx)(n.h2,{id:"job-targets",children:"Job Targets"}),"\n",(0,o.jsx)(n.h3,{id:"single-node-target",children:"Single Node Target"}),"\n",(0,o.jsx)(n.p,{children:"Execute on a specific node:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\nauto target_node = nodes[0];\n\nauto target = job_target::node(target_node);\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"any-node-target",children:"Any Node Target"}),"\n",(0,o.jsx)(n.p,{children:"Execute on any node from a set:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\nauto target = job_target::any_node(nodes);\n\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Create from vector:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"std::vector<cluster_node> node_list = {node1, node2, node3};\nauto target = job_target::any_node(node_list);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Create from set:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"std::set<cluster_node> node_set = {node1, node2, node3};\nauto target = job_target::any_node(node_set);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"colocated-target",children:"Colocated Target"}),"\n",(0,o.jsx)(n.p,{children:"Execute on the node containing table data:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'ignite_tuple key{{"id", 42}};\nauto target = job_target::colocated("accounts", key);\n\nauto execution = compute.submit(target, descriptor, arg);\n'})}),"\n",(0,o.jsx)(n.p,{children:"Use qualified table names:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'qualified_name table_name = qualified_name::parse("my_schema.accounts");\nauto target = job_target::colocated(table_name, key);\n'})}),"\n",(0,o.jsx)(n.p,{children:"Colocated execution minimizes network overhead by running compute jobs where data resides."}),"\n",(0,o.jsx)(n.h2,{id:"job-descriptors-1",children:"Job Descriptors"}),"\n",(0,o.jsx)(n.h3,{id:"building-descriptors",children:"Building Descriptors"}),"\n",(0,o.jsx)(n.p,{children:"Create a basic descriptor:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto descriptor = job_descriptor::builder("com.example.MyJob").build();\n'})}),"\n",(0,o.jsx)(n.p,{children:"Add deployment units:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'std::vector<deployment_unit> units{\n    {"my-app", "1.0.0"},\n    {"my-lib", "2.1.0"}\n};\n\nauto descriptor = job_descriptor::builder("com.example.MyJob")\n    .deployment_units(units)\n    .build();\n'})}),"\n",(0,o.jsx)(n.p,{children:"Add execution options:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'job_execution_options opts;\nopts.priority(10);\n\nauto descriptor = job_descriptor::builder("com.example.MyJob")\n    .execution_options(opts)\n    .build();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"descriptor-components",children:"Descriptor Components"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Job Class Name"})," - Fully qualified Java class name implementing the compute job interface"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Deployment Units"})," - List of units containing job code and dependencies"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Execution Options"})," - Priority and other runtime configuration"]}),"\n",(0,o.jsx)(n.h2,{id:"job-execution",children:"Job Execution"}),"\n",(0,o.jsx)(n.h3,{id:"monitoring-execution",children:"Monitoring Execution"}),"\n",(0,o.jsx)(n.p,{children:"Check job state:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto execution = compute.submit(target, descriptor, arg);\n\nauto state = execution.get_state();\nif (state.has_value()) {\n    // Examine state\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Get state asynchronously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"execution.get_state_async([](ignite_result<std::optional<job_state>> result) {\n    if (!result.has_error()) {\n        auto state = std::move(result).value();\n        if (state.has_value()) {\n            // Examine state\n        }\n    }\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"State may be unavailable if the job has expired from the execution history."}),"\n",(0,o.jsx)(n.h3,{id:"retrieving-results",children:"Retrieving Results"}),"\n",(0,o.jsx)(n.p,{children:"Get result (blocks until completion):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto result = execution.get_result();\n\nif (result.has_value()) {\n    auto data = result.value();\n    // Process binary object\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Get result asynchronously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"execution.get_result_async([](ignite_result<std::optional<binary_object>> result) {\n    if (!result.has_error()) {\n        auto obj = std::move(result).value();\n        if (obj.has_value()) {\n            // Process result\n        }\n    }\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"execution-information",children:"Execution Information"}),"\n",(0,o.jsx)(n.p,{children:"Access execution metadata:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto job_id = execution.get_id();\nauto node = execution.get_node();\n\nstd::cout << "Job ID: " << job_id << std::endl;\nstd::cout << "Executing on: " << node.get_name() << std::endl;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"job-control",children:"Job Control"}),"\n",(0,o.jsx)(n.h3,{id:"cancelling-jobs",children:"Cancelling Jobs"}),"\n",(0,o.jsx)(n.p,{children:"Cancel a running job:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto execution = compute.submit(target, descriptor, arg);\n\nauto result = execution.cancel();\n\nswitch (result) {\n    case job_execution::operation_result::SUCCESS:\n        std::cout << "Job cancelled" << std::endl;\n        break;\n    case job_execution::operation_result::INVALID_STATE:\n        std::cout << "Job already completed" << std::endl;\n        break;\n    case job_execution::operation_result::NOT_FOUND:\n        std::cout << "Job not found" << std::endl;\n        break;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Cancel asynchronously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"execution.cancel_async([](ignite_result<job_execution::operation_result> result) {\n    if (!result.has_error()) {\n        auto status = result.value();\n        // Check status\n    }\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"changing-priority",children:"Changing Priority"}),"\n",(0,o.jsx)(n.p,{children:"Modify job execution priority:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto execution = compute.submit(target, descriptor, arg);\n\nauto result = execution.change_priority(5);\n\nif (result == job_execution::operation_result::SUCCESS) {\n    std::cout << "Priority changed" << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Change priority asynchronously:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"execution.change_priority_async(5,\n    [](ignite_result<job_execution::operation_result> result) {\n        // Handle result\n    });\n"})}),"\n",(0,o.jsx)(n.p,{children:"Higher priority values execute before lower priority jobs in the queue."}),"\n",(0,o.jsx)(n.h2,{id:"broadcast-execution-1",children:"Broadcast Execution"}),"\n",(0,o.jsx)(n.h3,{id:"broadcasting-to-multiple-nodes",children:"Broadcasting to Multiple Nodes"}),"\n",(0,o.jsx)(n.p,{children:"Execute on all nodes in a set:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\nstd::set<cluster_node> node_set(nodes.begin(), nodes.end());\n\nauto target = broadcast_job_target::nodes(node_set);\nauto broadcast = compute.submit_broadcast(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Broadcast to a single node:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto target = broadcast_job_target::node(specific_node);\nauto broadcast = compute.submit_broadcast(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"async-broadcast",children:"Async Broadcast"}),"\n",(0,o.jsx)(n.p,{children:"Submit broadcast without blocking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"compute.submit_broadcast_async(target, descriptor, arg,\n    [](ignite_result<broadcast_execution> result) {\n        if (!result.has_error()) {\n            auto broadcast = std::move(result).value();\n            // Use broadcast execution\n        }\n    });\n"})}),"\n",(0,o.jsx)(n.h3,{id:"processing-broadcast-results",children:"Processing Broadcast Results"}),"\n",(0,o.jsx)(n.p,{children:"Access individual executions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'auto broadcast = compute.submit_broadcast(target, descriptor, arg);\nauto executions = broadcast.get_job_executions();\n\nfor (auto& exec_result : executions) {\n    if (exec_result.has_value()) {\n        auto execution = exec_result.value();\n        auto result = execution.get_result();\n\n        if (result.has_value()) {\n            std::cout << "Node " << execution.get_node().get_name()\n                      << " result: " << /* process result */ << std::endl;\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Each execution in the broadcast operates independently. Retrieve results individually from each execution handle."}),"\n",(0,o.jsx)(n.h2,{id:"binary-arguments",children:"Binary Arguments"}),"\n",(0,o.jsx)(n.h3,{id:"passing-primitive-arguments",children:"Passing Primitive Arguments"}),"\n",(0,o.jsx)(n.p,{children:"Jobs accept binary_object arguments. Wrap primitive values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"binary_object arg(42);  // Integer argument\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"passing-complex-arguments",children:"Passing Complex Arguments"}),"\n",(0,o.jsx)(n.p,{children:"Create binary objects from serialized data:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"// Serialize your data structure to bytes\nstd::vector<std::byte> data = serialize_my_data(my_object);\nbinary_object arg(data);\n\nauto execution = compute.submit(target, descriptor, arg);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"no-argument-jobs",children:"No Argument Jobs"}),"\n",(0,o.jsx)(n.p,{children:"Pass empty binary object for jobs without arguments:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"binary_object empty_arg;\nauto execution = compute.submit(target, descriptor, empty_arg);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.h3,{id:"handling-job-errors",children:"Handling Job Errors"}),"\n",(0,o.jsx)(n.p,{children:"Job execution errors propagate to the client:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'try {\n    auto result = execution.get_result();\n    // Process result\n} catch (const ignite_error& e) {\n    std::cerr << "Job failed: " << e.what_str() << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"With async operations:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'execution.get_result_async([](ignite_result<std::optional<binary_object>> result) {\n    if (result.has_error()) {\n        std::cerr << "Error: " << result.error().what_str() << std::endl;\n    } else {\n        // Process result\n    }\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"handling-submission-errors",children:"Handling Submission Errors"}),"\n",(0,o.jsx)(n.p,{children:"Handle submission failures:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'try {\n    auto execution = compute.submit(target, descriptor, arg);\n} catch (const ignite_error& e) {\n    std::cerr << "Submission failed: " << e.what_str() << std::endl;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Common errors include missing deployment units, invalid job class names, and network failures."}),"\n",(0,o.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsx)(n.h3,{id:"map-reduce-pattern",children:"Map-Reduce Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Submit jobs to multiple nodes and aggregate results:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"auto nodes = client.get_cluster_nodes();\nstd::vector<job_execution> executions;\n\n// Map: Submit jobs to all nodes\nfor (const auto& node : nodes) {\n    auto target = job_target::node(node);\n    executions.push_back(compute.submit(target, map_job, arg));\n}\n\n// Reduce: Collect and aggregate results\nstd::vector<binary_object> results;\nfor (auto& execution : executions) {\n    auto result = execution.get_result();\n    if (result.has_value()) {\n        results.push_back(result.value());\n    }\n}\n\nauto final_result = reduce(results);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"colocated-processing",children:"Colocated Processing"}),"\n",(0,o.jsx)(n.p,{children:"Process data where it resides:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'// Execute compute job on the node containing this key\nignite_tuple key{{"customer_id", 12345}};\nauto target = job_target::colocated("orders", key);\n\nauto descriptor = job_descriptor::builder("com.example.OrderProcessor").build();\nauto execution = compute.submit(target, descriptor, arg);\n\nauto result = execution.get_result();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"batch-job-submission",children:"Batch Job Submission"}),"\n",(0,o.jsx)(n.p,{children:"Submit multiple jobs in parallel:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"std::vector<job_execution> executions;\n\nfor (const auto& work_item : work_items) {\n    auto execution = compute.submit(target, descriptor, work_item);\n    executions.push_back(std::move(execution));\n}\n\n// Wait for all to complete\nfor (auto& execution : executions) {\n    execution.get_result();\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://ignite.apache.org/releases/ignite3/latest/cpp-api/",children:"C++ API Documentation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"../../../develop/work-with-data/compute",children:"Compute Concept"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"./client-api",children:"Client API"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"./network-api",children:"Network API"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);