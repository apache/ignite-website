"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6299],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},36304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"understand/core-concepts/what-is-ignite","title":"What is Apache Ignite 3?","description":"Apache Ignite is a distributed database designed for high-performance transactional and analytical workloads. It combines in-memory speed with disk persistence, providing both SQL and key-value access to the same data with full ACID transaction support.","source":"@site/docs/understand/core-concepts/what-is-ignite.md","sourceDirName":"understand/core-concepts","slug":"/understand/core-concepts/what-is-ignite","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/what-is-ignite","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ignite-3/tree/main/docs/docs/understand/core-concepts/what-is-ignite.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"what-is-ignite","title":"What is Apache Ignite 3?","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Core Concepts","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/"},"next":{"title":"Tables and Schemas","permalink":"/suggested-site/docs/ignite3/3.1.0/understand/core-concepts/tables-and-schemas"}}');var s=t(74848),a=t(28453);const r={id:"what-is-ignite",title:"What is Apache Ignite 3?",sidebar_position:1},o=void 0,c={},d=[{value:"When to Use Ignite",id:"when-to-use-ignite",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Component Layers",id:"component-layers",level:3},{value:"Core Features",id:"core-features",level:2},{value:"Unified Data Model",id:"unified-data-model",level:3},{value:"ACID Transactions",id:"acid-transactions",level:3},{value:"Distribution Zones",id:"distribution-zones",level:3},{value:"Distributed Compute",id:"distributed-compute",level:3},{value:"Distributed SQL",id:"distributed-sql",level:3},{value:"Storage Options",id:"storage-options",level:3},{value:"Clients and Connectivity",id:"clients-and-connectivity",level:2},{value:"Management",id:"management",level:2},{value:"Changes from Ignite 2",id:"changes-from-ignite-2",level:2},{value:"Data Model",id:"data-model",level:3},{value:"Transactions",id:"transactions",level:3},{value:"Distribution Configuration",id:"distribution-configuration",level:3},{value:"Client Model",id:"client-model",level:3},{value:"Compute API",id:"compute-api",level:3},{value:"Management Tools",id:"management-tools",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Apache Ignite is a distributed database designed for high-performance transactional and analytical workloads. It combines in-memory speed with disk persistence, providing both SQL and key-value access to the same data with full ACID transaction support."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-ignite",children:"When to Use Ignite"}),"\n",(0,s.jsx)(n.p,{children:"Ignite fits workloads that require low-latency data access at scale:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Workload"}),(0,s.jsx)(n.th,{children:"How Ignite Helps"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"High-throughput OLTP"})}),(0,s.jsx)(n.td,{children:"In-memory processing with persistent storage handles millions of transactions per second"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Real-time analytics"})}),(0,s.jsx)(n.td,{children:"Distributed SQL queries execute across partitioned data without ETL"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Caching layer"})}),(0,s.jsx)(n.td,{children:"Replace external caches with a transactional, SQL-queryable data layer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Microservices data"})}),(0,s.jsx)(n.td,{children:"Shared distributed state with strong consistency guarantees"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Event processing"})}),(0,s.jsx)(n.td,{children:"Colocated compute executes business logic where data resides"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Ignite clusters consist of server nodes that store partitioned data and execute distributed queries and compute jobs. Clients connect through a lightweight protocol without joining the cluster topology."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Applications"\n        App1[Java App]\n        App2[.NET App]\n        App3[C++ App]\n        SQL[SQL Tools]\n    end\n\n    subgraph "Apache Ignite Cluster"\n        subgraph "Node 1"\n            P1[Partitions]\n            C1[Compute]\n        end\n        subgraph "Node 2"\n            P2[Partitions]\n            C2[Compute]\n        end\n        subgraph "Node 3"\n            P3[Partitions]\n            C3[Compute]\n        end\n    end\n\n    App1 & App2 & App3 --\x3e|"Thin Client"| P1 & P2 & P3\n    SQL --\x3e|"JDBC/ODBC"| P1 & P2 & P3'}),"\n",(0,s.jsx)(n.h3,{id:"component-layers",children:"Component Layers"}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Client Layer"\n        Clients[Thin Clients]\n        JDBC[JDBC/ODBC]\n    end\n\n    subgraph "API Layer"\n        SQLEngine[SQL Engine]\n        TableAPI[Table API]\n        ComputeAPI[Compute API]\n    end\n\n    subgraph "Transaction Layer"\n        TX[Transaction Manager]\n        MVCCStore[MVCC Storage]\n        Locks[Lock Manager]\n    end\n\n    subgraph "Distribution Layer"\n        Zones[Distribution Zones]\n        Placement[Placement Driver]\n        Raft[Raft Consensus]\n    end\n\n    subgraph "Storage Layer"\n        Memory[In-Memory]\n        Disk[Persistent]\n    end\n\n    Clients --\x3e SQLEngine & TableAPI & ComputeAPI\n    JDBC --\x3e SQLEngine\n    SQLEngine & TableAPI --\x3e TX\n    TX --\x3e MVCCStore & Locks\n    MVCCStore --\x3e Zones\n    Zones --\x3e Placement\n    Placement --\x3e Raft\n    Raft --\x3e Memory & Disk'}),"\n",(0,s.jsx)(n.h2,{id:"core-features",children:"Core Features"}),"\n",(0,s.jsx)(n.h3,{id:"unified-data-model",children:"Unified Data Model"}),"\n",(0,s.jsx)(n.p,{children:"Tables provide a single data structure for both SQL and key-value operations. The same schema serves distributed queries and low-latency key lookups."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Table"\n        Schema[Schema Definition]\n    end\n\n    subgraph "Access Patterns"\n        SQL[SQL Queries]\n        KV[Key-Value API]\n        Compute[Colocated Compute]\n    end\n\n    Schema --\x3e SQL & KV & Compute'}),"\n",(0,s.jsx)(n.p,{children:"Create tables with SQL, then access them through any API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE accounts (\n    id INT PRIMARY KEY,\n    name VARCHAR(100),\n    balance DECIMAL(10,2)\n) WITH PRIMARY_ZONE = 'default';\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Key-value access to the same table\nKeyValueView<Long, Account> kv = table.keyValueView(\n    Mapper.of(Long.class), Mapper.of(Account.class));\nAccount account = kv.get(null, 42L);\n\n// SQL access\nResultSet rs = client.sql().execute(null,\n    "SELECT * FROM accounts WHERE balance > ?", 1000);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"acid-transactions",children:"ACID Transactions"}),"\n",(0,s.jsx)(n.p,{children:"All tables support transactions by default using Multi-Version Concurrency Control (MVCC). Read-write transactions execute with serializable isolation. Read-only transactions provide snapshot isolation without acquiring locks."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Transaction Model"\n        MVCC["MVCC Engine"]\n\n        subgraph "Read-Write"\n            Serial["Serializable Isolation"]\n            Locks2["Lock-based"]\n            TwoPC["2PC Commit"]\n        end\n\n        subgraph "Read-Only"\n            Snapshot["Snapshot Isolation"]\n            LockFree["Lock-free"]\n            AnyReplica["Any Replica"]\n        end\n    end\n\n    MVCC --\x3e Serial & Snapshot\n    Serial --\x3e Locks2 --\x3e TwoPC\n    Snapshot --\x3e LockFree --\x3e AnyReplica'}),"\n",(0,s.jsx)(n.p,{children:"Transactions work across SQL and key-value operations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'var tx = client.transactions().begin();\ntry {\n    // Mix SQL and key-value in same transaction\n    client.sql().execute(tx, "UPDATE accounts SET balance = balance - 100 WHERE id = ?", 1);\n    kv.put(tx, 2L, new Account("Jane", 100.00));\n    tx.commit();\n} catch (Exception e) {\n    tx.rollback();\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"distribution-zones",children:"Distribution Zones"}),"\n",(0,s.jsx)(n.p,{children:"Distribution zones control how data is partitioned and replicated across the cluster. Each zone defines partition count, replication factor, and node placement rules."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Distribution Zone"\n        Config["Zone: transactions_zone"]\n\n        subgraph "Configuration"\n            Part["Partitions: 64"]\n            Repl["Replicas: 3"]\n            Filter["Filter: region=us-east"]\n        end\n\n        subgraph "Assigned Tables"\n            T1[orders]\n            T2[payments]\n            T3[audit_log]\n        end\n    end\n\n    Config --\x3e Part & Repl & Filter\n    Part --\x3e T1 & T2 & T3'}),"\n",(0,s.jsx)(n.p,{children:"Tables in the same zone with matching colocation keys store related data on the same partitions, enabling efficient joins without network transfers."}),"\n",(0,s.jsx)(n.h3,{id:"distributed-compute",children:"Distributed Compute"}),"\n",(0,s.jsx)(n.p,{children:"Execute code where data resides to minimize network overhead. Jobs can target specific nodes, colocate with data partitions, or broadcast across the cluster."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Job Placement"\n        Any["Any Node"]\n        Coloc["Colocated"]\n        Bcast["Broadcast"]\n    end\n\n    subgraph "Execution"\n        N1[Node 1]\n        N2[Node 2]\n        N3[Node 3]\n    end\n\n    Any --\x3e N1\n    Coloc --\x3e|"Data-local"| N2\n    Bcast --\x3e N1 & N2 & N3'}),"\n",(0,s.jsx)(n.p,{children:"Colocated execution processes data without network transfer:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Execute on node holding account 42\'s partition\nJobExecution<Double> execution = client.compute().submit(\n    JobTarget.colocated("accounts", Tuple.create().set("id", 42L)),\n    JobDescriptor.builder(CalculateInterestJob.class).build(),\n    42L\n);\nDouble interest = execution.resultAsync().join();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"distributed-sql",children:"Distributed SQL"}),"\n",(0,s.jsx)(n.p,{children:"The SQL engine executes ANSI SQL queries across partitioned data. Query plans push predicates to partitions, aggregate results, and handle distributed joins."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    subgraph "Query Execution"\n        Query["SELECT * FROM orders o<br/>JOIN customers c ON o.cust_id = c.id<br/>WHERE c.region = \'US\'"]\n    end\n\n    subgraph "Distributed Plan"\n        Parse[Parse & Optimize]\n        Frag1[Fragment: customers scan]\n        Frag2[Fragment: orders scan]\n        Join[Colocated Join]\n        Agg[Aggregate Results]\n    end\n\n    Query --\x3e Parse\n    Parse --\x3e Frag1 & Frag2\n    Frag1 & Frag2 --\x3e Join\n    Join --\x3e Agg'}),"\n",(0,s.jsx)(n.p,{children:"Standard JDBC connectivity works with existing SQL tools:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'try (Connection conn = DriverManager.getConnection("jdbc:ignite:thin://localhost:10800")) {\n    PreparedStatement stmt = conn.prepareStatement(\n        "SELECT region, SUM(amount) FROM orders GROUP BY region");\n    ResultSet rs = stmt.executeQuery();\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"storage-options",children:"Storage Options"}),"\n",(0,s.jsx)(n.p,{children:"Ignite supports multiple storage engines optimized for different workloads:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Engine"}),(0,s.jsx)(n.th,{children:"Characteristics"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"aimem"})}),(0,s.jsx)(n.td,{children:"In-memory only, volatile"}),(0,s.jsx)(n.td,{children:"Caching, session data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"aipersist"})}),(0,s.jsx)(n.td,{children:"In-memory with disk persistence"}),(0,s.jsx)(n.td,{children:"Primary data storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"rocksdb"})}),(0,s.jsx)(n.td,{children:"Disk-based with memory cache"}),(0,s.jsx)(n.td,{children:"Large datasets exceeding RAM"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Storage profiles assign engines to distribution zones:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE ZONE large_data WITH\n    STORAGE_PROFILES = 'rocksdb_profile',\n    PARTITIONS = 128,\n    REPLICAS = 3;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"clients-and-connectivity",children:"Clients and Connectivity"}),"\n",(0,s.jsx)(n.p,{children:"Ignite provides native thin clients and standard database connectivity:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Client"}),(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Protocol"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java Client"}),(0,s.jsx)(n.td,{children:"Java 11+"}),(0,s.jsx)(n.td,{children:"Binary"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:".NET Client"}),(0,s.jsx)(n.td,{children:".NET 6+"}),(0,s.jsx)(n.td,{children:"Binary"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C++ Client"}),(0,s.jsx)(n.td,{children:"C++17"}),(0,s.jsx)(n.td,{children:"Binary"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JDBC Driver"}),(0,s.jsx)(n.td,{children:"Any JVM"}),(0,s.jsx)(n.td,{children:"JDBC"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ODBC Driver"}),(0,s.jsx)(n.td,{children:"Any"}),(0,s.jsx)(n.td,{children:"ODBC"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Thin clients connect directly to cluster nodes without joining the topology:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'IgniteClient client = IgniteClient.builder()\n    .addresses("node1:10800", "node2:10800", "node3:10800")\n    .build();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"management",children:"Management"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ignite3"})," CLI provides cluster administration, configuration, and disaster recovery operations. Configuration uses HOCON format split between cluster-wide and node-specific settings."]}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "CLI"\n        Tool[ignite3]\n    end\n\n    subgraph "Operations"\n        Init[Cluster Init]\n        Config[Configuration]\n        Status[Health/Status]\n        Recovery[Disaster Recovery]\n    end\n\n    Tool --\x3e Init & Config & Status & Recovery'}),"\n",(0,s.jsx)(n.h2,{id:"changes-from-ignite-2",children:"Changes from Ignite 2"}),"\n",(0,s.jsx)(n.p,{children:"For teams migrating from Ignite 2, the following section summarizes architectural changes."}),"\n",(0,s.jsx)(n.h3,{id:"data-model",children:"Data Model"}),"\n",(0,s.jsx)(n.p,{children:"Ignite 2 stored data in caches using Binary Object format. SQL and key-value APIs operated on different representations. Ignite 3 replaces caches with tables that provide a unified schema for all access patterns."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph "Ignite 2"\n        direction TB\n        C[Cache]\n        BO[Binary Objects]\n        SQL2[SQL Schema]\n        KV2[Key-Value API]\n        C --\x3e BO\n        BO --\x3e SQL2\n        BO --\x3e KV2\n    end\n\n    subgraph "Ignite 3"\n        direction TB\n        T[Table]\n        Schema2[Single Schema]\n        SQL3[SQL API]\n        KV3[Key-Value API]\n        T --\x3e Schema2\n        Schema2 --\x3e SQL3\n        Schema2 --\x3e KV3\n    end'}),"\n",(0,s.jsx)(n.h3,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Ignite 2 transactions required cache atomicity configuration and had performance implications. Ignite 3 makes all tables transactional by default with MVCC-based concurrency control. The WAIT_DIE algorithm prevents deadlocks without detection overhead."}),"\n",(0,s.jsx)(n.h3,{id:"distribution-configuration",children:"Distribution Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Ignite 2 spread distribution settings across affinity functions, backup configuration, and baseline topology. Ignite 3 consolidates these into distribution zones with explicit partition counts, replica factors, and node filters. Custom affinity functions are replaced by deterministic rendezvous hashing."}),"\n",(0,s.jsx)(n.h3,{id:"client-model",children:"Client Model"}),"\n",(0,s.jsx)(n.p,{children:"Ignite 2 thick clients joined the cluster as nodes, requiring full protocol participation. Ignite 3 uses thin clients exclusively for standard operations. Embedded mode remains available for specialized use cases."}),"\n",(0,s.jsx)(n.h3,{id:"compute-api",children:"Compute API"}),"\n",(0,s.jsxs)(n.p,{children:["Ignite 3 extends Ignite 2's compute capabilities with job state tracking, priority-based queuing, and automatic failover on node departure. All compute operations return ",(0,s.jsx)(n.code,{children:"CompletableFuture"})," for non-blocking execution."]}),"\n",(0,s.jsx)(n.h3,{id:"management-tools",children:"Management Tools"}),"\n",(0,s.jsxs)(n.p,{children:["Ignite 2 used multiple CLI scripts with overlapping functionality. Ignite 3 provides a single ",(0,s.jsx)(n.code,{children:"ignite3"})," CLI with interactive mode and command autocomplete. Configuration moved from XML to HOCON format."]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./tables-and-schemas",children:"Tables and Schemas"})," for data modeling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./distribution-and-colocation",children:"Distribution and Colocation"})," for partitioning"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./transactions-and-mvcc",children:"Transactions and MVCC"})," for concurrency control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./compute-and-events",children:"Compute and Events"})," for distributed processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/3.1.0/getting-started/",children:"Getting Started"})," to deploy your first cluster"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);