"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[6815],{40830:(e,s,t)=>{t.d(s,{lZ:()=>n});var a=t(56347),i=t(44586);function n(){const e=(0,a.zy)(),{siteConfig:s}=(0,i.A)();let t=e.pathname;return"/"!==t&&t.endsWith("/")&&(t=t.slice(0,-1)),`${s.url}${t}`}},95160:(e,s,t)=>{t.r(s),t.d(s,{default:()=>c});t(96540);var a=t(19766),i=t(28774),n=t(5260),o=t(40830),r=t(74848);function c(){const e=(0,o.lZ)();return(0,r.jsxs)(a.A,{children:[(0,r.jsxs)(n.A,{children:[(0,r.jsx)("title",{children:"High-Performance Computing - Apache Ignite"}),(0,r.jsx)("meta",{name:"description",content:"Apache Ignite supports compute-to-data patterns through schema-driven colocation. Local joins and recommendation engines benefit from significant latency reduction through colocation."}),(0,r.jsx)("link",{rel:"canonical",href:e}),(0,r.jsx)("meta",{property:"og:title",content:"High-Performance Computing - Apache Ignite"}),(0,r.jsx)("meta",{property:"og:type",content:"article"}),(0,r.jsx)("meta",{property:"og:url",content:e}),(0,r.jsx)("meta",{property:"og:image",content:"/suggested-site/img/og-pic.png"}),(0,r.jsx)("meta",{property:"og:description",content:"Apache Ignite supports compute-to-data patterns through schema-driven colocation."})]}),(0,r.jsx)("section",{className:"innerhero",children:(0,r.jsx)("div",{className:"container innerhero__cont",children:(0,r.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,r.jsxs)("h1",{className:"h1 innerhero__h1",children:["High-Performance Computing",(0,r.jsx)("br",{}),(0,r.jsx)("span",{className:"with-apache",children:"With Apache Ignite"})]}),(0,r.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Schema-driven colocation and compute-to-data patterns"}),(0,r.jsx)("div",{className:"innerhero__action",children:(0,r.jsx)("a",{className:"button innerhero__button",href:"/suggested-site/docs/",target:"_blank",rel:"noreferrer",style:{background:"#fff",color:"var(--ai-blue)"},children:"Start Coding"})})]})})}),(0,r.jsx)("section",{className:"inmememor1 container",children:(0,r.jsxs)("header",{className:"blockheader blockheader--spl flexi",children:[(0,r.jsx)("h2",{className:"capstext pb-3",children:"Compute-To-Data Pattern"}),(0,r.jsxs)("div",{className:"inmememor1__text",children:[(0,r.jsx)("p",{children:"Ignite supports compute-to-data patterns by executing calculations on nodes where data resides. Schema-driven colocation through table design enables local joins without network transfers. Recommendation engines and analytics benefit from significant latency reduction through colocation."}),(0,r.jsx)("p",{className:"pt-3",children:"Both Ignite 2 and Ignite 3 support compute-to-data patterns. Ignite 2 uses Affinity Key annotation for colocation. Ignite 3 uses colocation keys defined in table schema. Both versions provide Compute APIs for executing code across cluster nodes."})]})]})}),(0,r.jsx)("section",{className:"inmememor-adv",children:(0,r.jsxs)("div",{className:"container",children:[(0,r.jsxs)("header",{className:"blockheader blockheader--spl flexi",children:[(0,r.jsx)("h2",{className:"h4",children:"How Colocation Works"}),(0,r.jsx)("div",{className:"blockheader__right fz20",children:"Schema-driven colocation keeps related data on the same nodes for local processing"})]}),(0,r.jsxs)("div",{className:"inmememor-adv__wrap",children:[(0,r.jsxs)("div",{className:"inmememor-adv__item",children:[(0,r.jsx)("h3",{className:"h4",children:"Schema-Driven Colocation"}),(0,r.jsx)("div",{className:"inmememor-adv__text",children:"Define colocation keys in table schema to control data placement. Related records (orders with order items, users with transactions) stored on same partition. Local joins execute without network transfers. Significant latency reduction compared to distributed joins."})]}),(0,r.jsxs)("div",{className:"inmememor-adv__item",children:[(0,r.jsx)("h3",{className:"h4",children:"Compute-To-Data Execution"}),(0,r.jsx)("div",{className:"inmememor-adv__text",children:"Execute calculations on nodes where data resides. Compute APIs broadcast tasks to cluster nodes. Custom code executes locally on colocated data sets. Eliminates network transfers for data-intensive calculations."})]})]})]})}),(0,r.jsxs)("section",{className:"inmememor2 container",children:[(0,r.jsx)("h2",{className:"h4",children:"Architecture Pattern"}),(0,r.jsx)("p",{className:"fz20 pt-5",children:(0,r.jsx)("strong",{children:"Local Joins With Colocated Data"})}),(0,r.jsxs)("div",{className:"inmememor2__work flexi pt-2",children:[(0,r.jsx)("div",{className:"inmememor2__left",children:(0,r.jsx)("p",{children:(0,r.jsx)("em",{children:"Define colocation keys in table schema to ensure related records reside on same partitions, enabling local joins without network overhead."})})}),(0,r.jsxs)("div",{className:"inmememor2__right",children:[(0,r.jsxs)("p",{className:"pb-2",children:[(0,r.jsx)("strong",{children:"Integration Pattern:"})," Design table schemas with colocation keys that match join patterns. Orders table colocated with order items using orderId. Users table colocated with transactions using userId. Local joins execute on single node without network transfers."]}),(0,r.jsxs)("p",{children:[(0,r.jsx)("strong",{children:"Performance Characteristics:"})," Local joins deliver significant latency reduction compared to distributed joins. Network transfers eliminated for colocated data. Memory-first storage enables low-latency join execution. Horizontal scalability maintained through proper partitioning strategy."]}),(0,r.jsxs)("p",{children:[(0,r.jsx)("strong",{children:"Version Support:"})," Ignite 2 uses Affinity Key annotation for colocation. Ignite 3 uses colocation keys defined in CREATE TABLE statements. Both versions support same performance benefits."]})]})]}),(0,r.jsx)("p",{className:"fz20 pt-5",children:(0,r.jsx)("strong",{children:"Recommendation Engines"})}),(0,r.jsxs)("div",{className:"inmememor2__work flexi pt-3",children:[(0,r.jsx)("div",{className:"inmememor2__left",children:(0,r.jsx)("p",{children:(0,r.jsx)("em",{children:"Execute recommendation algorithms on nodes where user and product data resides, avoiding network transfers for large feature sets."})})}),(0,r.jsxs)("div",{className:"inmememor2__right",children:[(0,r.jsxs)("p",{className:"pb-2",children:[(0,r.jsx)("strong",{children:"Integration Pattern:"})," Colocate user profiles, purchase history, and product catalogs using userId as colocation key. Execute recommendation algorithms using Compute APIs on colocated data sets. Results calculated locally without network transfers."]}),(0,r.jsxs)("p",{children:[(0,r.jsx)("strong",{children:"Performance Characteristics:"})," Compute-to-data pattern delivers significant latency reduction for recommendation calculations. Feature extraction from colocated data avoids network overhead. Parallel execution across cluster nodes for multiple user recommendations."]}),(0,r.jsxs)("p",{children:[(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Example Use Cases:"})})," E-commerce product recommendations based on purchase history and browsing patterns. Content recommendations for streaming platforms. Personalized search results."]})]})]})]}),(0,r.jsxs)("section",{className:"inmememor3 container pt-5",children:[(0,r.jsx)("h2",{className:"h4",children:"Key Benefits"}),(0,r.jsxs)("div",{className:"inmememor3__botwrap flexi pt-3",children:[(0,r.jsxs)("div",{className:"inmememor2__left",children:[(0,r.jsx)("h3",{className:"fz20",children:"Significant Latency Reduction"}),(0,r.jsx)("p",{children:"Local joins and calculations on colocated data eliminate network transfers. Significant latency reduction compared to distributed joins across nodes. Memory-first storage delivers low-latency data access for local operations. Particularly effective for join-heavy queries and recommendation algorithms."}),(0,r.jsx)("h3",{className:"fz20 pt-4",children:"Schema-Driven Design"}),(0,r.jsx)("p",{children:"Define colocation keys in table schema to control data placement. Compile-time awareness of colocation patterns. Query optimizer leverages colocation for local execution. Explicit schema design makes colocation patterns visible in DDL."})]}),(0,r.jsxs)("div",{className:"inmememor2__right",children:[(0,r.jsx)("h3",{className:"fz20",children:"Horizontal Scalability"}),(0,r.jsx)("p",{children:"Add nodes to increase compute capacity while maintaining colocation benefits. Each partition processed independently in parallel. Scales to large data sets through proper partitioning strategy. Compute-to-data pattern scales linearly with cluster size."}),(0,r.jsx)("h3",{className:"fz20 pt-4",children:"Familiar SQL Patterns"}),(0,r.jsx)("p",{children:"Standard SQL joins work automatically with colocated data. No specialized APIs required for local joins. Query optimizer detects colocation and executes locally. Compute APIs available for custom algorithms on colocated data."})]})]})]}),(0,r.jsxs)("section",{className:"inmememor2 container pt-5",children:[(0,r.jsx)("h2",{className:"h4",children:"When This Pattern Works"}),(0,r.jsxs)("div",{className:"inmememor2__work flexi pt-3",children:[(0,r.jsxs)("div",{className:"inmememor2__left",children:[(0,r.jsx)("h3",{className:"fz20",children:"Best For Join-Heavy Workloads"}),(0,r.jsx)("p",{children:"This pattern works well when workloads have predictable join patterns (orders with order items, users with transactions). Schema-driven colocation enables local joins for related records. Significant latency reduction for join-heavy queries. Best when colocation key matches most frequent join patterns."})]}),(0,r.jsxs)("div",{className:"inmememor2__right",children:[(0,r.jsx)("h3",{className:"fz20",children:"Requires Careful Schema Design"}),(0,r.jsx)("p",{children:"Effective colocation requires upfront schema design with appropriate colocation keys. Poor colocation key choice results in distributed joins. Single colocation key per table limits flexibility for multiple join patterns. Query patterns should be analyzed before defining colocation strategy."})]})]})]}),(0,r.jsxs)("section",{className:"inmememor2 container pt-5",children:[(0,r.jsx)("h2",{className:"h4",children:"Example Applications"}),(0,r.jsxs)("div",{className:"inmememor2__work flexi pt-3",children:[(0,r.jsxs)("div",{className:"inmememor2__left",children:[(0,r.jsx)("p",{children:"This pattern applies to:"}),(0,r.jsxs)("ul",{className:"dashlist pt-1",children:[(0,r.jsx)("li",{children:"E-commerce platforms with product recommendations based on purchase history"}),(0,r.jsx)("li",{children:"Financial applications with account-based analytics requiring local joins"}),(0,r.jsx)("li",{children:"Content platforms with personalized recommendations based on user behavior"}),(0,r.jsx)("li",{children:"IoT analytics with device-based aggregations on colocated sensor data"})]})]}),(0,r.jsxs)("div",{className:"inmememor2__right",children:[(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Concrete Example:"})}),(0,r.jsxs)("ul",{className:"pt-1",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("strong",{children:"Order Processing:"})," Orders table colocated with order_items using orderId. Local joins for order totals without network transfers. Significant latency reduction for checkout processing."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("strong",{children:"Recommendation Engine:"})," User profiles colocated with purchase history using userId. Execute recommendation algorithms locally on colocated data. Parallel execution across cluster for multiple users."]})]})]})]})]}),(0,r.jsx)("section",{className:"native-bottom container",children:(0,r.jsxs)("div",{className:"native-bottom__grid",children:[(0,r.jsxs)("article",{className:"nativebotblock",children:[(0,r.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,r.jsx)("img",{src:"/suggested-site/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,r.jsx)("span",{children:"Ready to Start?"})]}),(0,r.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,r.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,r.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,r.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,r.jsx)("img",{src:"/suggested-site/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,r.jsx)("span",{children:"Explore More Use Cases"})]}),(0,r.jsx)("p",{className:"nativebotblock__text",children:"Learn about other Ignite use cases"}),(0,r.jsx)(i.A,{className:"nativebotblock__link arrowlink",to:"/suggested-site/use-cases/",children:"Use Cases Overview"})]})]})})]})}}}]);