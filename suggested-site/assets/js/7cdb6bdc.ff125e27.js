<<<<<<< HEAD
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[5624],{33492:(e,s,a)=>{a.r(s),a.d(s,{default:()=>l});a(96540);var i=a(19766),t=a(28774),n=a(5260),r=a(40830),c=a(74848);function l(){const e=(0,r.lZ)();return(0,c.jsxs)(i.A,{children:[(0,c.jsxs)(n.A,{children:[(0,c.jsx)("title",{children:"Access Patterns - Apache Ignite"}),(0,c.jsx)("meta",{name:"description",content:"Apache Ignite offers multiple access patterns for the same data: SQL with JDBC drivers, Table API with RecordView and KeyValueView, or native language APIs. All benefit from memory-first architecture and partition-aware routing."}),(0,c.jsx)("link",{rel:"canonical",href:e}),(0,c.jsx)("meta",{property:"og:title",content:"Access Patterns - Apache Ignite"}),(0,c.jsx)("meta",{property:"og:type",content:"article"}),(0,c.jsx)("meta",{property:"og:url",content:e}),(0,c.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,c.jsx)("meta",{property:"og:description",content:"Apache Ignite offers multiple access patterns for the same data: SQL with JDBC drivers, Table API with RecordView and KeyValueView, or native language APIs. All benefit from memory-first architecture and partition-aware routing."})]}),(0,c.jsx)("section",{className:"innerhero",children:(0,c.jsxs)("div",{className:"container innerhero__cont",children:[(0,c.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,c.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,c.jsx)("h1",{className:"h1 innerhero__h1",children:"Your Choice of Access Pattern"}),(0,c.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"SQL, Table API, or native language APIs. All access the same data."})]}),(0,c.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Access Patterns"})]})}),(0,c.jsx)("section",{className:"container pt-5 pb-5",children:(0,c.jsx)("div",{className:"pt-3 pb-3",children:(0,c.jsx)("p",{className:"fz20",children:"Apache Ignite provides multiple ways to access data. Use SQL with standard JDBC drivers. Use the Table API with typed RecordView or efficient KeyValueView. Use native language-specific APIs. All approaches access the same underlying data and benefit from memory-first architecture with partition-aware routing."})})}),(0,c.jsxs)("section",{className:"nativepersistence3 container",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"SQL with Distributed Execution"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"ANSI SQL Support"}),(0,c.jsx)("p",{children:"Apache Ignite implements ANSI SQL with support for DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE, MERGE), and complex queries with joins, aggregations, and subqueries. The query planner generates distributed execution plans."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Distributed Query Execution"}),(0,c.jsx)("p",{children:"Queries execute across cluster nodes in parallel. The planner routes operations to nodes holding relevant partitions. Results stream back through the coordinator. This enables queries against datasets larger than any single node's memory."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Colocated Joins"}),(0,c.jsx)("p",{children:"When tables share colocation keys, joins execute locally without data movement. The colocateBy annotation in schema definitions enables this optimization. Colocated joins deliver join performance comparable to single-node databases at distributed scale."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"JDBC Access"}),(0,c.jsx)("p",{children:"Apache Ignite provides standard JDBC drivers. Applications connect using familiar JDBC patterns. The driver implements automatic failover and connection pooling. This enables integration with existing tools and frameworks expecting JDBC connectivity."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Table API: Type-Safe Access"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"RecordView"}),(0,c.jsx)("p",{children:"RecordView provides typed access to complete table rows. Methods accept and return objects matching the table schema. The API handles serialization automatically. Use RecordView when working with full records or when type safety matters."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"KeyValueView"}),(0,c.jsx)("p",{children:"KeyValueView separates key and value types for efficient partial updates. Operations specify only the columns involved. This reduces network traffic and serialization overhead. Use KeyValueView for high-throughput scenarios or targeted column updates."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Partition-Aware Routing"}),(0,c.jsx)("p",{children:"The Table API calculates partition ownership from keys. Operations route directly to nodes holding the data. No coordinator overhead. This single-hop access delivers minimal latency for point lookups and targeted updates."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Bulk Operations"}),(0,c.jsx)("p",{children:"Both RecordView and KeyValueView support batch operations. Methods like getAll, putAll, and deleteAll process multiple keys efficiently. The API groups operations by partition and executes them in parallel across relevant nodes."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Native Language APIs"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Multi-Language Support"}),(0,c.jsx)("p",{children:"Apache Ignite provides native clients for Java, .NET, C++, Python, and other languages. Each client implements the same core APIs with language-specific patterns. Consistent functionality across languages enables polyglot architectures."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Protocol Efficiency"}),(0,c.jsx)("p",{children:"All clients communicate via an efficient binary protocol. The protocol minimizes serialization overhead and supports request pipelining. Partition awareness works identically across languages. This delivers consistent performance characteristics regardless of client language."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Transaction Support"}),(0,c.jsx)("p",{children:"SQL queries and Table API operations both support transactions. Begin transactions explicitly or use single-statement transactions. Choose isolation levels (REPEATABLE_READ or READ_COMMITTED). All access patterns provide the same transactional guarantees."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Async and Reactive APIs"}),(0,c.jsx)("p",{children:"The Table API offers asynchronous methods returning CompletableFuture. This enables non-blocking operations for high-concurrency scenarios. Reactive streams support backpressure for controlled data ingestion. Choose synchronous or asynchronous based on application requirements."})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Operational Analytics"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Run analytical SQL queries against operational data. Complex aggregations execute in parallel across cluster nodes. MVCC enables analytical queries while transactional updates proceed at full speed. No ETL to separate analytical systems."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/05-key-value-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"High-Throughput Applications"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Use KeyValueView for maximum throughput. Partition-aware routing delivers single-hop access. Batch operations process thousands of keys efficiently. Memory-first architecture provides microsecond-level latency for point operations."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/high-performance-computing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/06-compute-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Polyglot Architectures"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Build systems with multiple languages accessing the same data. Java services use RecordView. Python analytics use SQL. .NET applications use KeyValueView. Consistent APIs and performance across all languages."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"How Access Patterns Connect to the Foundation"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Operations"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"All access patterns execute against in-memory data. SQL queries, Table API operations, and native calls all benefit from memory-resident processing. No cache-miss penalties. No cache-warming strategies needed."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"MVCC Enables Concurrent Access"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC allows SQL analytical queries and Table API updates to run simultaneously. Long-running aggregations work on stable snapshots. Transactional updates proceed at full throughput. Readers never block writers."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About MVCC"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/05-key-value-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Partition-Aware Routing"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Table API and SQL both leverage partition awareness. Operations route directly to data owners. Colocated joins execute locally. This delivers minimal latency through single-hop access patterns."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)("a",{href:"/docs/ignite3/3.1.0/configure-and-operate/operations/colocation",className:"cardsimple__button button button--shadow",target:"_blank",rel:"noreferrer",children:"Learn About Colocation"})})]})]})]}),(0,c.jsx)("section",{className:"native-bottom container",children:(0,c.jsxs)("div",{className:"native-bottom__grid",children:[(0,c.jsxs)("article",{className:"nativebotblock",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Ready to Start?"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,c.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Read Documentation"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Learn about SQL syntax, Table API methods, and client configuration"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/api-reference/sql-only-apis/jdbc",target:"_blank",rel:"noreferrer",children:"SQL and JDBC Documentation"})]})]})})]})}},40830:(e,s,a)=>{a.d(s,{lZ:()=>n});var i=a(56347),t=a(44586);function n(){const e=(0,i.zy)(),{siteConfig:s}=(0,t.A)();let a=e.pathname;return"/"!==a&&a.endsWith("/")&&(a=a.slice(0,-1)),`${s.url}${a}`}}}]);
=======
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[5624],{33492:(e,s,a)=>{a.r(s),a.d(s,{default:()=>l});a(96540);var i=a(19766),t=a(28774),n=a(5260),r=a(40830),c=a(74848);function l(){const e=(0,r.lZ)();return(0,c.jsxs)(i.A,{children:[(0,c.jsxs)(n.A,{children:[(0,c.jsx)("title",{children:"Access Patterns - Apache Ignite"}),(0,c.jsx)("meta",{name:"description",content:"Apache Ignite offers multiple access patterns for the same data: SQL with JDBC drivers, Table API with RecordView and KeyValueView, or native language APIs. All benefit from memory-first architecture and partition-aware routing."}),(0,c.jsx)("link",{rel:"canonical",href:e}),(0,c.jsx)("meta",{property:"og:title",content:"Access Patterns - Apache Ignite"}),(0,c.jsx)("meta",{property:"og:type",content:"article"}),(0,c.jsx)("meta",{property:"og:url",content:e}),(0,c.jsx)("meta",{property:"og:image",content:"/suggested-site/img/og-pic.png"}),(0,c.jsx)("meta",{property:"og:description",content:"Apache Ignite offers multiple access patterns for the same data: SQL with JDBC drivers, Table API with RecordView and KeyValueView, or native language APIs. All benefit from memory-first architecture and partition-aware routing."})]}),(0,c.jsx)("section",{className:"innerhero",children:(0,c.jsxs)("div",{className:"container innerhero__cont",children:[(0,c.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,c.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,c.jsx)("h1",{className:"h1 innerhero__h1",children:"Your Choice of Access Pattern"}),(0,c.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"SQL, Table API, or native language APIs. All access the same data."})]}),(0,c.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/suggested-site/img/features/hero-bg.svg",alt:"Access Patterns"})]})}),(0,c.jsx)("section",{className:"container pt-5 pb-5",children:(0,c.jsx)("div",{className:"pt-3 pb-3",children:(0,c.jsx)("p",{className:"fz20",children:"Apache Ignite provides multiple ways to access data. Use SQL with standard JDBC drivers. Use the Table API with typed RecordView or efficient KeyValueView. Use native language-specific APIs. All approaches access the same underlying data and benefit from memory-first architecture with partition-aware routing."})})}),(0,c.jsxs)("section",{className:"nativepersistence3 container",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"SQL with Distributed Execution"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"ANSI SQL Support"}),(0,c.jsx)("p",{children:"Apache Ignite implements ANSI SQL with support for DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE, MERGE), and complex queries with joins, aggregations, and subqueries. The query planner generates distributed execution plans."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Distributed Query Execution"}),(0,c.jsx)("p",{children:"Queries execute across cluster nodes in parallel. The planner routes operations to nodes holding relevant partitions. Results stream back through the coordinator. This enables queries against datasets larger than any single node's memory."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Colocated Joins"}),(0,c.jsx)("p",{children:"When tables share colocation keys, joins execute locally without data movement. The colocateBy annotation in schema definitions enables this optimization. Colocated joins deliver join performance comparable to single-node databases at distributed scale."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"JDBC Access"}),(0,c.jsx)("p",{children:"Apache Ignite provides standard JDBC drivers. Applications connect using familiar JDBC patterns. The driver implements automatic failover and connection pooling. This enables integration with existing tools and frameworks expecting JDBC connectivity."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Table API: Type-Safe Access"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"RecordView"}),(0,c.jsx)("p",{children:"RecordView provides typed access to complete table rows. Methods accept and return objects matching the table schema. The API handles serialization automatically. Use RecordView when working with full records or when type safety matters."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"KeyValueView"}),(0,c.jsx)("p",{children:"KeyValueView separates key and value types for efficient partial updates. Operations specify only the columns involved. This reduces network traffic and serialization overhead. Use KeyValueView for high-throughput scenarios or targeted column updates."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Partition-Aware Routing"}),(0,c.jsx)("p",{children:"The Table API calculates partition ownership from keys. Operations route directly to nodes holding the data. No coordinator overhead. This single-hop access delivers minimal latency for point lookups and targeted updates."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Bulk Operations"}),(0,c.jsx)("p",{children:"Both RecordView and KeyValueView support batch operations. Methods like getAll, putAll, and deleteAll process multiple keys efficiently. The API groups operations by partition and executes them in parallel across relevant nodes."})]})]})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Native Language APIs"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Multi-Language Support"}),(0,c.jsx)("p",{children:"Apache Ignite provides native clients for Java, .NET, C++, Python, and other languages. Each client implements the same core APIs with language-specific patterns. Consistent functionality across languages enables polyglot architectures."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Protocol Efficiency"}),(0,c.jsx)("p",{children:"All clients communicate via an efficient binary protocol. The protocol minimizes serialization overhead and supports request pipelining. Partition awareness works identically across languages. This delivers consistent performance characteristics regardless of client language."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Transaction Support"}),(0,c.jsx)("p",{children:"SQL queries and Table API operations both support transactions. Begin transactions explicitly or use single-statement transactions. Choose isolation levels (REPEATABLE_READ or READ_COMMITTED). All access patterns provide the same transactional guarantees."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Async and Reactive APIs"}),(0,c.jsx)("p",{children:"The Table API offers asynchronous methods returning CompletableFuture. This enables non-blocking operations for high-concurrency scenarios. Reactive streams support backpressure for controlled data ingestion. Choose synchronous or asynchronous based on application requirements."})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/03-distributed-SQL.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Operational Analytics"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Run analytical SQL queries against operational data. Complex aggregations execute in parallel across cluster nodes. MVCC enables analytical queries while transactional updates proceed at full speed. No ETL to separate analytical systems."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/05-key-value-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"High-Throughput Applications"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Use KeyValueView for maximum throughput. Partition-aware routing delivers single-hop access. Batch operations process thousands of keys efficiently. Memory-first architecture provides microsecond-level latency for point operations."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/use-cases/high-performance-computing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/06-compute-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Polyglot Architectures"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Build systems with multiple languages accessing the same data. Java services use RecordView. Python analytics use SQL. .NET applications use KeyValueView. Consistent APIs and performance across all languages."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"How Access Patterns Connect to the Foundation"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Operations"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"All access patterns execute against in-memory data. SQL queries, Table API operations, and native calls all benefit from memory-resident processing. No cache-miss penalties. No cache-warming strategies needed."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/04-ACID-transactions.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"MVCC Enables Concurrent Access"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC allows SQL analytical queries and Table API updates to run simultaneously. Long-running aggregations work on stable snapshots. Transactional updates proceed at full throughput. Readers never block writers."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About MVCC"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/05-key-value-APIs.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Partition-Aware Routing"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Table API and SQL both leverage partition awareness. Operations route directly to data owners. Colocated joins execute locally. This delivers minimal latency through single-hop access patterns."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)("a",{href:"/suggested-site/docs/ignite3/3.1.0/configure-and-operate/operations/colocation",className:"cardsimple__button button button--shadow",target:"_blank",rel:"noreferrer",children:"Learn About Colocation"})})]})]})]}),(0,c.jsx)("section",{className:"native-bottom container",children:(0,c.jsxs)("div",{className:"native-bottom__grid",children:[(0,c.jsxs)("article",{className:"nativebotblock",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/suggested-site/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Ready to Start?"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,c.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/suggested-site/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Read Documentation"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Learn about SQL syntax, Table API methods, and client configuration"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/api-reference/sql-only-apis/jdbc",target:"_blank",rel:"noreferrer",children:"SQL and JDBC Documentation"})]})]})})]})}},40830:(e,s,a)=>{a.d(s,{lZ:()=>n});var i=a(56347),t=a(44586);function n(){const e=(0,i.zy)(),{siteConfig:s}=(0,t.A)();let a=e.pathname;return"/"!==a&&a.endsWith("/")&&(a=a.slice(0,-1)),`${s.url}${a}`}}}]);
>>>>>>> origin/master
