<<<<<<< HEAD
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[899],{40830:(e,s,i)=>{i.d(s,{lZ:()=>n});var a=i(56347),t=i(44586);function n(){const e=(0,a.zy)(),{siteConfig:s}=(0,t.A)();let i=e.pathname;return"/"!==i&&i.endsWith("/")&&(i=i.slice(0,-1)),`${s.url}${i}`}},98895:(e,s,i)=>{i.r(s),i.d(s,{default:()=>c});i(96540);var a=i(19766),t=i(28774),n=i(5260),r=i(40830),o=i(74848);function c(){const e=(0,r.lZ)();return(0,o.jsxs)(a.A,{children:[(0,o.jsxs)(n.A,{children:[(0,o.jsx)("title",{children:"Coordination That Scales - Apache Ignite"}),(0,o.jsx)("meta",{name:"description",content:"Apache Ignite provides distributed coordination through Catalog, Meta Storage, and Hybrid Logical Clock. Type-safe configuration with hot reconfiguration. Schema metadata with version tracking enables zero-downtime evolution."}),(0,o.jsx)("link",{rel:"canonical",href:e}),(0,o.jsx)("meta",{property:"og:title",content:"Coordination That Scales - Apache Ignite"}),(0,o.jsx)("meta",{property:"og:type",content:"article"}),(0,o.jsx)("meta",{property:"og:url",content:e}),(0,o.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,o.jsx)("meta",{property:"og:description",content:"Apache Ignite provides distributed coordination through Catalog, Meta Storage, and Hybrid Logical Clock. Type-safe configuration with hot reconfiguration. Schema metadata with version tracking enables zero-downtime evolution."})]}),(0,o.jsx)("section",{className:"innerhero",children:(0,o.jsxs)("div",{className:"container innerhero__cont",children:[(0,o.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,o.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,o.jsx)("h1",{className:"h1 innerhero__h1",children:"Coordination That Scales"}),(0,o.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Distributed metadata, configuration, and event ordering"})]}),(0,o.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Coordination"})]})}),(0,o.jsx)("section",{className:"container pt-5 pb-5",children:(0,o.jsx)("div",{className:"pt-3 pb-3",children:(0,o.jsx)("p",{className:"fz20",children:"Apache Ignite provides distributed coordination primitives that scale with cluster size. The Catalog manages schema metadata with atomic versioning. Meta Storage provides distributed key-value coordination. Hybrid Logical Clock ensures event ordering. Type-safe configuration enables hot reconfiguration without restarts."})})}),(0,o.jsxs)("section",{className:"nativepersistence3 container",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Catalog: Schema Metadata Management"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Versioned Schema Storage"}),(0,o.jsx)("p",{children:"The Catalog stores table definitions, indexes, and distribution zones with version numbers. Schema changes create new versions atomically. All nodes see schema updates simultaneously. This eliminates inconsistent schema states during changes."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Schema Evolution Support"}),(0,o.jsx)("p",{children:"The Catalog enables schema evolution without downtime. Add columns to existing tables. Create indexes on populated tables. Modify distribution zones. Applications continue operating during schema changes with backward compatibility."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Multi-API Consistency"}),(0,o.jsx)("p",{children:"One Catalog schema serves SQL, RecordView, and KeyValueView. Schema changes apply to all access patterns simultaneously. No need to synchronize cache configurations separately. This unified approach prevents API inconsistencies."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Distributed Consensus"}),(0,o.jsx)("p",{children:"The Catalog uses Raft consensus for schema changes. Changes replicate through the consensus log before becoming visible. This ensures all nodes agree on schema state. No split-brain scenarios during network partitions."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Meta Storage: Distributed Key-Value Coordination"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Coordination Primitive"}),(0,o.jsx)("p",{children:"Meta Storage provides a distributed key-value store for coordination. Store cluster metadata, partition assignments, and node attributes. Access through get, put, and compare-and-swap operations. Raft consensus ensures consistency."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Watches and Notifications"}),(0,o.jsx)("p",{children:"Meta Storage supports watches on key prefixes. Applications receive notifications when watched keys change. This enables reactive patterns for topology changes, configuration updates, and partition reassignments."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Topology Management"}),(0,o.jsx)("p",{children:"Meta Storage tracks node membership and attributes. Nodes register on join. Updates propagate through consensus. Node failures detect through timeouts. This provides reliable cluster membership information."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Partition Assignment"}),(0,o.jsx)("p",{children:"Meta Storage stores partition-to-node assignments. Distribution zones query these assignments for data placement. Rebalancing updates assignments atomically. This coordination enables dynamic partition distribution."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Configuration Management"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Type-Safe Configuration"}),(0,o.jsx)("p",{children:"Apache Ignite uses typed configuration objects. Compile-time validation prevents configuration errors. IDE auto-completion helps discoverability. Generated documentation keeps configuration references current."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Hot Reconfiguration"}),(0,o.jsx)("p",{children:"Many configuration parameters support runtime updates. Change without cluster restarts. Updates propagate through Meta Storage. Nodes apply changes atomically. This enables operational adjustments without downtime."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Configuration Validation"}),(0,o.jsx)("p",{children:"The system validates configuration changes before applying them. Reject invalid values at submission time. Validate cross-parameter constraints. This prevents runtime failures from configuration errors."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Configuration History"}),(0,o.jsx)("p",{children:"Meta Storage maintains configuration history. Query previous configurations. Understand when changes occurred. This supports troubleshooting and compliance requirements."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Hybrid Logical Clock"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Event Ordering"}),(0,o.jsx)("p",{children:"Hybrid Logical Clock (HLC) provides total ordering of events across nodes. Combines physical time with logical counters. Events order deterministically even when physical clocks skew. This enables causality tracking in distributed operations."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Clock Synchronization"}),(0,o.jsx)("p",{children:"HLC synchronizes through message passing. No external clock synchronization service required. Clock skew remains bounded within configured limits. This simplifies deployment compared to systems requiring NTP or GPS."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"MVCC Integration"}),(0,o.jsx)("p",{children:"HLC timestamps MVCC versions. Transactions use HLC values for snapshot isolation. This provides consistent timestamps across distributed operations. Clock ordering ensures transaction serialization."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Wait-Free Reads"}),(0,o.jsx)("p",{children:"HLC enables wait-free read operations. No synchronization required for reads. Readers use HLC timestamps to select correct MVCC versions. This delivers maximum read throughput without coordination overhead."})]})]})]}),(0,o.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-4",children:"How Coordination Connects to the Foundation"}),(0,o.jsxs)("div",{className:"cardswrap",children:[(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Raft Consensus for Metadata"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Catalog and Meta Storage use Raft consensus. Metadata changes replicate through distributed consensus log. This provides strong consistency for schema and configuration without requiring external coordination services."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"HLC Enables MVCC"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Hybrid Logical Clock provides timestamps for MVCC versions. Transactions use HLC for snapshot isolation. This coordination primitive enables distributed transactions without external timestamp services."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn About Transactions"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/img/features/01-multi-tier-storage.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Catalog Enables Schema Evolution"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"The Catalog's versioned schema storage enables zero-downtime schema evolution. Atomic versioning ensures consistency. This coordination layer supports continuous deployment without maintenance windows."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/features/schema-evolution",className:"cardsimple__button button button--shadow",children:"Learn About Schema Evolution"})})]})]})]}),(0,o.jsx)("section",{className:"native-bottom container",children:(0,o.jsxs)("div",{className:"native-bottom__grid",children:[(0,o.jsxs)("article",{className:"nativebotblock",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Ready to Start?"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,o.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Read Documentation"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Learn about configuration management, catalog operations, and cluster coordination"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/configure-and-operate/configuration/config-cluster-and-nodes",target:"_blank",rel:"noreferrer",children:"Configuration Documentation"})]})]})})]})}}}]);
=======
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[899],{40830:(e,s,i)=>{i.d(s,{lZ:()=>n});var a=i(56347),t=i(44586);function n(){const e=(0,a.zy)(),{siteConfig:s}=(0,t.A)();let i=e.pathname;return"/"!==i&&i.endsWith("/")&&(i=i.slice(0,-1)),`${s.url}${i}`}},98895:(e,s,i)=>{i.r(s),i.d(s,{default:()=>c});i(96540);var a=i(19766),t=i(28774),n=i(5260),r=i(40830),o=i(74848);function c(){const e=(0,r.lZ)();return(0,o.jsxs)(a.A,{children:[(0,o.jsxs)(n.A,{children:[(0,o.jsx)("title",{children:"Coordination That Scales - Apache Ignite"}),(0,o.jsx)("meta",{name:"description",content:"Apache Ignite provides distributed coordination through Catalog, Meta Storage, and Hybrid Logical Clock. Type-safe configuration with hot reconfiguration. Schema metadata with version tracking enables zero-downtime evolution."}),(0,o.jsx)("link",{rel:"canonical",href:e}),(0,o.jsx)("meta",{property:"og:title",content:"Coordination That Scales - Apache Ignite"}),(0,o.jsx)("meta",{property:"og:type",content:"article"}),(0,o.jsx)("meta",{property:"og:url",content:e}),(0,o.jsx)("meta",{property:"og:image",content:"/suggested-site/img/og-pic.png"}),(0,o.jsx)("meta",{property:"og:description",content:"Apache Ignite provides distributed coordination through Catalog, Meta Storage, and Hybrid Logical Clock. Type-safe configuration with hot reconfiguration. Schema metadata with version tracking enables zero-downtime evolution."})]}),(0,o.jsx)("section",{className:"innerhero",children:(0,o.jsxs)("div",{className:"container innerhero__cont",children:[(0,o.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,o.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,o.jsx)("h1",{className:"h1 innerhero__h1",children:"Coordination That Scales"}),(0,o.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Distributed metadata, configuration, and event ordering"})]}),(0,o.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/suggested-site/img/features/hero-bg.svg",alt:"Coordination"})]})}),(0,o.jsx)("section",{className:"container pt-5 pb-5",children:(0,o.jsx)("div",{className:"pt-3 pb-3",children:(0,o.jsx)("p",{className:"fz20",children:"Apache Ignite provides distributed coordination primitives that scale with cluster size. The Catalog manages schema metadata with atomic versioning. Meta Storage provides distributed key-value coordination. Hybrid Logical Clock ensures event ordering. Type-safe configuration enables hot reconfiguration without restarts."})})}),(0,o.jsxs)("section",{className:"nativepersistence3 container",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Catalog: Schema Metadata Management"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Versioned Schema Storage"}),(0,o.jsx)("p",{children:"The Catalog stores table definitions, indexes, and distribution zones with version numbers. Schema changes create new versions atomically. All nodes see schema updates simultaneously. This eliminates inconsistent schema states during changes."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Schema Evolution Support"}),(0,o.jsx)("p",{children:"The Catalog enables schema evolution without downtime. Add columns to existing tables. Create indexes on populated tables. Modify distribution zones. Applications continue operating during schema changes with backward compatibility."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Multi-API Consistency"}),(0,o.jsx)("p",{children:"One Catalog schema serves SQL, RecordView, and KeyValueView. Schema changes apply to all access patterns simultaneously. No need to synchronize cache configurations separately. This unified approach prevents API inconsistencies."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Distributed Consensus"}),(0,o.jsx)("p",{children:"The Catalog uses Raft consensus for schema changes. Changes replicate through the consensus log before becoming visible. This ensures all nodes agree on schema state. No split-brain scenarios during network partitions."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Meta Storage: Distributed Key-Value Coordination"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Coordination Primitive"}),(0,o.jsx)("p",{children:"Meta Storage provides a distributed key-value store for coordination. Store cluster metadata, partition assignments, and node attributes. Access through get, put, and compare-and-swap operations. Raft consensus ensures consistency."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Watches and Notifications"}),(0,o.jsx)("p",{children:"Meta Storage supports watches on key prefixes. Applications receive notifications when watched keys change. This enables reactive patterns for topology changes, configuration updates, and partition reassignments."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Topology Management"}),(0,o.jsx)("p",{children:"Meta Storage tracks node membership and attributes. Nodes register on join. Updates propagate through consensus. Node failures detect through timeouts. This provides reliable cluster membership information."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Partition Assignment"}),(0,o.jsx)("p",{children:"Meta Storage stores partition-to-node assignments. Distribution zones query these assignments for data placement. Rebalancing updates assignments atomically. This coordination enables dynamic partition distribution."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Configuration Management"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Type-Safe Configuration"}),(0,o.jsx)("p",{children:"Apache Ignite uses typed configuration objects. Compile-time validation prevents configuration errors. IDE auto-completion helps discoverability. Generated documentation keeps configuration references current."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Hot Reconfiguration"}),(0,o.jsx)("p",{children:"Many configuration parameters support runtime updates. Change without cluster restarts. Updates propagate through Meta Storage. Nodes apply changes atomically. This enables operational adjustments without downtime."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Configuration Validation"}),(0,o.jsx)("p",{children:"The system validates configuration changes before applying them. Reject invalid values at submission time. Validate cross-parameter constraints. This prevents runtime failures from configuration errors."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Configuration History"}),(0,o.jsx)("p",{children:"Meta Storage maintains configuration history. Query previous configurations. Understand when changes occurred. This supports troubleshooting and compliance requirements."})]})]})]}),(0,o.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-3",children:"Hybrid Logical Clock"}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"Event Ordering"}),(0,o.jsx)("p",{children:"Hybrid Logical Clock (HLC) provides total ordering of events across nodes. Combines physical time with logical counters. Events order deterministically even when physical clocks skew. This enables causality tracking in distributed operations."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Clock Synchronization"}),(0,o.jsx)("p",{children:"HLC synchronizes through message passing. No external clock synchronization service required. Clock skew remains bounded within configured limits. This simplifies deployment compared to systems requiring NTP or GPS."})]})]}),(0,o.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,o.jsxs)("div",{className:"nativepersistence3__left",children:[(0,o.jsx)("h3",{className:"h5",children:"MVCC Integration"}),(0,o.jsx)("p",{children:"HLC timestamps MVCC versions. Transactions use HLC values for snapshot isolation. This provides consistent timestamps across distributed operations. Clock ordering ensures transaction serialization."})]}),(0,o.jsxs)("div",{className:"nativepersistence3__right",children:[(0,o.jsx)("h3",{className:"h5",children:"Wait-Free Reads"}),(0,o.jsx)("p",{children:"HLC enables wait-free read operations. No synchronization required for reads. Readers use HLC timestamps to select correct MVCC versions. This delivers maximum read throughput without coordination overhead."})]})]})]}),(0,o.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,o.jsx)("h2",{className:"h4 pb-4",children:"How Coordination Connects to the Foundation"}),(0,o.jsxs)("div",{className:"cardswrap",children:[(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/suggested-site/img/features/02-native-persistence.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Raft Consensus for Metadata"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Catalog and Meta Storage use Raft consensus. Metadata changes replicate through distributed consensus log. This provides strong consistency for schema and configuration without requiring external coordination services."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/suggested-site/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/suggested-site/img/features/04-ACID-transactions.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"HLC Enables MVCC"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"Hybrid Logical Clock provides timestamps for MVCC versions. Transactions use HLC for snapshot isolation. This coordination primitive enables distributed transactions without external timestamp services."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/suggested-site/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn About Transactions"})})]}),(0,o.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,o.jsx)("div",{className:"cardsimple__icon",children:(0,o.jsx)("img",{src:"/suggested-site/img/features/01-multi-tier-storage.svg",alt:""})}),(0,o.jsx)("h3",{className:"cardsimple__title",children:"Catalog Enables Schema Evolution"}),(0,o.jsx)("div",{className:"cardsimple__text",children:"The Catalog's versioned schema storage enables zero-downtime schema evolution. Atomic versioning ensures consistency. This coordination layer supports continuous deployment without maintenance windows."}),(0,o.jsx)("div",{className:"cardsimple__bottom",children:(0,o.jsx)(t.A,{to:"/suggested-site/features/schema-evolution",className:"cardsimple__button button button--shadow",children:"Learn About Schema Evolution"})})]})]})]}),(0,o.jsx)("section",{className:"native-bottom container",children:(0,o.jsxs)("div",{className:"native-bottom__grid",children:[(0,o.jsxs)("article",{className:"nativebotblock",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/suggested-site/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Ready to Start?"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,o.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,o.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,o.jsx)("img",{src:"/suggested-site/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,o.jsx)("span",{children:"Read Documentation"})]}),(0,o.jsx)("p",{className:"nativebotblock__text",children:"Learn about configuration management, catalog operations, and cluster coordination"}),(0,o.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/configure-and-operate/configuration/config-cluster-and-nodes",target:"_blank",rel:"noreferrer",children:"Configuration Documentation"})]})]})})]})}}}]);
>>>>>>> origin/master
