"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[6313],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},53166:e=>{e.exports=JSON.parse('{"permalink":"/suggested-site/blog/2025/12/23/ignite3-architecture-p5","editUrl":"https://github.com/apache/ignite-website/tree/master/blog/2025-12-23-ignite3-architecture-p5.md","source":"@site/blog/2025-12-23-ignite3-architecture-p5.md","title":"Eliminating Data Movement: The Hidden Cost of Distributed Event Processing","description":"Your high-velocity application processes events fast enough until it doesn\'t. The bottleneck isn\'t CPU or memory. It\'s data movement. Every time event processing requires data from another node, network latency adds milliseconds that compound into seconds of delay under load.","date":"2025-12-23T00:00:00.000Z","tags":[{"inline":true,"label":"architecture","permalink":"/suggested-site/blog/tags/architecture"},{"inline":true,"label":"technical","permalink":"/suggested-site/blog/tags/technical"},{"inline":true,"label":"ignite","permalink":"/suggested-site/blog/tags/ignite"},{"inline":true,"label":"ignite3","permalink":"/suggested-site/blog/tags/ignite-3"}],"readingTime":8.65,"hasTruncateMarker":true,"authors":[{"name":"Michael Aglietti","title":"Apache Ignite Contributor and DevRel","url":"https://github.com/maglietti","imageURL":"/suggested-site/img/authors/maglietti.png","key":"maglietti","page":null}],"frontMatter":{"title":"Eliminating Data Movement: The Hidden Cost of Distributed Event Processing","authors":["maglietti"],"date":"2025-12-23T00:00:00.000Z","tags":["architecture","technical","ignite","ignite3"]},"unlisted":false,"prevItem":{"title":"Distributed Consistency Under Load: When High-Velocity Meets High-Availability","permalink":"/suggested-site/blog/2025/12/30/ignite3-architecture-p6"},"nextItem":{"title":"Integrated Platform Performance: Maintaining Speed Under Pressure","permalink":"/suggested-site/blog/2025/12/16/ignite3-architecture-p4"}}')},54719:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var i=t(53166),s=t(74848),o=t(28453);const r={title:"Eliminating Data Movement: The Hidden Cost of Distributed Event Processing",authors:["maglietti"],date:new Date("2025-12-23T00:00:00.000Z"),tags:["architecture","technical","ignite","ignite3"]},a="Apache Ignite 3 Architecture Series: Part 5 \u2014 Eliminating Data Movement: The Hidden Cost of Distributed Event Processing",c={authorsImageUrls:[void 0]},l=[{value:"The Data Movement Tax on High-Velocity Applications",id:"the-data-movement-tax-on-high-velocity-applications",level:2},{value:"Network Latency Arithmetic",id:"network-latency-arithmetic",level:3},{value:"The Compound Effect of Distribution",id:"the-compound-effect-of-distribution",level:3},{value:"Strategic Data Placement Through Collocation",id:"strategic-data-placement-through-collocation",level:2},{value:"Apache Ignite Collocation Architecture",id:"apache-ignite-collocation-architecture",level:3},{value:"Table Design for Event Processing Collocation",id:"table-design-for-event-processing-collocation",level:3},{value:"Compute Collocation for Event Processing",id:"compute-collocation-for-event-processing",level:3},{value:"Real-World Collocation Performance Impact",id:"real-world-collocation-performance-impact",level:2},{value:"Financial Risk Calculation Example",id:"financial-risk-calculation-example",level:3},{value:"IoT Event Processing Example",id:"iot-event-processing-example",level:3},{value:"Collocation Strategy Selection",id:"collocation-strategy-selection",level:2},{value:"Event-Driven Collocation Patterns",id:"event-driven-collocation-patterns",level:3},{value:"Automatic Query Optimization Through Collocation",id:"automatic-query-optimization-through-collocation",level:3},{value:"Performance Validation",id:"performance-validation",level:3},{value:"The Business Impact of Eliminating Data Movement",id:"the-business-impact-of-eliminating-data-movement",level:2},{value:"Cost Reduction",id:"cost-reduction",level:3},{value:"Performance Gains",id:"performance-gains",level:3},{value:"Application Capabilities",id:"application-capabilities",level:3},{value:"The Architectural Evolution",id:"the-architectural-evolution",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Your high-velocity application processes events fast enough until it doesn't. The bottleneck isn't CPU or memory. It's data movement. Every time event processing requires data from another node, network latency adds milliseconds that compound into seconds of delay under load."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Part 5 of 8 in the Apache Ignite 3 Architecture Series"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Consider a financial trading system processing peak loads of 10,000 trades per second. Each trade requires risk calculations against a customer's portfolio. If portfolio data lives on different nodes than the processing logic, network round-trips create an impossible performance equation: 10,000 trades \xd7 2ms network latency = 20 seconds of network delay per second of wall clock time."}),"\n",(0,s.jsx)(n.p,{children:"Apache Ignite eliminates this constraint through data collocation. Related data and processing live on the same nodes, transforming distributed operations into local memory operations."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The result: distributed system performance without distributed system overhead."})}),"\n",(0,s.jsx)(n.h2,{id:"the-data-movement-tax-on-high-velocity-applications",children:"The Data Movement Tax on High-Velocity Applications"}),"\n",(0,s.jsx)(n.h3,{id:"network-latency-arithmetic",children:"Network Latency Arithmetic"}),"\n",(0,s.jsx)(n.p,{children:"At scale, network latency creates mathematical impossibilities:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Here's what distributed processing costs in practice:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Traditional distributed processing (data on different nodes)\nlong startTime = System.nanoTime();\n// 1. Fetch event data (potentially remote: 0.5-2 ms)\nEventData event = eventService.getEvent(eventId);                       // Network: 0.5-2 ms\n// 2. Fetch related customer data (potentially remote: 0.5-2 ms)\nCustomerData customer = customerService.getCustomer(event.customerId);  // Network: 0.5-2 ms\n// 3. Fetch processing rules (potentially remote: 0.5-2 ms)\nProcessingRules rules = rulesService.getRules(customer.segment);        // Network: 0.5-2 ms\n// 4. Execute processing logic (local: 0.1 ms)\nProcessingResult result = processEvent(event, customer, rules);         // CPU: 0.1 ms\n// 5. Store results (potentially remote: 0.5-2 ms)\nresultService.storeResult(eventId, result);                             // Network: 0.5-2 ms\nlong totalTime = System.nanoTime() - startTime;\n// Total: 2.6-10.1 ms per event (90%+ network overhead)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"At Scale:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1,000 events/sec \xd7 5 ms average = 5 seconds processing time per second (impossible)"}),"\n",(0,s.jsx)(n.li,{children:"10,000 events/sec \xd7 5 ms average = 50 seconds processing time per second (catastrophic)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-compound-effect-of-distribution",children:"The Compound Effect of Distribution"}),"\n",(0,s.jsx)(n.p,{children:"Real applications don't just move data once per event. They move data multiple times:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Here's how the cascade effect compounds:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Multi-hop data movement for single order\nOrderEvent order = getOrder(orderId);                                    // Network hop 1: 1 ms\nCustomerData customer = getCustomer(order.customerId);                   // Network hop 2: 1 ms\nInventoryData inventory = getInventory(order.productId);                 // Network hop 3: 1 ms\nPricingData pricing = getPricing(order.productId, customer.segment);     // Network hop 4: 1 ms\nPaymentData payment = processPayment(order.amount, customer.paymentId);  // Network hop 5: 2 ms\nShippingData shipping = calculateShipping(order, customer.address);      // Network hop 6: 1 ms\nPromotionData promotions = applyPromotions(order, customer);             // Network hop 7: 1 ms\n// Total network overhead: 8ms per order (before any business logic)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The cascade effect"}),": Each data dependency creates another network round-trip. Complex event processing can require 10+ network operations per event."]}),"\n",(0,s.jsx)(n.h2,{id:"strategic-data-placement-through-collocation",children:"Strategic Data Placement Through Collocation"}),"\n",(0,s.jsx)(n.h3,{id:"apache-ignite-collocation-architecture",children:"Apache Ignite Collocation Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Apache Ignite uses deterministic hash distribution to ensure related data lands on the same nodes. The platform automatically generates consistent hash values for collocation keys, ensuring all data with the same collocation key always lands on the same node. This deterministic placement means that once data is collocated, subsequent access patterns benefit from data locality without manual coordination."}),"\n",(0,s.jsx)(n.h3,{id:"table-design-for-event-processing-collocation",children:"Table Design for Event Processing Collocation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create distribution zone for customer-based collocation\nCREATE ZONE customer_zone WITH\n    partitions=64,\n    replicas=3;\n\n-- Orders table using customer-based distribution zone\nCREATE TABLE orders (\n    order_id BIGINT PRIMARY KEY,\n    customer_id BIGINT,\n    product_id BIGINT,\n    amount DECIMAL(10,2),\n    order_date TIMESTAMP\n) WITH ZONE='customer_zone';\n\n-- Customer data using same distribution zone for collocation\nCREATE TABLE customers (\n    customer_id BIGINT PRIMARY KEY,\n    name VARCHAR(100),\n    segment VARCHAR(20),\n    payment_method VARCHAR(50)\n) WITH ZONE='customer_zone';\n\n-- Customer pricing using same zone for collocation\nCREATE TABLE customer_pricing (\n    customer_id BIGINT,\n    product_id BIGINT,\n    price DECIMAL(10,2),\n    discount_rate DECIMAL(5,2),\n    PRIMARY KEY (customer_id, product_id)\n) WITH ZONE='customer_zone';\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": All tables using the same distribution zone share the same partitioning strategy. Data for customer 12345 distributes to the same partition across all tables, enabling local processing without network communication."]}),"\n",(0,s.jsx)(n.h3,{id:"compute-collocation-for-event-processing",children:"Compute Collocation for Event Processing"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Processing Moves to Where Data Lives:"})}),"\n",(0,s.jsx)(n.p,{children:"Instead of moving data to processing logic, compute jobs execute on the nodes where related data already exists. For customer order processing, the compute job runs on the node containing the customer's data, orders, and pricing information. All data access becomes local memory operations rather than network calls."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Simple Collocation Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Execute processing where customer data lives\nTuple customerKey = Tuple.create().set("customer_id", customerId);\nCompletableFuture<OrderResult> future = client.compute().executeAsync(\n    JobTarget.colocated("customers", customerKey),  // Run on node with customer data\n    OrderProcessingJob.class,\n    customerId\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Impact"}),": 8ms distributed processing becomes sub-millisecond collocated processing through data locality."]}),"\n",(0,s.jsx)(n.h2,{id:"real-world-collocation-performance-impact",children:"Real-World Collocation Performance Impact"}),"\n",(0,s.jsx)(n.h3,{id:"financial-risk-calculation-example",children:"Financial Risk Calculation Example"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Trading system needs real-time portfolio risk calculation for each trade."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Here's what the distributed approach costs:"})}),"\n",(0,s.jsx)(n.p,{children:"Traditional risk calculations require multiple network calls: fetch trade details (1ms), retrieve portfolio data (2ms), get current market prices (1ms), and load risk rules (1ms). The actual risk calculation takes 0.2ms, but network overhead dominates at 5.2ms total. At 10,000 trades per second, this creates 52 seconds of processing time per second. This is mathematically impossible."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Collocated Risk Processing:"})}),"\n",(0,s.jsx)(n.p,{children:"When account portfolios, trade histories, and risk rules collocate by account ID, risk calculations become local operations. All required data lives on the same node where the processing executes. Network overhead disappears, transforming 5.2ms distributed operations into sub-millisecond local calculations."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Business Impact:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trading velocity"}),": Process 10,000+ trades per second with real-time risk assessment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Risk accuracy"}),": Use complete portfolio context without stale data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regulatory compliance"}),": Meet sub-second risk calculation requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"iot-event-processing-example",children:"IoT Event Processing Example"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Manufacturing system processes sensor events requiring contextual data for anomaly detection."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Collocated Design"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create distribution zone for equipment-based collocation\nCREATE ZONE equipment_zone WITH\n    partitions=32,\n    replicas=2;\n\n-- Sensor data using equipment-based distribution zone\nCREATE TABLE sensor_readings (\n    sensor_id BIGINT,\n    equipment_id BIGINT,\n    timestamp TIMESTAMP,\n    temperature DECIMAL(5,2),\n    pressure DECIMAL(8,2),\n    vibration DECIMAL(6,3),\n    PRIMARY KEY (sensor_id, timestamp)\n) WITH ZONE='equipment_zone';\n\n-- Equipment specifications using same zone for collocation\nCREATE TABLE equipment_specs (\n    equipment_id BIGINT PRIMARY KEY,\n    max_temperature DECIMAL(5,2),\n    max_pressure DECIMAL(8,2),\n    max_vibration DECIMAL(6,3),\n    maintenance_schedule VARCHAR(50)\n) WITH ZONE='equipment_zone';\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Processing Performance:"})}),"\n",(0,s.jsx)(n.p,{children:"Anomaly detection jobs execute on the nodes containing the equipment data they analyze. Current sensor readings, historical patterns, and equipment specifications all reside locally. The processing accesses recent sensor data, compares against equipment tolerances, and detects anomalies without any network calls."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Outcome"}),": Sub-millisecond anomaly detection vs multi-millisecond distributed processing. Single cluster processes tens of thousands of sensor readings per second with real-time anomaly detection."]}),"\n",(0,s.jsx)(n.h2,{id:"collocation-strategy-selection",children:"Collocation Strategy Selection"}),"\n",(0,s.jsx)(n.h3,{id:"event-driven-collocation-patterns",children:"Event-Driven Collocation Patterns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Customer-Centric Applications"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Customer-focused distribution zone\nCREATE ZONE customer_zone WITH partitions=64;\nCREATE TABLE orders (...) WITH ZONE='customer_zone';\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Orders, payments, preferences, history distributed by customer key"}),"\n",(0,s.jsx)(n.li,{children:"Customer service queries access data from same partition"}),"\n",(0,s.jsx)(n.li,{children:"Personalization engines process complete customer context locally"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Time-Series Event Processing"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Time-based distribution zone\nCREATE ZONE hourly_zone WITH partitions=24;\nCREATE TABLE events (...) WITH ZONE='hourly_zone';\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Recent events distribute based on time windows"}),"\n",(0,s.jsx)(n.li,{children:"Historical analysis accesses time-coherent partitions"}),"\n",(0,s.jsx)(n.li,{children:"Event correlation happens without cross-node communication"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Geographic Distribution"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Region-based distribution zone\nCREATE ZONE regional_zone WITH partitions=16;\nCREATE TABLE locations (...) WITH ZONE='regional_zone';\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Regional data partitions to regional node groups"}),"\n",(0,s.jsx)(n.li,{children:"Location-aware services access local partition data"}),"\n",(0,s.jsx)(n.li,{children:"Geographic analytics minimize cross-region data movement"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"automatic-query-optimization-through-collocation",children:"Automatic Query Optimization Through Collocation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When related data lives together, query performance transforms:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Before collocation: expensive cross-node JOINs\nSELECT c.name, o.order_total, p.amount\nFROM customers c\n  JOIN orders o ON c.customer_id = o.customer_id\n  JOIN payments p ON o.order_id = p.order_id\nWHERE c.customer_id = 12345;\n-- Network overhead: 3 tables \xd7 potential cross-node fetches = high latency\n\n-- After collocation: local memory JOINs\n-- Same query, but all customer 12345 data lives on same node\n-- Result: JOIN operations become local memory operations\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Complex Analytics Become Local Operations:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Complex analytical query becomes local operation\nResultSet<SqlRow> customerAnalysis = client.sql().execute(tx, """\n    SELECT\n        c.segment,\n        COUNT(o.order_id) as order_count,\n        SUM(o.amount) as total_spent,\n        AVG(p.processing_time) as avg_payment_time\n    FROM customers c\n      JOIN orders o ON c.customer_id = o.customer_id\n      JOIN payments p ON o.order_id = p.order_id\n    WHERE c.registration_date >= ?\n    GROUP BY c.segment\n    HAVING total_spent > 10000\n""", lastMonth);\n// When all three tables share the same distribution zone:\n// - Multi-table JOINs execute locally per partition\n// - No network overhead for related data access\n// - Query performance scales with CPU, not network bandwidth\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Query Performance Transformation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JOIN operations"}),": Cross-node network calls \u2192 local memory operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex analytics"}),": Network-bound \u2192 CPU-bound (much faster)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Query planning"}),": Distributed execution \u2192 local partition execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance scaling"}),": Limited by network \u2192 limited by CPU/memory"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The performance transformation"}),": Query optimization through data placement. When related data lives together, complex queries become simple local operations, fundamentally changing performance characteristics."]}),"\n",(0,s.jsx)(n.h3,{id:"performance-validation",children:"Performance Validation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Collocation Effectiveness Monitoring:"})}),"\n",(0,s.jsx)(n.p,{children:"Apache Ignite provides built-in metrics to monitor collocation effectiveness: query response times, network traffic patterns, and CPU utilization versus network wait time. Effective collocation strategies achieve specific performance indicators that demonstrate data locality success."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Success Indicators:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local execution"}),": 95%+ of queries execute locally without network hops"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory-speed access"}),": Average query latency under 1 ms for collocated data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU utilization"}),": 80%+ processing time versus network waiting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Predictable performance"}),": Consistent response times independent of cluster size"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-business-impact-of-eliminating-data-movement",children:"The Business Impact of Eliminating Data Movement"}),"\n",(0,s.jsx)(n.h3,{id:"cost-reduction",children:"Cost Reduction"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Infrastructure"}),": 10x reduction in inter-node bandwidth requirements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Efficiency"}),": Higher CPU/memory utilization vs network-bound systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operational Complexity"}),": Fewer moving parts in event processing pipelines"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-gains",children:"Performance Gains"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Response Time"}),": 10-50x improvement in event processing latency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Throughput"}),": 5-10x higher event processing capacity with same hardware"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Predictability"}),": Consistent performance independent of network conditions"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"application-capabilities",children:"Application Capabilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-Time Analytics"}),": Sub-millisecond analytics on live transactional event streams"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Event Processing"}),": Multi-step event processing without coordination overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interactive Applications"}),": User-facing features with database-backed logic at cache speeds"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-architectural-evolution",children:"The Architectural Evolution"}),"\n",(0,s.jsx)(n.p,{children:"Traditional distributed systems accept network overhead as inevitable. Apache Ignite eliminates it through intelligent data placement."}),"\n",(0,s.jsx)(n.p,{children:"Your high-velocity application doesn't need to choose between distributed scale and local performance. Collocation provides both: the data capacity and fault tolerance of distributed systems with the performance characteristics of single-node processing."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The principle"}),": Collocate related data, localize dependent processing."]}),"\n",(0,s.jsx)(n.p,{children:"Every network hop you eliminate returns performance to your application's processing budget. At high event volumes, those performance gains determine whether your architecture scales with your business success or becomes the constraint that limits it."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Return next Tuesday for Part 6 to discover how distributed consensus maintains data consistency during high-frequency operations. We'll explore how to preserve the performance gains from collocation while ensuring your high-velocity applications remain both fast and reliable."})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);