"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2726],{40830:(e,s,i)=>{i.d(s,{lZ:()=>t});var a=i(56347),n=i(44586);function t(){const e=(0,a.zy)(),{siteConfig:s}=(0,n.A)();let i=e.pathname;return"/"!==i&&i.endsWith("/")&&(i=i.slice(0,-1)),`${s.url}${i}`}},89763:(e,s,i)=>{i.r(s),i.d(s,{default:()=>r});i(96540);var a=i(19766),n=i(28774),t=i(5260),c=i(40830),l=i(74848);function r(){const e=(0,c.lZ)();return(0,l.jsxs)(a.A,{children:[(0,l.jsxs)(t.A,{children:[(0,l.jsx)("title",{children:"Schema Evolution Without Downtime - Apache Ignite"}),(0,l.jsx)("meta",{name:"description",content:"Apache Ignite enables schema changes without cluster restarts. Catalog-driven schema management provides atomic versioning. Add columns, modify indexes, and change distributions while applications continue running."}),(0,l.jsx)("link",{rel:"canonical",href:e}),(0,l.jsx)("meta",{property:"og:title",content:"Schema Evolution Without Downtime - Apache Ignite"}),(0,l.jsx)("meta",{property:"og:type",content:"article"}),(0,l.jsx)("meta",{property:"og:url",content:e}),(0,l.jsx)("meta",{property:"og:image",content:"/suggested-site/img/og-pic.png"}),(0,l.jsx)("meta",{property:"og:description",content:"Apache Ignite enables schema changes without cluster restarts. Catalog-driven schema management provides atomic versioning. Add columns, modify indexes, and change distributions while applications continue running."})]}),(0,l.jsx)("section",{className:"innerhero",children:(0,l.jsxs)("div",{className:"container innerhero__cont",children:[(0,l.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,l.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,l.jsx)("h1",{className:"h1 innerhero__h1",children:"Schema Evolution Without Downtime"}),(0,l.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Add columns, modify indexes, change distributions. Applications keep running."})]}),(0,l.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/suggested-site/img/features/hero-bg.svg",alt:"Schema Evolution"})]})}),(0,l.jsx)("section",{className:"container pt-5 pb-5",children:(0,l.jsx)("div",{className:"pt-3 pb-3",children:(0,l.jsx)("p",{className:"fz20",children:"Apache Ignite enables schema changes without cluster restarts. Catalog-driven schema management provides atomic versioning. Add columns, modify indexes, and change distributions while applications continue running. Deploy features continuously without maintenance windows."})})}),(0,l.jsxs)("section",{className:"nativepersistence3 container",children:[(0,l.jsx)("h2",{className:"h4 pb-3",children:"Catalog-Driven Schema Management"}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Atomic Schema Versioning"}),(0,l.jsx)("p",{children:"The catalog stores schema definitions with version numbers. Schema changes create new versions atomically. All nodes see schema changes simultaneously. No partial updates. No synchronization windows. This eliminates inconsistent schema states during changes."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"Zero-Downtime Changes"}),(0,l.jsx)("p",{children:"Schema changes execute while the cluster processes requests. Add columns to existing tables. Create new indexes on populated tables. Modify distribution zones for existing data. Applications continue reading and writing during changes."})]})]}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Backward Compatibility"}),(0,l.jsx)("p",{children:"New schema versions maintain compatibility with existing data. Nullable columns default to NULL for existing rows. Applications running older schema versions continue functioning. This enables gradual application rollouts without coordinated deployments."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"Transaction Safety"}),(0,l.jsx)("p",{children:"Ongoing transactions complete under their starting schema version. New transactions use the latest schema. No transaction failures from schema changes. MVCC ensures transactions see consistent schema states throughout execution."})]})]})]}),(0,l.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,l.jsx)("h2",{className:"h4 pb-3",children:"Schema Operations"}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Column Operations"}),(0,l.jsx)("p",{children:"Add columns with default values. Drop unused columns. Modify column types when safe. All operations execute without blocking reads or writes. The system handles data migration transparently for storage engines."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"Index Management"}),(0,l.jsx)("p",{children:"Create indexes on existing tables without downtime. The system builds indexes in the background while serving queries. Drop unused indexes immediately. Index changes become visible atomically across the cluster."})]})]}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Distribution Changes"}),(0,l.jsx)("p",{children:"Modify distribution zones for existing tables. Change replica counts. Adjust node filters. The system rebalances data automatically. Applications continue operating during rebalancing with no impact on consistency."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"Colocation Changes"}),(0,l.jsx)("p",{children:"Modify colocation keys requires table recreation. The catalog enforces this constraint to prevent incorrect query results. Plan colocation carefully during initial schema design. This trade-off ensures correctness for colocated joins."})]})]})]}),(0,l.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,l.jsx)("h2",{className:"h4 pb-3",children:"Multiple API Views"}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Single Schema, Multiple APIs"}),(0,l.jsx)("p",{children:"One catalog schema serves SQL, RecordView, and KeyValueView. Schema changes apply to all access patterns simultaneously. No need to update cache configurations separately. This simplifies operations and prevents API inconsistencies."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"API Compatibility"}),(0,l.jsx)("p",{children:"SQL sees new columns immediately after schema changes. RecordView and KeyValueView reflect updated schemas through type-safe interfaces. Applications check schema versions to handle new columns gracefully. This enables progressive rollouts."})]})]}),(0,l.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,l.jsxs)("div",{className:"nativepersistence3__left",children:[(0,l.jsx)("h3",{className:"h5",children:"Client Schema Awareness"}),(0,l.jsx)("p",{children:"Clients fetch current schema versions automatically. Type-safe APIs validate against current schemas. The protocol includes schema metadata for correct serialization. This prevents version mismatches between clients and cluster."})]}),(0,l.jsxs)("div",{className:"nativepersistence3__right",children:[(0,l.jsx)("h3",{className:"h5",children:"Development Workflow"}),(0,l.jsx)("p",{children:"Define schemas using DDL statements or Table API. Test schema changes in development environments. Apply identical changes to production clusters. The catalog ensures deterministic behavior across environments."})]})]})]}),(0,l.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,l.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,l.jsxs)("div",{className:"cardswrap",children:[(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/06-compute-APIs.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"Continuous Deployment"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"Deploy application features without maintenance windows. Add columns for new functionality. Create indexes to optimize new query patterns. Roll out changes gradually across application tiers. Zero-downtime evolution enables continuous delivery."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/use-cases/microservices-state",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/03-distributed-SQL.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"A/B Testing"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"Add columns for experimental features. New application versions write to new columns. Old versions ignore them gracefully. Collect metrics on both approaches. Remove unsuccessful experiments by dropping columns."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/09-streaming.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"Evolving Data Models"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"Adapt schemas as requirements change. Add columns for new attributes. Create indexes as query patterns evolve. Modify distributions as data growth patterns change. Schema evolution supports changing business needs."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/use-cases/event-stream-processing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,l.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,l.jsx)("h2",{className:"h4 pb-4",children:"How Schema Evolution Connects to the Foundation"}),(0,l.jsxs)("div",{className:"cardswrap",children:[(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/08-services.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"Catalog Provides Consistency"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"The catalog uses distributed consensus for schema changes. All nodes see schema updates atomically. Version numbers ensure consistent views. This coordination enables zero-downtime schema evolution at scale."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/04-ACID-transactions.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"MVCC Enables Safe Evolution"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"MVCC allows ongoing transactions to complete under old schema versions. New transactions use updated schemas. No transaction failures from schema changes. Version chains support multiple schema versions simultaneously."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About MVCC"})})]}),(0,l.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,l.jsx)("div",{className:"cardsimple__icon",children:(0,l.jsx)("img",{src:"/suggested-site/img/features/03-distributed-SQL.svg",alt:""})}),(0,l.jsx)("h3",{className:"cardsimple__title",children:"Unified Schema for All APIs"}),(0,l.jsx)("div",{className:"cardsimple__text",children:"SQL, RecordView, and KeyValueView share the same catalog schema. Schema changes apply to all access patterns simultaneously. This unified approach simplifies operations and prevents inconsistencies."}),(0,l.jsx)("div",{className:"cardsimple__bottom",children:(0,l.jsx)(n.A,{to:"/suggested-site/features/sql",className:"cardsimple__button button button--shadow",children:"Learn About Access Patterns"})})]})]})]}),(0,l.jsx)("section",{className:"native-bottom container",children:(0,l.jsxs)("div",{className:"native-bottom__grid",children:[(0,l.jsxs)("article",{className:"nativebotblock",children:[(0,l.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,l.jsx)("img",{src:"/suggested-site/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,l.jsx)("span",{children:"Ready to Start?"})]}),(0,l.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,l.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,l.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,l.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,l.jsx)("img",{src:"/suggested-site/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,l.jsx)("span",{children:"Read Documentation"})]}),(0,l.jsx)("p",{className:"nativebotblock__text",children:"Learn about table creation, schema modifications, and catalog operations"}),(0,l.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/develop/work-with-data/table-api",target:"_blank",rel:"noreferrer",children:"Tables Documentation"})]})]})})]})}}}]);