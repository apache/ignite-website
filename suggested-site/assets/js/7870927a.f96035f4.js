"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2910],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},28785:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/2025-12-04-How-Many-Client-Connections-Can-Ignite-Handle-5f6f9a1d704d396d7306313ec234a9d4.png"},88145:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var i=t(96949),s=t(74848),o=t(28453);const a={title:"How many client connections can Apache Ignite 3 handle?",authors:["pavel"],date:new Date("2025-12-11T00:00:00.000Z"),tags:["performance","technical","ignite","ignite3"]},c=void 0,r={authorsImageUrls:[void 0]},l=[{value:"The Question",id:"the-question",level:2},{value:"Testing Setup",id:"testing-setup",level:2},{value:"Server",id:"server",level:3},{value:"Client",id:"client",level:3},{value:"Ephemeral Port Exhaustion",id:"ephemeral-port-exhaustion",level:3},{value:"Results",id:"results",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Apache Ignite 3 manages client connections so efficiently that the scaling limits common in database-style systems simply aren't a factor."}),"\n",(0,s.jsx)(n.h2,{id:"the-question",children:"The Question"}),"\n",(0,s.jsx)(n.p,{children:'A common capacity planning question we get from users is: "How many client connections can one Ignite node maintain?"'}),"\n",(0,s.jsx)(n.p,{children:"With traditional relational databases, the common knowledge is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Client connection is typically single-threaded and short-lived. "Open -> Do work -> Close" is the usual pattern.'}),"\n",(0,s.jsxs)(n.li,{children:["The server can handle a limited number of concurrent connections.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/current/runtime-config-connection.html#GUC-MAX-CONNECTIONS",children:"Postgres defaults to 100"})," ",(0,s.jsx)(n.code,{children:"max_connections"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Each connection has significant memory overhead (",(0,s.jsx)(n.a,{href:"https://blog.anarazel.de/2020/10/07/measuring-the-memory-overhead-of-a-postgres-connection/",children:"a few MBs"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["An external connection pool (like ",(0,s.jsx)(n.a,{href:"https://www.pgbouncer.org/",children:"PgBouncer"}),") is recommended to improve scalability."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://ignite.apache.org/",children:"Apache Ignite 3"})," is quite different:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Client connections are long-lived, multiplexed, and thread-safe. Quite often, a single client connection is enough for the entire application lifetime."}),"\n",(0,s.jsx)(n.li,{children:"On the server side, each client connection has a small memory footprint (a few KB)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach with cheap long-lived connections provides low latency and great scalability for applications:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The connection is always open and responds to queries immediately."}),"\n",(0,s.jsx)(n.li,{children:"Multiple queries can be executed concurrently over the same connection (multiplexing)."}),"\n",(0,s.jsx)(n.li,{children:"No need for an external connection pool."}),"\n",(0,s.jsx)(n.li,{children:"Query metadata is cached by the client connection, improving performance for repeated queries."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's see how many concurrent client connections a single Apache Ignite 3 node can handle."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"testing-setup",children:"Testing Setup"}),"\n",(0,s.jsx)(n.h3,{id:"server",children:"Server"}),"\n",(0,s.jsxs)(n.p,{children:["I'm going to use the ",(0,s.jsx)(n.a,{href:"https://ignite.apache.org/download.cgi",children:"binary distribution"})," of Apache Ignite 3.1.0 for this test."]}),"\n",(0,s.jsxs)(n.p,{children:["The default node configuration is good enough, the only thing I changed was the logging level in ",(0,s.jsx)(n.code,{children:"etc/ignite.java.util.logging.properties"})," to reduce logging overhead."]}),"\n",(0,s.jsx)(n.h3,{id:"client",children:"Client"}),"\n",(0,s.jsxs)(n.p,{children:["To establish the connections, I'm using the ",(0,s.jsx)(n.a,{href:"https://www.nuget.org/packages/Apache.Ignite/3.1.0",children:"Ignite.NET client"})," in a simple console app that connects to the server in a loop and keeps the connections open. After the loop we verify that all connections are still alive."]}),"\n",(0,s.jsxs)(n.p,{children:["Full program is on GitHub: ",(0,s.jsx)(n.a,{href:"https://gist.github.com/ptupitsyn/86056d4143811ba5dde6b2d1704fa948",children:"https://gist.github.com/ptupitsyn/86056d4143811ba5dde6b2d1704fa948"})]}),"\n",(0,s.jsx)(n.h3,{id:"ephemeral-port-exhaustion",children:"Ephemeral Port Exhaustion"}),"\n",(0,s.jsxs)(n.p,{children:["In the program you can notice the trick with multiple localhost addresses (",(0,s.jsx)(n.code,{children:"127.0.0.1"}),", ",(0,s.jsx)(n.code,{children:"127.0.0.2"}),", etc). Without it, after about 28k connections, the program fails with a ",(0,s.jsx)(n.code,{children:"SocketException (99): Cannot assign requested address"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Basically, every TCP connection has a source ",(0,s.jsx)(n.code,{children:"IP:port"})," pair and the port is chosen from the ephemeral port range (typically 32768\u201360999 on Linux). We can't have more connections on the same address than the number of ephemeral ports available. Using multiple localhost addresses works around this limitation."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"results",children:"Results"}),"\n",(0,s.jsxs)(n.p,{children:["I'm starting to get weird errors and timeouts at about 250k (yes, 250 thousand) connections with default settings. At ",(0,s.jsx)(n.strong,{children:"200k connections"})," the system is stable and responsive, so I decided to stop the test there."]}),"\n",(0,s.jsxs)(n.p,{children:["Initial memory usage of the Apache Ignite node was about 200 MB, and with 200k active connections it was about 900 MB after a full GC, about ",(0,s.jsx)(n.strong,{children:"3.5 KB per connection"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"VisualVM screenshot:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"VisualVM memory usage with 200k client connections",src:t(28785).A+"",width:"700",height:"538"})}),"\n",(0,s.jsx)(n.p,{children:"Client log:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Connected 200000 connections in 00:02:49.2601996\nVerified connectivity in 00:00:09.1446883\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that each connection exchanges a heartbeat message every 10 seconds, so the system is not completely idle. We have about 20k small requests per second, but this barely requires any CPU."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Apache Ignite client connections are very lightweight, so open as many as your application requires and keep them open for the best performance!"})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},96949:e=>{e.exports=JSON.parse('{"permalink":"/suggested-site/blog/2025/12/10/ignite3-client-connections","editUrl":"https://github.com/apache/ignite-website/tree/master/blog/2025-12-10-ignite3-client-connections.md","source":"@site/blog/2025-12-10-ignite3-client-connections.md","title":"How many client connections can Apache Ignite 3 handle?","description":"Apache Ignite 3 manages client connections so efficiently that the scaling limits common in database-style systems simply aren\'t a factor.","date":"2025-12-11T00:00:00.000Z","tags":[{"inline":true,"label":"performance","permalink":"/suggested-site/blog/tags/performance"},{"inline":true,"label":"technical","permalink":"/suggested-site/blog/tags/technical"},{"inline":true,"label":"ignite","permalink":"/suggested-site/blog/tags/ignite"},{"inline":true,"label":"ignite3","permalink":"/suggested-site/blog/tags/ignite-3"}],"readingTime":2.93,"hasTruncateMarker":true,"authors":[{"name":"Pavel Tupitsyn","title":"Apache Ignite Committer","url":"https://github.com/ptupitsyn","imageURL":"https://github.com/ptupitsyn.png","key":"pavel","page":null}],"frontMatter":{"title":"How many client connections can Apache Ignite 3 handle?","authors":["pavel"],"date":"2025-12-11T00:00:00.000Z","tags":["performance","technical","ignite","ignite3"]},"unlisted":false,"nextItem":{"title":"Schema Evolution Under Operational Pressure: When Downtime Isn\'t an Option","permalink":"/suggested-site/blog/2025/12/09/ignite3-architecture-p3"}}')}}]);