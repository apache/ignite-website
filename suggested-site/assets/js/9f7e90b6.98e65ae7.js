<<<<<<< HEAD
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[237],{40073:(e,s,i)=>{i.r(s),i.d(s,{default:()=>l});i(96540);var a=i(19766),t=i(28774),r=i(5260),n=i(40830),c=i(74848);function l(){const e=(0,n.lZ)();return(0,c.jsxs)(a.A,{children:[(0,c.jsxs)(r.A,{children:[(0,c.jsx)("title",{children:"Architectural Foundation - Apache Ignite"}),(0,c.jsx)("meta",{name:"description",content:"The architectural backbone of Apache Ignite: MVCC and distributed replication via Raft enable memory-first distributed computing without sacrificing consistency or availability."}),(0,c.jsx)("link",{rel:"canonical",href:e}),(0,c.jsx)("meta",{property:"og:title",content:"Architectural Foundation - Apache Ignite"}),(0,c.jsx)("meta",{property:"og:type",content:"article"}),(0,c.jsx)("meta",{property:"og:url",content:e}),(0,c.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,c.jsx)("meta",{property:"og:description",content:"The architectural backbone of Apache Ignite: MVCC and distributed replication via Raft enable memory-first distributed computing without sacrificing consistency or availability."})]}),(0,c.jsx)("section",{className:"innerhero",children:(0,c.jsxs)("div",{className:"container innerhero__cont",children:[(0,c.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,c.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,c.jsx)("h1",{className:"h1 innerhero__h1",children:"The Architectural Backbone"}),(0,c.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Two foundational choices that make memory-first distributed computing possible"})]}),(0,c.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Architectural Foundation"})]})}),(0,c.jsx)("section",{className:"container pt-5 pb-5",children:(0,c.jsx)("div",{className:"pt-3 pb-3",children:(0,c.jsx)("p",{className:"fz20",children:"Two foundational architectural choices enable everything Apache Ignite delivers. These aren't implementation details. They're the backbone that makes memory-first distributed computing possible without sacrificing consistency or availability."})})}),(0,c.jsxs)("section",{className:"nativepersistence3 container",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"MVCC: Multi-Version Concurrency Control"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"The Fundamental Problem"}),(0,c.jsx)("p",{children:"How do you serve reads and writes concurrently without blocking? Traditional locking approaches force a choice: either readers block writers, writers block readers, or you accept eventual consistency."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"The Solution"}),(0,c.jsx)("p",{children:"MVCC solves this by creating a new version for every write, tagged with a timestamp. Readers work against stable snapshots while writers create new versions. Readers and writers never block each other."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"How It Works"}),(0,c.jsx)("p",{children:"Every row exists as a version chain. Each write adds a new version with begin and commit timestamps. Transactions read from a snapshot determined by their start time. The system maintains multiple versions until older snapshots complete."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"What This Enables"}),(0,c.jsx)("p",{children:"Snapshot isolation (REPEATABLE_READ) without traditional locking overhead. Analytical queries execute on stable snapshots while transactional updates proceed at full speed. Long-running reads don't block operational writes."})]})]}),(0,c.jsx)("div",{className:"pt-4",children:(0,c.jsx)("a",{href:"/docs/ignite3/3.1.0/develop/work-with-data/transactions",className:"button button--shadow",target:"_blank",rel:"noreferrer",children:"Read Transactions Documentation"})})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Distributed Replication"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Consensus-Based Replication"}),(0,c.jsx)("p",{children:"Making distributed state changes safe requires consensus. Apache Ignite uses Raft consensus for replication. Each partition forms a Raft group with a leader and followers."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"How Leader Election Works"}),(0,c.jsx)("p",{children:"When a leader fails, the remaining nodes elect a new leader through the Raft protocol. Leader election completes in milliseconds. The new leader continues serving requests without data loss."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"WAL-Free Architecture"}),(0,c.jsx)("p",{children:"Apache Ignite uses Raft consensus for durability instead of traditional write-ahead logs. The leader processes writes and replicates through the distributed consensus log. No local WAL needed."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Durability and Availability"}),(0,c.jsx)("p",{children:"Data is durable once replicated to a majority of replicas. The cluster remains available as long as a majority of replicas are reachable. This provides both durability and availability without traditional logging overhead."})]})]}),(0,c.jsx)("div",{className:"pt-4",children:(0,c.jsx)("a",{href:"/docs/ignite3/3.1.0/sql/reference/language-definition/distribution-zones",className:"button button--shadow",target:"_blank",rel:"noreferrer",children:"Read Distribution Zones Documentation"})})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"What This Foundation Enables"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"ACID Transactions"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC provides snapshot isolation without blocking readers. Distributed replication ensures durability across partitions. Full ACID transactions work across any number of partitions."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Storage"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Raft-based replication provides durability without traditional write-ahead logging. AIPERSIST uses this for sub-millisecond persistence. AIMEM leverages version chains for microsecond-level access."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Concurrent Workloads"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC allows analytical queries and operational writes to run simultaneously. Long-running aggregations work on stable snapshots while real-time updates proceed at full throughput."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/features/sql",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/img/features/deployment/hero.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"High Availability"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Raft leader election ensures continuous operation during failures. Automatic failover completes in milliseconds. The cluster remains available as long as a majority of replicas are reachable."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)("a",{href:"/docs/ignite3/3.1.0/sql/reference/language-definition/distribution-zones",className:"cardsimple__button button button--shadow",target:"_blank",rel:"noreferrer",children:"Learn More"})})]})]})]}),(0,c.jsx)("section",{className:"native-bottom container",children:(0,c.jsxs)("div",{className:"native-bottom__grid",children:[(0,c.jsxs)("article",{className:"nativebotblock",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Ready to Start?"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,c.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Explore Features"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"See how these architectural foundations enable all Apache Ignite capabilities"}),(0,c.jsx)(t.A,{className:"nativebotblock__link arrowlink",to:"/features",children:"Features Overview"})]})]})})]})}},40830:(e,s,i)=>{i.d(s,{lZ:()=>r});var a=i(56347),t=i(44586);function r(){const e=(0,a.zy)(),{siteConfig:s}=(0,t.A)();let i=e.pathname;return"/"!==i&&i.endsWith("/")&&(i=i.slice(0,-1)),`${s.url}${i}`}}}]);
=======
"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[237],{40073:(e,s,i)=>{i.r(s),i.d(s,{default:()=>l});i(96540);var a=i(19766),t=i(28774),r=i(5260),n=i(40830),c=i(74848);function l(){const e=(0,n.lZ)();return(0,c.jsxs)(a.A,{children:[(0,c.jsxs)(r.A,{children:[(0,c.jsx)("title",{children:"Architectural Foundation - Apache Ignite"}),(0,c.jsx)("meta",{name:"description",content:"The architectural backbone of Apache Ignite: MVCC and distributed replication via Raft enable memory-first distributed computing without sacrificing consistency or availability."}),(0,c.jsx)("link",{rel:"canonical",href:e}),(0,c.jsx)("meta",{property:"og:title",content:"Architectural Foundation - Apache Ignite"}),(0,c.jsx)("meta",{property:"og:type",content:"article"}),(0,c.jsx)("meta",{property:"og:url",content:e}),(0,c.jsx)("meta",{property:"og:image",content:"/suggested-site/img/og-pic.png"}),(0,c.jsx)("meta",{property:"og:description",content:"The architectural backbone of Apache Ignite: MVCC and distributed replication via Raft enable memory-first distributed computing without sacrificing consistency or availability."})]}),(0,c.jsx)("section",{className:"innerhero",children:(0,c.jsxs)("div",{className:"container innerhero__cont",children:[(0,c.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,c.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,c.jsx)("h1",{className:"h1 innerhero__h1",children:"The Architectural Backbone"}),(0,c.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Two foundational choices that make memory-first distributed computing possible"})]}),(0,c.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/suggested-site/img/features/hero-bg.svg",alt:"Architectural Foundation"})]})}),(0,c.jsx)("section",{className:"container pt-5 pb-5",children:(0,c.jsx)("div",{className:"pt-3 pb-3",children:(0,c.jsx)("p",{className:"fz20",children:"Two foundational architectural choices enable everything Apache Ignite delivers. These aren't implementation details. They're the backbone that makes memory-first distributed computing possible without sacrificing consistency or availability."})})}),(0,c.jsxs)("section",{className:"nativepersistence3 container",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"MVCC: Multi-Version Concurrency Control"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"The Fundamental Problem"}),(0,c.jsx)("p",{children:"How do you serve reads and writes concurrently without blocking? Traditional locking approaches force a choice: either readers block writers, writers block readers, or you accept eventual consistency."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"The Solution"}),(0,c.jsx)("p",{children:"MVCC solves this by creating a new version for every write, tagged with a timestamp. Readers work against stable snapshots while writers create new versions. Readers and writers never block each other."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"How It Works"}),(0,c.jsx)("p",{children:"Every row exists as a version chain. Each write adds a new version with begin and commit timestamps. Transactions read from a snapshot determined by their start time. The system maintains multiple versions until older snapshots complete."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"What This Enables"}),(0,c.jsx)("p",{children:"Snapshot isolation (REPEATABLE_READ) without traditional locking overhead. Analytical queries execute on stable snapshots while transactional updates proceed at full speed. Long-running reads don't block operational writes."})]})]}),(0,c.jsx)("div",{className:"pt-4",children:(0,c.jsx)("a",{href:"/suggested-site/docs/ignite3/3.1.0/develop/work-with-data/transactions",className:"button button--shadow",target:"_blank",rel:"noreferrer",children:"Read Transactions Documentation"})})]}),(0,c.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-3",children:"Distributed Replication"}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"Consensus-Based Replication"}),(0,c.jsx)("p",{children:"Making distributed state changes safe requires consensus. Apache Ignite uses Raft consensus for replication. Each partition forms a Raft group with a leader and followers."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"How Leader Election Works"}),(0,c.jsx)("p",{children:"When a leader fails, the remaining nodes elect a new leader through the Raft protocol. Leader election completes in milliseconds. The new leader continues serving requests without data loss."})]})]}),(0,c.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,c.jsxs)("div",{className:"nativepersistence3__left",children:[(0,c.jsx)("h3",{className:"h5",children:"WAL-Free Architecture"}),(0,c.jsx)("p",{children:"Apache Ignite uses Raft consensus for durability instead of traditional write-ahead logs. The leader processes writes and replicates through the distributed consensus log. No local WAL needed."})]}),(0,c.jsxs)("div",{className:"nativepersistence3__right",children:[(0,c.jsx)("h3",{className:"h5",children:"Durability and Availability"}),(0,c.jsx)("p",{children:"Data is durable once replicated to a majority of replicas. The cluster remains available as long as a majority of replicas are reachable. This provides both durability and availability without traditional logging overhead."})]})]}),(0,c.jsx)("div",{className:"pt-4",children:(0,c.jsx)("a",{href:"/suggested-site/docs/ignite3/3.1.0/sql/reference/language-definition/distribution-zones",className:"button button--shadow",target:"_blank",rel:"noreferrer",children:"Read Distribution Zones Documentation"})})]}),(0,c.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,c.jsx)("h2",{className:"h4 pb-4",children:"What This Foundation Enables"}),(0,c.jsxs)("div",{className:"cardswrap",children:[(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/04-ACID-transactions.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"ACID Transactions"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC provides snapshot isolation without blocking readers. Distributed replication ensures durability across partitions. Full ACID transactions work across any number of partitions."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/02-native-persistence.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Storage"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Raft-based replication provides durability without traditional write-ahead logging. AIPERSIST uses this for sub-millisecond persistence. AIMEM leverages version chains for microsecond-level access."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/features/storage",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/03-distributed-SQL.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"Concurrent Workloads"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"MVCC allows analytical queries and operational writes to run simultaneously. Long-running aggregations work on stable snapshots while real-time updates proceed at full throughput."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)(t.A,{to:"/suggested-site/features/sql",className:"cardsimple__button button button--shadow",children:"Learn More"})})]}),(0,c.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,c.jsx)("div",{className:"cardsimple__icon",children:(0,c.jsx)("img",{src:"/suggested-site/img/features/deployment/hero.svg",alt:""})}),(0,c.jsx)("h3",{className:"cardsimple__title",children:"High Availability"}),(0,c.jsx)("div",{className:"cardsimple__text",children:"Raft leader election ensures continuous operation during failures. Automatic failover completes in milliseconds. The cluster remains available as long as a majority of replicas are reachable."}),(0,c.jsx)("div",{className:"cardsimple__bottom",children:(0,c.jsx)("a",{href:"/suggested-site/docs/ignite3/3.1.0/sql/reference/language-definition/distribution-zones",className:"cardsimple__button button button--shadow",target:"_blank",rel:"noreferrer",children:"Learn More"})})]})]})]}),(0,c.jsx)("section",{className:"native-bottom container",children:(0,c.jsxs)("div",{className:"native-bottom__grid",children:[(0,c.jsxs)("article",{className:"nativebotblock",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/suggested-site/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Ready to Start?"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,c.jsx)("a",{className:"nativebotblock__link arrowlink",href:"/suggested-site/docs/ignite3/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,c.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,c.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,c.jsx)("img",{src:"/suggested-site/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,c.jsx)("span",{children:"Explore Features"})]}),(0,c.jsx)("p",{className:"nativebotblock__text",children:"See how these architectural foundations enable all Apache Ignite capabilities"}),(0,c.jsx)(t.A,{className:"nativebotblock__link arrowlink",to:"/features",children:"Features Overview"})]})]})})]})}},40830:(e,s,i)=>{i.d(s,{lZ:()=>r});var a=i(56347),t=i(44586);function r(){const e=(0,a.zy)(),{siteConfig:s}=(0,t.A)();let i=e.pathname;return"/"!==i&&i.endsWith("/")&&(i=i.slice(0,-1)),`${s.url}${i}`}}}]);
>>>>>>> origin/master
