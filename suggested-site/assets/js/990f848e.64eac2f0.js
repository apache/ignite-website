"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[2194],{32628:(e,s,a)=>{a.r(s),a.d(s,{default:()=>c});a(96540);var i=a(19766),t=a(28774),r=a(5260),n=a(74848);function c(){return(0,n.jsxs)(i.A,{children:[(0,n.jsxs)(r.A,{children:[(0,n.jsx)("title",{children:"Backpressured Streaming - Apache Ignite"}),(0,n.jsx)("meta",{name:"description",content:"Apache Ignite provides reactive streaming with automatic backpressure control. DataStreamer delivers high-throughput ingestion while respecting cluster capacity. Integrates with MVCC and transactions for consistent data ingestion."}),(0,n.jsx)("link",{rel:"canonical",href:"https://ignite.apache.org/features/streaming"}),(0,n.jsx)("meta",{property:"og:title",content:"Backpressured Streaming - Apache Ignite"}),(0,n.jsx)("meta",{property:"og:type",content:"article"}),(0,n.jsx)("meta",{property:"og:url",content:"https://ignite.apache.org/features/streaming"}),(0,n.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,n.jsx)("meta",{property:"og:description",content:"Apache Ignite provides reactive streaming with automatic backpressure control. DataStreamer delivers high-throughput ingestion while respecting cluster capacity. Integrates with MVCC and transactions for consistent data ingestion."})]}),(0,n.jsx)("section",{className:"innerhero",children:(0,n.jsxs)("div",{className:"container innerhero__cont",children:[(0,n.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,n.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,n.jsx)("h1",{className:"h1 innerhero__h1",children:"Backpressured Streaming"}),(0,n.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Reactive streams with automatic rate coordination"})]}),(0,n.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Backpressured Streaming"})]})}),(0,n.jsx)("section",{className:"container pt-5 pb-5",children:(0,n.jsx)("div",{className:"pt-3 pb-3",children:(0,n.jsx)("p",{className:"fz20",children:"Apache Ignite provides reactive streaming with automatic backpressure control. DataStreamer delivers high-throughput ingestion while respecting cluster capacity. The system coordinates producer and consumer rates automatically. This prevents memory overflow and maintains cluster stability under high-velocity data streams."})})}),(0,n.jsxs)("section",{className:"nativepersistence3 container",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"Reactive Streaming with Backpressure"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Publisher Interface"}),(0,n.jsx)("p",{children:"DataStreamer implements reactive Publisher patterns. Producers publish data items. The system requests items based on cluster capacity. This pull-based approach prevents overwhelming the cluster with data faster than it can process."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Automatic Rate Coordination"}),(0,n.jsx)("p",{children:"The streaming system signals producers when ready for more data. Producers slow down when cluster capacity decreases. Producers speed up when capacity increases. This dynamic coordination happens automatically without manual tuning."})]})]}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Buffer Management"}),(0,n.jsx)("p",{children:"DataStreamer maintains internal buffers sized based on cluster capacity. Buffers absorb temporary rate mismatches. The system applies backpressure before buffers overflow. This prevents out-of-memory conditions during ingestion spikes."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Flow Control"}),(0,n.jsx)("p",{children:"The Publisher interface provides natural flow control. Applications receive signals when the cluster needs more data. Applications pause data generation when backpressure applies. This coordination works across network boundaries."})]})]})]}),(0,n.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"High-Throughput Ingestion"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Batching and Buffering"}),(0,n.jsx)("p",{children:"DataStreamer groups individual items into batches automatically. Batch sizes adapt to network conditions and cluster load. Larger batches reduce network overhead. Smaller batches reduce latency. The system balances throughput and latency dynamically."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Partition-Aware Distribution"}),(0,n.jsx)("p",{children:"The streamer routes data items to partition owners directly. Single-hop writes avoid coordinator overhead. Items for the same partition group together in batches. This optimization delivers maximum throughput for partitioned data."})]})]}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Parallel Processing"}),(0,n.jsx)("p",{children:"DataStreamer processes multiple batches in parallel across cluster nodes. Each node processes its partition data independently. This parallelism scales linearly with cluster size. Adding nodes increases total ingestion throughput proportionally."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Memory-First Writes"}),(0,n.jsx)("p",{children:"Streamed data writes directly to memory. No disk I/O during ingestion. Replication handles durability through distributed consensus. This memory-first approach delivers the throughput needed for high-velocity streams."})]})]})]}),(0,n.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"Integration with Transactions and MVCC"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Transactional Streaming"}),(0,n.jsx)("p",{children:"DataStreamer supports transactional writes. Batches commit atomically. Failures trigger automatic rollback. This ensures consistency for streamed data. Applications choose between throughput-optimized non-transactional mode or consistency-optimized transactional mode."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"MVCC Compatibility"}),(0,n.jsx)("p",{children:"Streaming writes create new MVCC versions. Concurrent queries see consistent snapshots. Long-running aggregations don't block streaming ingestion. Readers never block writers. This enables mixed streaming and analytical workloads."})]})]}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Upsert Semantics"}),(0,n.jsx)("p",{children:"DataStreamer supports upsert operations. Inserts new records. Updates existing records. Applications specify keys for conflict resolution. This handles duplicate events in streaming scenarios without application-level deduplication logic."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Ordered Processing"}),(0,n.jsx)("p",{children:"The system preserves ordering within partitions. Events for the same key process in order. Events across partitions process in parallel. This ordering guarantee simplifies event stream processing logic."})]})]})]}),(0,n.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-4",children:"Use Cases"}),(0,n.jsxs)("div",{className:"cardswrap",children:[(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/09-streaming.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Event Stream Processing"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"Ingest event streams at high velocity. Process events with transactional guarantees. Update multiple aggregations atomically. Backpressure prevents data loss during spikes. MVCC enables concurrent analytics on streaming data."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/use-cases/event-stream-processing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/05-key-value-APIs.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"IoT Data Ingestion"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"Stream sensor data from millions of devices. Partition-aware routing delivers maximum throughput. Memory-first writes provide minimal latency. Backpressure protects cluster during device bursts. Upsert semantics handle sensor state updates."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/use-cases/high-performance-computing",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Real-Time Aggregations"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"Stream events into base tables. Update materialized aggregations on write. Transactional streaming ensures consistent aggregates. Queries run against current aggregated state. No batch processing delays."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/use-cases/operational-analytics",className:"cardsimple__button button button--shadow",children:"View Use Case"})})]})]})]}),(0,n.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-4",children:"How Streaming Connects to the Foundation"}),(0,n.jsxs)("div",{className:"cardswrap",children:[(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Memory-First Ingestion"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"DataStreamer writes directly to memory without disk I/O. Distributed replication provides durability. This memory-first approach delivers the throughput needed for high-velocity event streams."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/features/storage",className:"cardsimple__button button button--shadow",children:"Learn About Storage"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Transactional Guarantees"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"Streaming writes support full ACID transactions. Batches commit atomically. MVCC enables concurrent queries during ingestion. This provides consistency without sacrificing streaming throughput."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/features/acid-transactions",className:"cardsimple__button button button--shadow",children:"Learn About Transactions"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/05-key-value-APIs.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Partition-Aware Routing"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"DataStreamer routes items to partition owners directly. Single-hop writes eliminate coordinator overhead. Items group by partition in batches. This optimization scales linearly with cluster size."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)("a",{href:"https://ignite.apache.org/suggested-site/docsconfigure-and-operate/operations/colocation",className:"cardsimple__button button button--shadow",target:"_blank",rel:"noreferrer",children:"Learn About Colocation"})})]})]})]}),(0,n.jsx)("section",{className:"native-bottom container",children:(0,n.jsxs)("div",{className:"native-bottom__grid",children:[(0,n.jsxs)("article",{className:"nativebotblock",children:[(0,n.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,n.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,n.jsx)("span",{children:"Ready to Start?"})]}),(0,n.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,n.jsx)("a",{className:"nativebotblock__link arrowlink",href:"https://ignite.apache.org/suggested-site/docsgetting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,n.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,n.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,n.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,n.jsx)("span",{children:"Read Documentation"})]}),(0,n.jsx)("p",{className:"nativebotblock__text",children:"Learn about DataStreamer configuration, batching strategies, and reactive patterns"}),(0,n.jsx)("a",{className:"nativebotblock__link arrowlink",href:"https://ignite.apache.org/suggested-site/docsdevelop/work-with-data/streaming",target:"_blank",rel:"noreferrer",children:"Streaming Documentation"})]})]})})]})}}}]);