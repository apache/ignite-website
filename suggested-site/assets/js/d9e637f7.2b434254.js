"use strict";(globalThis.webpackChunkdocusaurus=globalThis.webpackChunkdocusaurus||[]).push([[556],{41275:(e,s,a)=>{a.r(s),a.d(s,{default:()=>c});a(96540);var i=a(19766),t=a(28774),r=a(5260),n=a(74848);function c(){return(0,n.jsxs)(i.A,{children:[(0,n.jsxs)(r.A,{children:[(0,n.jsx)("title",{children:"Memory-First Storage Architecture - Apache Ignite"}),(0,n.jsx)("meta",{name:"description",content:"Apache Ignite places data and operations in memory by default. AIPERSIST provides persistent storage with sub-millisecond latency. AIMEM delivers microsecond-level access when durability is unnecessary."}),(0,n.jsx)("link",{rel:"canonical",href:"https://ignite.apache.org/features/storage"}),(0,n.jsx)("meta",{property:"og:title",content:"Memory-First Storage Architecture - Apache Ignite"}),(0,n.jsx)("meta",{property:"og:type",content:"article"}),(0,n.jsx)("meta",{property:"og:url",content:"https://ignite.apache.org/features/storage"}),(0,n.jsx)("meta",{property:"og:image",content:"/img/og-pic.png"}),(0,n.jsx)("meta",{property:"og:description",content:"Apache Ignite places data and operations in memory by default. AIPERSIST provides persistent storage with sub-millisecond latency. AIMEM delivers microsecond-level access when durability is unnecessary."})]}),(0,n.jsx)("section",{className:"innerhero",children:(0,n.jsxs)("div",{className:"container innerhero__cont",children:[(0,n.jsxs)("div",{className:"innerhero__main innerhero__main--long",children:[(0,n.jsx)("div",{className:"innerhero__pre pb-3",children:"Apache Ignite"}),(0,n.jsx)("h1",{className:"h1 innerhero__h1",children:"Memory-First Storage Architecture"}),(0,n.jsx)("div",{className:"innerhero__descr pt-2 h5",children:"Data lives in memory by default. Disk provides durability."})]}),(0,n.jsx)("img",{className:"innerhero__pic innerhero__pic--native",src:"/img/features/hero-bg.svg",alt:"Memory-First Storage"})]})}),(0,n.jsx)("section",{className:"container pt-5 pb-5",children:(0,n.jsx)("div",{className:"pt-3 pb-3",children:(0,n.jsx)("p",{className:"fz20",children:"Apache Ignite places data and operations in memory by default. Persistence provides durability rather than serving as the primary access path. This design delivers the latency characteristics needed for complex operations within shrinking transaction windows."})})}),(0,n.jsxs)("section",{className:"nativepersistence3 container",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"AIPERSIST: Persistent Storage with Memory-First Access"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"What It Provides"}),(0,n.jsx)("p",{children:"AIPERSIST keeps data in memory while maintaining durable copies on disk. The storage engine provides persistence with sub-millisecond latency for hot data. Data remains available after restarts without full reload."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"How It Works"}),(0,n.jsx)("p",{children:"Data modifications replicate through the distributed consensus log (Raft). No traditional write-ahead log needed. The storage engine persists data in sorted structures that support efficient scans and range queries."})]})]}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"When to Use"}),(0,n.jsx)("p",{children:"Use AIPERSIST when you need durability without sacrificing latency. Suitable for transactional workloads, event stream processing, and operational data stores where restart tolerance matters."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Memory Management"}),(0,n.jsx)("p",{children:"The storage engine automatically manages memory allocation. Hot data stays in memory. Cold data resides on disk but loads to memory on access. No manual cache configuration needed."})]})]})]}),(0,n.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"AIMEM: Pure Memory Storage"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"What It Provides"}),(0,n.jsx)("p",{children:"AIMEM stores data entirely in memory with no disk persistence. This delivers microsecond-level access latency when durability is unnecessary. Data exists only while the cluster runs."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"How It Works"}),(0,n.jsx)("p",{children:"Data replicates across cluster nodes for availability but never touches disk. Version chains support MVCC without persistence overhead. All coordination and transaction state stays in memory."})]})]}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi pt-4",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"When to Use"}),(0,n.jsx)("p",{children:"Use AIMEM for session state, real-time aggregations, temporary result sets, or derived data that can be recreated. Appropriate when restart tolerance isn't required or data has external durability."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Availability"}),(0,n.jsx)("p",{children:"AIMEM provides high availability through replication. Data remains accessible during node failures as long as a majority of replicas are reachable. Losing the majority means data loss."})]})]})]}),(0,n.jsxs)("section",{className:"nativepersistence3 container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-3",children:"RocksDB: Experimental Storage"}),(0,n.jsxs)("div",{className:"nativepersistence3__block flexi",children:[(0,n.jsxs)("div",{className:"nativepersistence3__left",children:[(0,n.jsx)("h3",{className:"h5",children:"Current Status"}),(0,n.jsx)("p",{children:"RocksDB storage remains experimental. It provides an alternative persistence approach for specialized workloads. Not recommended for production deployments until the implementation matures."})]}),(0,n.jsxs)("div",{className:"nativepersistence3__right",children:[(0,n.jsx)("h3",{className:"h5",children:"Characteristics"}),(0,n.jsx)("p",{children:"RocksDB offers different performance trade-offs compared to AIPERSIST. It may suit workloads with specific access patterns or storage requirements. Evaluate carefully before adoption."})]})]})]}),(0,n.jsxs)("section",{className:"container pt-5 pb-5",children:[(0,n.jsx)("h2",{className:"h4 pb-4",children:"How Storage Connects to the Foundation"}),(0,n.jsxs)("div",{className:"cardswrap",children:[(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/02-native-persistence.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Raft-Based Durability"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"AIPERSIST uses Raft consensus for durability instead of traditional write-ahead logs. Data replicates through the distributed consensus log. This eliminates local WAL overhead while providing durability."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About Distributed Replication"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/04-ACID-transactions.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"MVCC Version Chains"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"Both AIPERSIST and AIMEM leverage MVCC version chains. Multiple versions of each row enable snapshot isolation without blocking. Storage engines manage version cleanup automatically."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/features/architectural-foundation",className:"cardsimple__button button button--shadow",children:"Learn About MVCC"})})]}),(0,n.jsxs)("div",{className:"usecasecard cardsimple",children:[(0,n.jsx)("div",{className:"cardsimple__icon",children:(0,n.jsx)("img",{src:"/img/features/03-distributed-SQL.svg",alt:""})}),(0,n.jsx)("h3",{className:"cardsimple__title",children:"Memory-Resident Operations"}),(0,n.jsx)("div",{className:"cardsimple__text",children:"SQL queries, transactions, and compute jobs execute directly against in-memory data. No cache-miss penalties. No cache-warming strategies. Data already resides where processing happens."}),(0,n.jsx)("div",{className:"cardsimple__bottom",children:(0,n.jsx)(t.A,{to:"/features/sql",className:"cardsimple__button button button--shadow",children:"Learn About Access Patterns"})})]})]})]}),(0,n.jsx)("section",{className:"native-bottom container",children:(0,n.jsxs)("div",{className:"native-bottom__grid",children:[(0,n.jsxs)("article",{className:"nativebotblock",children:[(0,n.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,n.jsx)("img",{src:"/img/features/native-rocket.svg",alt:"",className:"nativebotblock__icon"}),(0,n.jsx)("span",{children:"Ready to Start?"})]}),(0,n.jsx)("p",{className:"nativebotblock__text",children:"Discover our quick start guide and build your first application in 5-10 minutes"}),(0,n.jsx)("a",{className:"nativebotblock__link arrowlink",href:"https://ignite-dev.gridgain.com/docs/3.1.0/getting-started/quick-start",target:"_blank",rel:"noreferrer",children:"Quick Start Guide"})]}),(0,n.jsxs)("article",{className:"nativebotblock nativebotblock--learn",children:[(0,n.jsxs)("div",{className:"h4 nativebotblock__title",children:[(0,n.jsx)("img",{src:"/img/features/native-docs.svg",alt:"",className:"nativebotblock__icon"}),(0,n.jsx)("span",{children:"Read Documentation"})]}),(0,n.jsx)("p",{className:"nativebotblock__text",children:"Learn about table creation, storage engines, and configuration options"}),(0,n.jsx)("a",{className:"nativebotblock__link arrowlink",href:"https://ignite-dev.gridgain.com/docs/3.1.0/develop/work-with-data/table-api",target:"_blank",rel:"noreferrer",children:"Tables Documentation"})]})]})})]})}}}]);